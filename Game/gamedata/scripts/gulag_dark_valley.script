-- -*- mode: lua; encoding: windows-1251 -*-

--------------------------------------------------------------------------
-- States
--------------------------------------------------------------------------
local state_normal = 0
local state_alarm = 1
local state_alarm_actor_inside = 2
local state_fight = 1

local ltx = ""
--------------------------------------------------------------------------
-- General
--------------------------------------------------------------------------
local t = {}
local gulags = {
	val_escort = {},
	val_sacrifice = {},
	val_prisoner = {},
	val_sos = {},
	val_rob = {},
	val_lager_bandits = {},
	val_watchtower = {},
	val_soldiers_raid = {},
	offline_group = {}
}

function get_gulag(gulag_type)
	return gulags[gulag_type]
end

--------------------------------------------------------------------------
-- Gulags
--------------------------------------------------------------------------

--------------------------------------------------------------------------
-- Escort (сцена спасения пленного долговца)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function e_predicate_n(npc_info) -- nap1
    return npc_info.story_id == story_ids.val_escort_nap1
end

function e_predicate_c(npc_info) -- captive
    return npc_info.story_id == story_ids.val_escort_captive
end

function e_predicate_w(npc_info) -- wounded bandit
    return npc_info.story_id == story_ids.val_escort_wounded
end

function e_predicate_g1(npc_info) -- guards
    return npc_info.story_id == story_ids.val_escort_guard1
end

function e_predicate_g2(npc_info) -- guards
    return npc_info.story_id == story_ids.val_escort_guard2
end

-- Jobs ------------------------------------------------------------------
gulags.val_escort.job = function(sj, gname, gulag_type, squad, groups)
-- игнорирование
    ltx = "[meet@ignore_abuse]\n" ..
                "use             = true\n" ..
                "use_wpn         = false\n" ..
                "abuse           = false\n"

    -- напарник с которым спасаем пленного
    t = { section = "logic@" .. gname .. "_nap1",
        prior = 1,
        squad = squad, group = groups[1],
        in_rest = "val_lager_bandits_restrictor", out_rest = "",
        online = true,
        predicate = e_predicate_n
    }
    table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_nap1.ltx\"\n"

    -- пленный
    t = { section = "logic@" .. gname .. "_captive",
        squad = squad, group = groups[1],
        in_rest = "val_lager_bandits_restrictor", out_rest = "",
        position_threshold = 50,
        online = true,
        predicate = e_predicate_c
    }
    table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_escort_captive.ltx\"\n"

    -- охранники ведущие пленного
    t = { section = "logic@" .. gname .. "_guard",
        squad = squad, group = groups[1],
        in_rest = "val_lager_bandits_restrictor", out_rest = "",
        position_threshold = 50,
        online = true,
        predicate = e_predicate_g1
    }
    table.insert(sj, t)

    t = { section = "logic@" .. gname .. "_guard",
        squad = squad, group = groups[1],
        in_rest = "val_lager_bandits_restrictor", out_rest = "",
        position_threshold = 50,
        online = true,
        predicate = e_predicate_g2
    }
    table.insert(sj, t)

    ltx = ltx.."[logic@" .. gname .. "_guard]\n" ..
               "active          = patrol@" .. gname .. "_guard_wait\n" ..
               "on_death        = death@" .. gname .. "_guard\n" ..
               "on_hit          = hit@" .. gname .. "_guard\n" ..
               "on_combat       = combat@" .. gname .. "_guard\n" ..
               "combat_ignore   = combat_ignore\n" ..

               "[death@" .. gname .. "_guard]\n" ..
               "on_info     = %=" .. gname .. "_guard_death%\n" ..

               "[hit@" .. gname .. "_guard]\n" ..
               "on_info     = %=" .. gname .. "_guard_hit%\n" ..

               "[combat@" .. gname .. "_guard]\n" ..
               "on_info     = %=" .. gname .. "_guard_combat%\n" ..

               "[danger@" .. gname .. "_guard]\n" ..
               "ignore_types                    = corpse\n" ..
               "ignore_distance_sound          = 30\n" ..
               "danger_inertion_time_sound      = 5000\n" ..
               "danger_inertion_time_hit        = 7000\n" ..
               "danger_inertion_time_ricochet   = 4000\n" ..

               -- wait for scene start
               "[patrol@" .. gname .. "_guard_wait]\n" ..
               "path_walk           = captive_wait_walk\n" ..
               "path_look           = captive_wait_look\n" ..
               "animation           = guard\n" ..
               "on_info             = {+val_escort_start}           follower@val_escort_guard_walk\n" .. --patrol
               "on_info2            = {+val_escort_combat}          remark@val_escort_guard_fight\n" ..
               "on_info3            = {+val_escort_captive_dead}    patrol@val_escort_guard_free\n" ..
               --"on_info3            = {+val_escort_captive_enemy}   remark@val_escort_guard_free\n" ..
               "danger              = danger@" .. gname .. "_guard\n" ..
               "combat_ignore_cond  = {=check_fighting(400) -val_escort_captive_enemy}\n" ..
--[[
               -- escort captive
               "[patrol@" .. gname .. "_guard_walk]\n" ..
               "path_walk           = captive_walk\n" ..
               "path_look           = captive_look\n" ..
               "formation           = back\n" ..
               --"animation           = patrol\n" ..
               "on_info             = {+val_escort_combat}          remark@val_escort_guard_fight\n" ..
               "on_info2            = {+val_escort_captive_dead}    remark@val_escort_guard_free\n" ..
               --"on_info3            = {+val_escort_captive_enemy}   remark@val_escort_guard_free\n" ..
               "danger              = danger@" .. gname .. "_guard\n" ..
               "combat_ignore_cond  = {=check_fighting(400) -val_escort_captive_enemy}\n" ..
--]]
               "[follower@" .. gname .. "_guard_walk]\n" ..
               "leader              = 400\n" ..
               "dont_change_job     = true\n" ..
               "anim_walk           = patrol\n" ..
               "anim_run            = assault\n" ..
               "on_info             = {+val_escort_combat}          remark@val_escort_guard_fight\n" ..
               "on_info2            = {+val_escort_captive_dead}    patrol@val_escort_guard_free\n" ..
               --"on_info3            = {+val_escort_captive_enemy}   remark@val_escort_guard_free\n" ..
               "danger              = danger@" .. gname .. "_guard\n" ..
               "combat_ignore_cond  = {=check_fighting(400) -val_escort_captive_enemy}, {=check_fighting(406)}\n" ..

               -- fight with actor and nap1
               "[remark@" .. gname .. "_guard_fight]\n" ..
               "anim                = wait_na\n" ..
               "on_info             = {+val_escort_nap1_dead}       patrol@val_escort_guard_free\n" ..
               "on_info2            = {+val_escort_captive_dead}    patrol@val_escort_guard_free\n" ..
               --"on_info3            = {+val_escort_captive_enemy}   remark@val_escort_guard_free\n" ..
               "combat_ignore_cond  = {=check_fighting(400) -val_escort_captive_enemy}\n" ..

               -- 
               "[patrol@" .. gname .. "_guard_free]\n" ..
               "path_walk           = guards_leave_walk\n" ..
               "def_state_moving1   = patrol\n" ..
               "def_state_moving2   = patrol\n" ..
               "formation           = line\n" ..
               "on_signal           = arrived | %=" .. gname .. "_guard_free%\n"
               --"[remark@" .. gname .. "_guard_free]\n" ..
               --"anim                = wait\n" ..
               --"on_info             = %=" .. gname .. "_guard_free%\n"

    -- раненый бандит в начале сцены
    t = { section = "logic@" .. gname .. "_halfdead",
        squad = squad, group = groups[1],
        in_rest = "val_lager_bandits_restrictor", out_rest = "",
        --online = true,
        predicate = e_predicate_w
    }
    table.insert(sj, t)

    ltx = ltx.."[logic@" .. gname .. "_halfdead]\n" ..
               "active          = remark@" .. gname .. "_halfdead_wait\n" ..
               "combat_ignore   = combat_ignore\n" ..

               "[wounded@" .. gname .. "_halfdead]\n" ..
               "hp_state        = 0|wounded_heavy@nil\n" ..
               "hp_state_see    = 0|wounded_heavy@nil\n" ..
               "hp_cover        = 0|false\n" ..
               "hp_fight        = 0|false\n" ..

               "[wounded@" .. gname .. "_halfdead1]\n" ..
               "hp_state        = 0|wounded_heavy@nil\n" ..
               "hp_state_see    = 0|wounded_heavy@nil\n" ..
               "hp_cover        = 0|false\n" ..
               "hp_fight        = 0|false\n" ..

               "[remark@" .. gname .. "_halfdead_wait]\n" ..
               "path_walk           = nap1_look\n" ..
               "anim                = wounded_heavy ;wait\n" ..
               "target              = 406\n" ..
               "on_info             = {+val_nap1_phrase1_end} remark@" .. gname .. "_halfdead_phrase\n" ..
               "wounded             = wounded@" .. gname .. "_halfdead\n" ..
               "combat_ignore_cond  = always\n" ..

               --------------------------------------------------------------------------
               -- фраза: Не-еет!!! Не убивай меня! Твоего напарника, сейчас будут вести на Базу Монолита.
               --        Это все, что я знаю...бля-буду...
               --------------------------------------------------------------------------
               "[remark@" .. gname .. "_halfdead_phrase]\n" ..
               "anim                = wounded_heavy ;wait\n" ..
               "snd                 = speech\n" ..
               "target              = 406\n" ..
               "on_signal           = sound_end | remark@" .. gname .. "_halfdead_end %+val_halfdead_phrase_end%\n" ..
               "wounded             = wounded@" .. gname .. "_halfdead1\n" ..
               "combat_ignore_cond  = always\n" ..

               "[remark@" .. gname .. "_halfdead_end]\n" ..
               "anim            = wounded_heavy ;wait\n" ..
               "target          = 406\n" ..
               "wounded         = wounded@" .. gname .. "_halfdead\n" ..
			   "combat_ignore_cond  = always\n"
end

gulags.val_escort.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.val_escort.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "dolg"
		or npc_community == "bandit"
end


--------------------------------------------------------------------------
-- Sacrifice (сцена возле ямы на главной базе бандитов)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function scf_predicate_v(npc_info) -- victim
    return npc_info.story_id == story_ids.val_sacrifice_victim
end

function scf_predicate_g1(npc_info) -- guard1
    return npc_info.story_id == story_ids.val_sacrifice_guard1
end

function scf_predicate_g2(npc_info) -- guard2
    return npc_info.story_id == story_ids.val_sacrifice_guard2
end

function scf_predicate_tb(npc_info) -- tunnel bandit
    return npc_info.story_id == story_ids.val_tunnel_bandit
end

-- Jobs ------------------------------------------------------------------
gulags.val_sacrifice.job = function(sj, gname, gulag_type, squad, groups)
    -- пленный, которого убивают
    t = { section = "logic@" .. gname .. "_victim",
        squad = squad, group = groups[1],
        in_rest = "", out_rest = "",
        online = true,
        predicate = scf_predicate_v
    }
    table.insert(sj, t)

    -- охранники
    t = { section = "logic@" .. gname .. "_guard1",
        squad = squad, group = groups[1],
        in_rest = "", out_rest = "",
        online = true,
        predicate = scf_predicate_g1
    }
    table.insert(sj, t)

    t = { section = "logic@" .. gname .. "_guard2",
        squad = squad, group = groups[1],
        in_rest = "", out_rest = "",
        online = true,
        predicate = scf_predicate_g2
    }
    table.insert(sj, t)

    -- бандит над трубой
    t = { section = "logic@" .. gname .. "_tunnel_bandit",
        squad = squad, group = groups[1],
        in_rest = "", out_rest = "",
        predicate = scf_predicate_tb
    }
    table.insert(sj, t)
end

gulags.val_sacrifice.ltx = function(gulag_name, gulag_type)
	return "[combat@" .. gulag_name .. "]\n" ..
			"on_info = {-val_bandit_talk =see_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

			--"[hit@" .. gulag_name .. "_guard]\n" ..
			--"on_info = {=hit_by_actor} %+val_sacrifice_plr_detected +val_sacrifice_finish%\n" ..

			"[danger@" .. gulag_name .. "_guard]\n" ..
			"ignore_distance               = 0\n" ..
			--"ignore_distance_sound      = 4\n" ..
			--"danger_inertion_time_sound = 2000\n" ..

			-- встреча отключена
			"[meet@" .. gulag_name .. "]\n" ..
			"meet_state     = 0|guard\n" ..
			"meet_state_wpn = 0|guard\n" ..
			"victim         = 0|actor\n" ..
			"victim_wpn     = 0|actor\n" ..
			"use            = true\n" ..
			"use_wpn        = false\n" ..

			"#include \"scripts\\val_sacrifice_victim.ltx\"\n" ..
			"#include \"scripts\\val_sacrifice_guard1.ltx\"\n" ..
			"#include \"scripts\\val_sacrifice_guard2.ltx\"\n" ..
			"#include \"scripts\\val_tunnel_bandit.ltx\"\n"
end

gulags.val_sacrifice.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "dolg"
		or npc_community == "bandit"
end

--------------------------------------------------------------------------
-- Prisoner (заключенный за решеткой в подвале на главной базе бандитов)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function p_predicate(npc_info) -- prisoner
    return npc_info.story_id == story_ids.val_prisoner
end

-- Jobs ------------------------------------------------------------------
gulags.val_prisoner.job = function(sj, gname, gulag_type, squad, groups)
    -- за решеткой
    t = { section = "logic@" .. gname,
        squad = squad, group = groups[1],
        out_rest = gname .. "_jail_restr",
        online = true,
        predicate = p_predicate
    }
    table.insert(sj, t)

    -- свободен
    t = { section = "logic@" .. gname .. "_free",
        squad = squad, group = groups[1],
        --online = true,
		state = {1},
        predicate = p_predicate
    }
    table.insert(sj, t)
end

gulags.val_prisoner.ltx = function(gulag_name, gulag_type)
	return "#include \"scripts\\val_prisoner_captive.ltx\"\n"
end

gulags.val_prisoner.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "dolg"
end
-- States ----------------------------------------------------------------
gulags.val_prisoner.state = function(gulag)
    if has_alife_info("val_prisoner_door_unlocked") then
        return 1
    end
    return 0
end


--------------------------------------------------------------------
-- Sos (раненый на заправке Мессер)
--------------------------------------------------------------------
-- Jobs ------------------------------------------------------------------
gulags.val_sos.job = function(sj, gname, gulag_type, squad, groups)
	t = { section = "logic@val_sos",
		predicate = function(obj_info)
						return obj_info.name == "val_sos_wounded"
					end
	}
	table.insert(sj, t)
end

gulags.val_sos.check_stalker = function (npc_community, gulag_type, npc_rank, se_obj)
	return se_obj:profile_name() == "val_sos_wounded"
end
--------------------------------------------------------------------
-- Robbers (грабители на ферме)
--------------------------------------------------------------------
-- Jobs --------------------------------------------------------------------
gulags.val_rob.job = function(sj, gname, gulag_type, squad, groups)
    local i = 0

    ltx = "[meet@ignore_abuse]\n" ..
                "use             = true\n" ..
                "use_wpn         = false\n" ..
                "abuse           = false\n" ..
                
                "[meet@" .. gname .. "_warn]\n" ..
                --"meet_state     = 20| {+val_rob_buying} threat, guard@ {+val_rob_buying} val_rob_guard_jeer\n" .. --, weather
                "meet_state     = 1| threat@threat_back\n" .. --, weather
                "meet_state_wpn = 25| threat@{+val_rob_buying} val_rob_guard_jeer, threat_back\n" ..
                "victim         = 20| actor\n" ..
                "victim_wpn     = 25| actor\n" ..
                "use            = true\n" ..
                "use_wpn        = false\n" ..
                "zone           = val_rob_warn_zone| {+val_rob_buying} threat@ {+val_rob_buying} val_rob_guard_jeer | val_rob_kill_zone| {+val_rob_buying} true \n" ..

                "[kamp@" .. gname .. "_kamp]\n" ..
                "center_point    = kamp\n" ..
                "meet            = meet@" .. gname .. "_warn\n"

    -- главный грабителей, с которым разговариваем
    t = { section = "logic@" .. gname .. "_leader",
        prior = 3,
        squad = squad, group = groups[1],
        in_rest = "", out_rest = ""
    }
    table.insert(sj, t)
    ltx = ltx.."#include \"scripts\\val_rob_leader.ltx\"\n"

    -- охранники на входах в здание фермы
    for i = 1, 2 do
        t = { section = "logic@" .. gname .. "_guard" .. i,
            prior = 2,
            squad = squad, group = groups[1],
            in_rest = "", out_rest = ""
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_guard" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_guard" .. i .. "\n" ..

                   "[walker@" .. gname .. "_guard" .. i .. "]\n" ..
                   "path_walk = guard" .. i .. "_walk\n" ..
                   "path_look = guard" .. i .. "_look\n" ..
                   "meet      = meet@" .. gname .. "_warn\n"
    end

    -- простые сталкеры внутри фермы вокруг костра
    for i = 1, 5 do
        t = { section = "logic@" .. gname .. "_kamp",
            prior = 1,
            squad = squad, group = groups[1],
            in_rest = "", out_rest = ""
        }
        table.insert(sj, t)
    end

    ltx = ltx.."[logic@" .. gname .. "_kamp]\n" ..
               "active = kamp@" .. gname .. "_kamp\n"
end

gulags.val_rob.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.val_rob.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "stalker"
end

--------------------------------------------------------------------------
-- Bandits (главная база бандитов)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function lb_predicate1(npc_info) 
    return npc_info.profile_name == "val_bandit_borov"
end

function lb_predicate_bg(npc_info) 
    return npc_info.profile_name == "val_bandit_bodyguard"
end

function lb_predicate2(npc_info) 
    return npc_info.profile_name == "val_bandit_veteran"
end

function lb_predicate3(npc_info) 
    return npc_info.profile_name == "val_bandit_general"
end

-- Jobs ------------------------------------------------------------------
gulags.val_lager_bandits.job = function(sj, gname, gulag_type, squad, groups)
    local i, v, j = 0, 0, 0
    local restr = 0
    ltx = ""
    --local combat_ignore = "combat_ignore_cond = {=val_bandits_ci}\n"
    --local combat_ignore = "combat_ignore_cond = {=check_fighting(400) -val_escort_captive_enemy}, {=check_fighting(401) -val_sacrifice_finish}, {=check_fighting(402) -val_prisoner_free}\n"
    local combat_ignore = "{=check_fighting(400) -val_escort_captive_enemy}, {=check_fighting(401) -val_sacrifice_finish}, {=check_fighting(402) -val_prisoner_free}\n"

    -- БОРОВ
    t = { section = "logic@" .. gname .. "_leader_normal",
		position_threshold = "graph",
        prior = 9, state = {state_normal},
        squad = squad, group = groups[1],
        online = "{+val_lager_bandits_show_leader_company}",
        out_rest   = gname .. "_borov_restrictor",
        predicate  = lb_predicate1
    }
    table.insert(sj, t)

    t = { section = "logic@" .. gname .. "_leader_alarm",
		position_threshold = "graph",
        prior = 9, state = {state_alarm},
        squad = squad, group = groups[1],
        online = "{+val_lager_bandits_show_leader_company}",
        out_rest   = gname .. "_borov_restrictor",
        predicate  = lb_predicate1
    }
    table.insert(sj, t)

    t = { section = "logic@" .. gname .. "_leader_alarm",
		position_threshold = "graph",
        prior = 9, state = {state_alarm_actor_inside},
        squad = squad, group = groups[1],
        online = "{+val_lager_bandits_show_leader_company}",
        out_rest   = gname .. "_borov_restrictor",
        predicate  = lb_predicate1
    }
    table.insert(sj, t)

    ltx = ltx.."[logic@" .. gname .. "_leader_normal]\n" ..
               "active = walker@" .. gname .. "_leader_normal\n" ..
               "on_death = death@" .. gname .. "_borov\n" ..
               "combat_ignore = combat_ignore\n" ..

               "[death@" .. gname .. "_borov]\n" ..
               "on_info = %+val_borov_dead =sak.bandits_enemy%\n" ..

               "[walker@" .. gname .. "_leader_normal]\n" ..
               "path_walk = leader_walk\n" ..
               "path_look = leader_look\n" ..
               --"show_spot = false\n" ..
               "combat_ignore_cond = " .. combat_ignore ..
               "meet = meet@" .. gname .. "_leader_normal\n" ..

               "[meet@" .. gname .. "_leader_normal]\n" ..
			   "use = true\n" ..
			   "use_wpn = false\n" ..
			   "meet_talk_enabled = true\n" ..
			   "meet_state = 4|choose@jila_hello|2|choose\n" ..
			   "meet_state_wpn = 4|choose@jila_hello|2|choose\n" ..

               "[logic@" .. gname .. "_leader_alarm]\n" ..
               "active = camper@" .. gname .. "_leader_alarm\n" ..
               "on_death = death@" .. gname .. "_borov\n" ..
               "combat_ignore = combat_ignore\n" ..

               "[camper@" .. gname .. "_leader_alarm]\n" ..
               "path_walk = leader_alarm_walk\n" ..
               "path_look = leader_alarm_look\n" ..
               "radius    = 15\n" ..
               --"show_spot = false\n" ..
               "combat_ignore_cond = " .. combat_ignore ..
               "meet = meet@" .. gname .. "_leader_alarm\n" ..

               "[meet@" .. gname .. "_leader_alarm]\n" ..
			   "use = true\n" ..
			   "use_wpn = false\n" ..
			   "meet_talk_enabled = true\n" ..
			   "meet_state = 4|hide@jila_hello|2|hide\n" ..
			   "meet_state_wpn = 4|hide@jila_hello|2|hide\n"

    -- ОХРАННИКИ БОРОВА
    for i = 1, 3 do
        t = { section = "logic@" .. gname .. "_bodyguard_normal" .. i,
			position_threshold = "graph",
            prior = 8, state = {state_normal},
            squad = squad, group = groups[1],
            online = "{+val_lager_bandits_show_leader_company}",
            out_rest   = gname .. "_main_building_restrictor",
            predicate  = lb_predicate_bg
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
			position_threshold = "graph",
            prior = 8, state = {state_alarm},
            squad = squad, group = groups[1],
            online = "{+val_lager_bandits_show_leader_company}",
            out_rest   = gname .. "_main_building_restrictor",
            predicate  = lb_predicate_bg
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_bodyguard_alarm" .. i,
			position_threshold = "graph",
            prior = 8, state = {state_alarm_actor_inside},
            squad = squad, group = groups[1],
            online = "{+val_lager_bandits_show_leader_company}",
            out_rest   = gname .. "_main_building_restrictor",
            predicate  = lb_predicate_bg
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_bodyguard_normal" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_bodyguard_normal" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[walker@" .. gname .. "_bodyguard_normal" .. i .. "]\n" ..
                   "path_walk = bodyguard_walk" .. i .. "\n" ..
                   "path_look = bodyguard_look" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore ..

                   "[logic@" .. gname .. "_bodyguard_alarm" .. i .. "]\n" ..
                   "active = camper@" .. gname .. "_bodyguard_alarm" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[camper@" .. gname .. "_bodyguard_alarm" .. i .. "]\n" ..
                   "path_walk = bodyguard_alarm_walk" .. i .. "\n" ..
                   "path_look = bodyguard_alarm_look" .. i .. "\n" ..
                   "radius = 10\n" ..
                   "combat_ignore_cond = " .. combat_ignore
    end

    -- СИДЯЩИЕ В КЕМПЕ 1 ВОЗЛЕ БОРОВА И В КЕМПЕ 2 НА ВТОРОМ ЭТАЖЕ
    restr = {gname .. "_main_building_restrictor", gname .. "_nedostroyka_restrictor", gname .. "_nedostroyka_restrictor", gname .. "_restrictor"}
    onlineid = {"{+val_lager_bandits_show_leader_company}", "{+val_lager_bandits_show_nedostroyka_company}", "{+val_lager_bandits_show_nedostroyka_company}"}
    local pr = {7, 5, 5, 2}
    for i, v in pairs({3, 4, 2, 3}) do
        ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "active = kamp@" .. gname .. "_kamp" .. i .. "_normal\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[kamp@" .. gname .. "_kamp" .. i .. "_normal]\n" ..
                   "center_point = kamp" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore

        for j = 1, v do
            t = { section = "logic@" .. gname .. "_kamp" .. i .. "_normal",
				position_threshold = "graph",
                prior = pr[i], state = {state_normal},
                squad = squad, group = groups[i],
                online = onlineid[i],
                out_rest = restr[i]
            }
            table.insert(sj, t)

            t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
				position_threshold = "graph",
                prior = pr[i], state = {state_alarm},
                squad = squad, group = groups[i],
                online = onlineid[i],
                out_rest = restr[i]
            }
            table.insert(sj, t)

            t = { section = "logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j,
				position_threshold = "graph",
                prior = 7, state = {state_alarm_actor_inside},
                squad = squad, group = groups[i],
                online = onlineid[i],
                out_rest = restr[i]
            }
            table.insert(sj, t)

            ltx = ltx.."[logic@" .. gname .. "_kamp" .. i .. "_alarm" .. j .. "]\n" ..
                       "active = camper@" .. gname .. "_kamp" .. i .. "_alarm" .. j .. "\n" ..
                       "combat_ignore = combat_ignore\n" ..

                       "[camper@" .. gname .. "_kamp" .. i .. "_alarm" .. j .. "]\n" ..
                       "path_walk = kamp" .. i .. "_alarm_walk" .. j .. "\n" ..
                       "path_look = kamp" .. i .. "_alarm_look" .. j .. "\n" ..
                       "def_state_moving = assault\n" ..
                       "radius = 8\n" ..
                       --"combat_ignore_cond = {=val_bandits_ci_actor(35)}\n"
                       "combat_ignore_cond = {=fighting_actor =dist_to_actor_ge(35)}, " .. combat_ignore
        end
    end

    -- БАНДИТЫ
    local quantity = {2, 4, 1, 4}

    -- guards
    restr = {gname .. "_main_side_restrictor", gname .. "_restrictor"}
    for i = 1, quantity[1] do
        t = { section = "logic@" .. gname .. "_guard_normal" .. i,
			position_threshold = "graph",
            prior = 6, state = {state_normal},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_guard_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_guard_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm_actor_inside},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_guard_normal" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_guard_normal" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[walker@" .. gname .. "_guard_normal" .. i .. "]\n" ..
                   "path_walk = guard_walk" .. i .. "\n" ..
                   "path_look = guard_look" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore ..

                   "[logic@" .. gname .. "_guard_alarm" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_guard_alarm" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..
                   
                   "[walker@" .. gname .. "_guard_alarm" .. i .. "]\n" ..
                   "path_walk = guard_alarm_walk" .. i .. "\n" ..
                   "path_look = guard_alarm_look" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore
    end

    -- patrols
    restr = {gname .. "_main_side_restrictor", gname .. "_restrictor", gname .. "_restrictor", gname .. "_restrictor"}
    for i = 1, quantity[2] do
        t = { section = "logic@" .. gname .. "_patrol_normal" .. i,
			position_threshold = "graph",
            prior = 5, state = {state_normal},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_patrol_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_patrol_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm_actor_inside},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_patrol_normal" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..
                    
                   "[walker@" .. gname .. "_patrol_normal" .. i .. "]\n" ..
                   "path_walk = patrol_walk" .. i .. "\n" ..
                   "path_look = patrol_look" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore ..
                    
                   "[logic@" .. gname .. "_patrol_alarm" .. i .. "]\n" ..
                   "active = walker@" .. gname .. "_patrol_alarm" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..
                    
                   "[walker@" .. gname .. "_patrol_alarm" .. i .. "]\n" ..
                   "path_walk = patrol_alarm_walk" .. i .. "\n" ..
                   "path_look = patrol_alarm_look" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore
    end

    -- snipers
    restr = {gname .. "_restrictor"}
    for i = 1, quantity[3] do
        t = { section = "logic@" .. gname .. "_sniper_normal" .. i,
			position_threshold = "graph",
            prior = 4, state = {state_normal},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_sniper_alarm" .. i,
			position_threshold = "graph",
            prior = 4, state = {state_alarm},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_sniper_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm_actor_inside},
            squad = squad, group = groups[1],
            out_rest = restr[i]
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_sniper_normal" .. i .. "]\n" ..
                   "active = camper@" .. gname .. "_sniper_normal" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[camper@" .. gname .. "_sniper_normal" .. i .. "]\n" ..
                   "path_walk = sniper_walk" .. i .. "\n" ..
                   "path_look = sniper_look" .. i .. "\n" ..
                   "def_state_moving = patrol\n" ..
                   "def_state_moving_fire = patrol_fire\n" ..
                   "def_state_campering = guard\n" ..
                   "def_state_campering_fire = guard_fire\n" ..
                   "combat_ignore_cond = " .. combat_ignore ..

                   "[logic@" .. gname .. "_sniper_alarm" .. i .. "]\n" ..
                   "active = camper@" .. gname .. "_sniper_alarm" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[camper@" .. gname .. "_sniper_alarm" .. i .. "]\n" ..
                   "path_walk = sniper_alarm_walk" .. i .. "\n" ..
                   "path_look = sniper_alarm_look" .. i .. "\n" ..
                   "def_state_moving = sneak\n" ..
                   "def_state_moving_fire = sneak_fire\n" ..
                   "def_state_campering = threat\n" ..
                   "def_state_campering_fire = threat_sniper_fire\n" ..
                   "sniper = true\n" ..
                   --"combat_ignore_cond = {=val_bandits_ci_actor(35)}\n"
                   "combat_ignore_cond = {=fighting_actor =dist_to_actor_ge(35)}, " .. combat_ignore
    end

    -- sleepers
    for i = 1, quantity[4] do
        t = { section = "logic@" .. gname .. "_sleeper_normal" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_normal},
            squad = squad, group = groups[2],
            online = "{+val_lager_bandits_show_nedostroyka_company}",
            out_rest = gname .. "_nedostroyka_restrictor", --info_restr = gname .. "_nedostroyka_info_restr"
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_sleeper_alarm" .. i,
			position_threshold = "graph",
            prior = 3, state = {state_alarm},
            squad = squad, group = groups[2],
            online = "{+val_lager_bandits_show_nedostroyka_company}",
            out_rest = gname .. "_nedostroyka_restrictor", --info_restr = gname .. "_nedostroyka_info_restr"
        }
        table.insert(sj, t)

        t = { section = "logic@" .. gname .. "_sleeper_alarm" .. i,
			position_threshold = "graph",
            prior = 6, state = {state_alarm_actor_inside},
            squad = squad, group = groups[2],
            online = "{+val_lager_bandits_show_nedostroyka_company}",
            out_rest = gname .. "_nedostroyka_restrictor", --info_restr = gname .. "_nedostroyka_info_restr"
        }
        table.insert(sj, t)

        ltx = ltx.."[logic@" .. gname .. "_sleeper_normal" .. i .. "]\n" ..
                   "active = sleeper@" .. gname .. "_sleeper_normal" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..
                    
                   "[sleeper@" .. gname .. "_sleeper_normal" .. i .. "]\n" ..
                   "path_main = sleeper" .. i .. "\n" ..
                   "combat_ignore_cond = " .. combat_ignore ..
                    
                   "[logic@" .. gname .. "_sleeper_alarm" .. i .. "]\n" ..
                   "active = camper@" .. gname .. "_sleeper_alarm" .. i .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..
                    
                   "[camper@" .. gname .. "_sleeper_alarm" .. i .. "]\n" ..
                   "path_walk = sleeper_alarm_walk" .. i .. "\n" ..
                   "path_look = sleeper_alarm_look" .. i .. "\n" ..
                   "def_state_moving = assault\n" ..
                   "radius = 8\n" ..
                   --"combat_ignore_cond = {=val_bandits_ci_actor(30)}\n"
                   "combat_ignore_cond = {=fighting_actor =dist_to_actor_ge(30)}, " .. combat_ignore
    end

    --ltx = ltx.."#include \"misc\\gulag_dark_valley.ltx\"\n"

	-- ЖИЛА
    t = { section = "logic@" .. gname .. "_trader",
		position_threshold = "graph",
        prior = 9, state = {state_normal, state_alarm, state_alarm_actor_inside},
        squad = squad, group = groups[1],
        online = "{+val_lager_bandits_show_leader_company}",
        out_rest   = gname .. "_main_building_restrictor",
        predicate  = function(npc_info)
			return npc_info.profile_name == "val_bandit_trader"
		end
    }
    table.insert(sj, t)

    ltx = ltx.."[logic@" .. gname .. "_trader]\n" ..
               "active = walker@" .. gname .. "_trader\n" ..
               "combat_ignore = combat_ignore\n" ..

               "[walker@" .. gname .. "_trader]\n" ..
               "path_walk = trader_walk\n" ..
               "path_look = trader_look\n" ..
               "combat_ignore_cond = " .. combat_ignore ..
               "meet = meet@" .. gname .. "_trader\n" ..

               "[meet@" .. gname .. "_trader]\n" ..
               "meet_state = 5| {+npc_greet} wait_trade, wait_trade@ {+npc_greet} talk_bye %-npc_greet% |4| {-npc_greet} wait_trade, wait_trade@ {-npc_greet} talk_hello %+npc_greet%\n" ..
               "meet_state_wpn = 5| {+npc_greet} wait_trade, wait_trade@ {+npc_greet} talk_bye %-npc_greet% |4| {-npc_greet} wait_trade, wait_trade@ {-npc_greet} talk_hello %+npc_greet%\n" ..
               "use = true\n" ..
               "use_wpn = false\n" ..
               "meet_talk_enabled = true\n" ..
               "precond = visibility\n"
end

gulags.val_lager_bandits.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.val_lager_bandits.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "bandit"
end

-- States ----------------------------------------------------------------
gulags.val_lager_bandits.state = function(gulag)
	-- if has_alife_info("val_bandit_talk") then
		-- return state_normal
	-- end

    if (gulag.state == state_alarm or gulag.state == state_alarm_actor_inside) and
        game.get_game_time():diffSec(gulag.stateBegin) < 12000 -- 200 minutes
    then
        return gulag.state
    else
        for k,v in pairs(gulag.Object) do
            if v ~= true then
                local enemy = v:best_enemy()
                if enemy ~= nil then
                    local enemy_type = enemy:clsid()
                    if enemy_type == clsid.actor and
                        utils.npc_in_zone(Actor, db.zone_by_name["val_lager_bandits_restrictor"]) then
                        -- log("gulag <val_lager_bandits>: STATE ALARM ACTOR")
                        return state_alarm_actor_inside
                    end
                    if enemy_type == clsid.actor or enemy_type == clsid.script_stalker then --or enemy_type == clsid.trader
                        -- log("gulag <val_lager_bandits>: STATE ALARM")
                        return state_alarm
                    end
                end
            end
        end
    end
    
    -- log("gulag <val_lager_bandits>: STATE NORMAL")
    return state_normal
end


--------------------------------------------------------------------------
-- Offline group (гулаг для держания сталкеров в оффлайне до определенного момента)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.offline_group.job = function(sj, gname, gulag_type, squad, groups)
    local i, it = 0, 1
    ltx = ""
    local pname = "offgroup"
    local phdr = gname .. "_" .. pname .. "_"

    while true do
        local way_name = phdr .. it
        
        if not level.patrol_path_exists(way_name) then
            break
        end

        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
        local job_count, prior = 5, 1

        -- Необходимо вычитать количество работ из названия точки пути.
        if wp_prop.count ~= nil then
            job_count = wp_prop.count
        end

        if wp_prop.prior ~= nil then
            prior = wp_prop.prior
        end

        for i = 1, job_count do
            -- добавляем должность
            t = { section = "logic@" .. way_name,
                idle = 0,
                prior = prior, state = {0}, squad = squad, group = groups[1],
                position_threshold = 20, in_rest = "", out_rest = "",
                online = false
            }
            table.insert(sj, t)
        end

        -- добавляем описание должности в лтх.
        ltx = ltx .. "[logic@" .. way_name .. "]\n" ..
                     "active    = remark@" .. way_name .. "\n" ..

                     "[remark@" .. way_name .. "]\n" ..
                     "path_walk = " .. pname .. "_" .. it .. "\n" ..
                     "anim      = wait_na\n"
        it = it + 1
    end
end

gulags.offline_group.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.offline_group.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return true
end


--------------------------------------------------------------------------
-- Soldiers raid group (аналог general_lager только с дополнительными рестрикторами)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------

-- Jobs ------------------------------------------------------------------
gulags.val_soldiers_raid.job = function(sj, gname, gulag_type, squad, groups)
    local i = 1

    ltx = "[danger@ignore_corpse]\n" ..
          "ignore_types = corpse\n"
          
    local idstr = gname .. "_guard"
    while level.patrol_path_exists(idstr .. "_" .. i .. "_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local way_name = idstr .. "_" .. i .. "_walk"

        -- добавляем должность
        t = { section = "logic@" .. idstr .. i,
            idle = 0,
            prior = 1, state = {0}, squad = squad, group = groups[1],
            --position_threshold = 10,
            in_rest = "", out_rest = gname .. "_restr" --, info_rest = ""
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. i .. "]\n" ..
                   "active = camper@" .. idstr .. i .. "\n" ..

                   "[camper@" .. idstr .. i .. "]\n" ..
                   --"meet                = meet@generic_lager_guard\n" ..
                   "path_walk           = guard_" .. i .. "_walk\n" ..
                   "def_state_moving    = assault\n" ..
                   "radius              = 10\n" ..
                   --"def_state_moving2   = patrol\n" ..
                   "danger              = danger@ignore_corpse\n"

        if level.patrol_path_exists(idstr .. "_" .. i .. "_look") then
            ltx = ltx.."path_look = guard_" .. i .. "_look\n"
        end

        i = i + 1
    end

    local j = 0
    i = 1
    idstr = gname .. "_raid"
    while level.patrol_path_exists(idstr .. "_" .. i .. "_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local way_name = idstr .. "_" .. i .. "_walk"
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		if wp_prop.count ~= nil then
			job_count = wp_prop.count
		end

		for j = 1, job_count do
            -- добавляем должность
            t = { section = "logic@" .. idstr .. i,
                idle = 0,
                prior = 1, state = {1}, squad = squad, group = groups[1],
                --position_threshold = 10,
                in_rest = "", out_rest = gname .. "_restr"
            }
            table.insert(sj, t)
        end

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. i .. "]\n" ..
                   "active = patrol@" .. idstr .. i .. "\n" ..

                   "[patrol@" .. idstr .. i .. "]\n" ..
                   "path_walk           = raid_" .. i .. "_walk\n" ..
                   "formation           = around\n" ..
                   "def_state_moving1   = assault\n" ..
                   "def_state_moving2   = assault\n" ..
                   "danger              = danger@ignore_corpse\n"

        if level.patrol_path_exists(idstr .. "_" .. i .. "_look") then
            ltx = ltx.."path_look = raid_" .. i .. "_look\n"
        end

        i = i + 1
    end
end

gulags.val_soldiers_raid.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.val_soldiers_raid.state = function(gulag)
	if gulag.state == 0 then
		if gulag.state_switch_1 and xr_logic.pick_section_from_condlist(Actor, gulag.smrttrn, gulag.state_switch_1) ~= nil then
			return 1
		end
		return 0
	elseif gulag.state == 1 then
		if gulag.state_switch_0 and xr_logic.pick_section_from_condlist(Actor, gulag.smrttrn, gulag.state_switch_0) ~= nil then
			return 0
		end
		return 1
	end
end

gulags.val_soldiers_raid.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "military"
end


--------------------------------------------------------------------------
-- WatchTower (смотровые вышки)
--------------------------------------------------------------------------
-- Predicates ------------------------------------------------------------
function wt_predicate_g(npc_info, gulag) -- guard
    return string.find(npc_info.name, gulag.type) ~= nil
end

function wt_predicate_s(npc_info, gulag) -- sniper
    return string.find(npc_info.name, gulag.type) ~= nil and npc_info.is_sniper == true
end

-- Jobs ------------------------------------------------------------------
gulags.val_watchtower.job = function(sj, gname, gulag_type, squad, groups)
    local i = 1
	ltx = ""

    -- Проверяем наличие часовых на вышке.
    local idstr = gname .. "_guard"
    while level.patrol_path_exists(idstr .. "_" .. i .. "_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local way_name = idstr .. "_" .. i .. "_walk"

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            prior = 1, squad = squad, group = groups[1],
            position_threshold = 10,
        --  predicate = wt_predicate_g,
            out_rest = gname .. "_restr"
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "active = walker@" .. idstr .. "\n" ..
                   "combat_ignore = combat_ignore\n" ..

                   "[walker@" .. idstr .. "]\n" ..
				   "combat_ignore_cond  = {=check_fighting(400) -val_escort_captive_enemy}, {=check_fighting(401) -val_sacrifice_finish}, {=check_fighting(422)}\n" ..
                   -- "meet                = meet@generic_lager_guard\n" ..
                   "path_walk           = guard_" .. i .. "_walk\n" ..
                   "def_state_moving1   = patrol\n" ..
                   "def_state_moving2   = patrol\n"

        if level.patrol_path_exists(idstr .. "_" .. i .. "_look") then
            ltx = ltx.."path_look = guard_" .. i .. "_look\n"
        end

        i = i + 1
    end

    -- Проверяем наличие снайперов на вышке.
    i = 1
    idstr = gname .. "_sniper"
    while level.patrol_path_exists(idstr .. "_" .. i .."_walk") do
        -- Необходимо вычитать количество работ из названия точки пути.
        local way_name = idstr .. "_" .. i .."_walk"
        local ptr = patrol(way_name)
        local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
        local d_sniper, d_wait, d = 20, 90, 0
        if wp_prop.ds ~= nil then
            d = tonumber(wp_prop.ds)
            if d ~= nil and d > 0 then
                d_sniper = d
            end
        end
        if wp_prop.dw ~= nil then
            d = tonumber(wp_prop.dw)
            if d ~= nil and d > 0 then
                d_wait = d
            end
        end

        -- добавляем должность
        t = { section = "logic@" .. idstr,
            prior = 2, squad = squad, group = groups[1],
            position_threshold = 10,
            in_rest = "", out_rest = gname .. "_restr"
        --  predicate = wt_predicate_s
        }
        table.insert(sj, t)

        -- добавляем описание должности в лтх.
        ltx = ltx.."[logic@" .. idstr .. "]\n" ..
                   "active = camper@" .. idstr .. "\n" ..

                   "[camper@" .. idstr .. "]\n" ..                            
                   "path_walk                   = sniper_" .. i .. "_walk\n" ..
                   "path_look                   = sniper_" .. i .. "_look\n" ..
                   "def_state_campering         = threat\n" ..
                   "def_state_campering_fire    = threat_sniper_fire\n" ..
                   "sniper                      = true\n" ..
                   "on_actor_dist_le_nvis       = 50 | walker@" .. idstr .. "_free\n" ..
                   "on_timer                    = " .. d_sniper .. "000 | remark@" .. idstr .. "\n" ..

                   "[walker@" .. idstr .. "_free]\n" ..                            
                   "path_walk                   = sniper_" .. i .. "_walk\n" ..
                   "path_look                   = sniper_" .. i .. "_look\n" ..
                   "on_actor_dist_ge_nvis       = 60 | camper@" .. idstr .. "\n" ..

                   "[remark@" .. idstr .. "]\n" ..                            
                   "anim                    = guard\n" ..
                   "on_actor_dist_le_nvis   = 50 | walker@" .. idstr .. "_free\n" ..
                   "on_timer                = " .. d_wait .. "000 | camper@" .. idstr .. "\n"

        i = i + 1
    end
end

gulags.val_watchtower.ltx = function(gulag_name, gulag_type)
	return ltx
end

gulags.val_watchtower.check_stalker = function(npc_community, gulag_type, npc_rank, se_obj)
	return npc_community == "bandit"
end


