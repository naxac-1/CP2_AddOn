-- -*- mode: lua; encoding: windows-1251 -*-
--[[

File:  amk_mod .script
copyright © AMK TEAM 2007-2008

добавлена  fenechka by TAG

--]]

local math_random = math.random
local math_pi = math.pi
local math_sin = math.sin
local math_cos = math.cos
local math_ceil = math.ceil
local string_find = string.find
local string_sub = string.sub

local w
in_hide=false
local sound_obj_right,sound_obj_left,snd_volume,snd_obj_eq


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      QUEST_AF_STAR        **   **   **   **    **   **   **   ** 
--'*******************************************************************************
local points={
    {
        position={x=-24.2727108001709,y=-12.1660995483398,z=-100.200202941895},
        gv=0,
        lv=73868
        },
    {
        position={x=159.56,y=4.72,z=88.60},
        gv=155,
        lv=463808
        },
    {
        position={x=-4.11,y=2.90,z=108.09},
        gv=85,
        lv=272619
        }
}
function test_star()
	for i, a in ipairs(points) do
		local str = news_main.get_point_description("l01_escape", vector():set(a.position.x,a.position.y,a.position.z))
		log("%d :: %s", i, str)
	end
end

function spawn_star(actor,npc,p1,p2)
	local n = math_random(#points)
    local a = points[n]
    local obj = AI:create_free("amk_af_night_star", vector():set(a.position.x,a.position.y,a.position.z), a.lv, a.gv)
	if (obj) then
		if is_debug==true then add_spot_on_map(obj.id, "red_location", "art") end
	end
	local m_where 
	if news_main then
		m_where = news_main.get_point_description("l01_escape", vector():set(a.position.x,a.position.y,a.position.z))
	else
		m_where = "здесь, на кордоне"
	end
	Actor:give_talk_message(m_where.." скорее всего поискать стоит. Где-то там он, точно говорю.", "ui\\ui_iconstotal", Frect():set(0,0,10,10), "simple_answer_item")
	
	local task = CGameTask()
	task:load("esc_test_art_task")
	local objective = task:get_objective(0)
	objective:set_article_id("esc_test_art_task_"..n)
	Actor:give_task(task, -1, true)
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        FIRST_RUN          **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function first_run() 
	-- На момент вызова этой функции актор уже доступен - переделано на поршень. То, что отключено, обозначено ----
	if not has_alife_info("x_first_run") then 
		amk.spawn_item("amk_zapiska",vector():set(-126.96,-28.41,-379.12),27,125181)
		amk.spawn_item("amk_zapiska",vector():set(21.6,-3.94,-18.28),1140,5991)
		AI:create_free("amk_zapiska",vector():set(124.86881256104,31.754182815552,-13.352614402771),7186,1543)
		AI:create("darkscape_teleport_01",vector():set(-248.57592773438,12.540954589844,-329.14068603516),139494,3997)

		sak.add_new_lcitem()

		spawn_military_btr()	
		spawn_fuel()

		meceniy_work.main()

		level_changers.first_run()

		braad_test.marsh_band_spawn()

		Actor:give_info_portion("x_first_run")
	end

	-- фикс пропадания таймеров 
	if not has_timer("show_news") then
		start_game_timer("show_news",0,0,10)
	end
end
--'*******************************************************************************
--'   **   **   **   **   **    **   **   **        CHECK_SPAWN          **   **   **   **   **    **   **   **  
--'*******************************************************************************
function check_spawn()
--[[
	Не переставлять нижеследующие функции местами!!!
	Сначала должна загрузиться таблица labels в gps_habar,
	потом из sak_off_corpses, через проверку по ней, добавляются предметы.
	Так же в sak_off_corpses удаляются аномалии,
	а в amk_anoms спавнятся.
	Через sak_off_corpses в таблицу respawners в amk_mod добавляются АМК-ашные респавнеры,
	в spawn_unspawned_respawners эта таблица используется для проверки.
	Всё это должно происходить только в такой последовательности.
]]
-->>
    gps_habar.on_game_load()
	amk_offline_alife.init()
    sak_off_corpses.off_corpses()
	amk_anoms.init()
	amk_mod.spawn_unspawned_respawners() 
--<<
	news_main.init()

	local lname = level.name()
	local sname = amk.load_variable("level_on_save","")

	sak.check_actor_community(lname, sname)

	-- Зададим сообщения при переходе на уровень.
	if (lname ~= sname and sname ~= "") then
		news_main.check_connection(lname, sname)
		start_small_timer(5000, u3_utils.auto_save_rename, sname)

		if lname=="l01_escape" then
			if sname=="l41_darkscape_ogse" then
				local obj = AI:story_object(story_ids.lc_escape_to_darkscape)
				if not obj then
					obj = AI:create(AI:spawn_id(story_ids.lc_escape_to_darkscape))
				end
			end
			naxac.escape_make_peace()
		elseif lname=="pripyat" and sname=="jupiter_underground" then
			local obj = AI:story_object(story_ids.lc_east_pripyat_to_jup_underground)
			if not obj then
				level_changers.create_level_changer("lc_east_pripyat_to_jup_underground")
			end
		elseif lname=="l07_military"
			and sname=="warlab"
			and Actor:has_info("info_way_arhara_warlab_skladu")
		then
			local obj = AI:story_object(story_ids.lc_military_to_warlab)
			if not obj then
				level_changers.create_level_changer("lc_military_to_warlab")
			end
		end
	end

	w = level.get_weather()

	local blow = amk.load_variable("blowout",0)
	if blow>0 then
		xr_s.subscribe("update", amk_mod.on_blowout_hit_actor)
	end
	level.set_weather("amk_for_blow",true)
	game.start_tutorial("restore_sun")

	if blow > 0 and blow < 4 then
		local bt=blowout_type()
		level.add_cam_effector("camera_effects\\earthquake.anm", 2002, true, "")
		if bt < 1 then
			level.add_pp_effector("vibros.ppe", 2001, true)
			blowout_psy_sound("start")
			show_hideouts(true)
		end
	end

	smart_terrain.on_options_change()
end

function restore_sun()
	amk.save_variable("level_on_save", level.name())
	if amk.load_variable("blowout",0) == 0 then
		level.set_weather(w,true)
	end
	if amk.load_variable("blow_started", 0) == 0 then
		start_blow_timer()
		amk.save_variable("blow_started", 1)
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      NEWS_AMK          **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function show_news_queue(text, timeout, sender)
	local tmp_news = {}
	local f
	while true do
		f = string.find(text, "%c[gray2]", 9, true)
		if f == nil then
			break
		end
		table.insert( tmp_news, string.sub(text, 1, f-1) )
		text = string.sub(text, f)
	end
	if #text > 0 then
		table.insert( tmp_news, text )
	end

	if #tmp_news == 0 then return end

	if timeout == nil then
		timeout = math.random(1000, 3000)
	end
	local showtime = 7000
	for i, v in ipairs(tmp_news) do
		news_manager.send_tip(v, timeout/1000, nil, showtime)
	--	news_manager.send_tip(v, timeout/1000, sender, showtime)
		timeout = timeout + showtime + math_random(1000, 2000)
	end
end

function show_news()
	news_main.on_news()

	start_game_timer("show_news",0,0,math_random(50,70))

	local bl = amk.load_variable("blowout",-1)
	if (bl > -1 and bl < 5) then return end

	if sleep_manager.is_sleep_active() or news_main.isIsolatedLevel(level.name()) then return end

	-- вероятности поставлены по примерному количеству СМС в каждом файле
	local news_text, sender
	if math_random()>0.92 then
		if math_random()>0.40 then
			news_text = amk_dolg.get_strings()
			sender = "dolg"
		else
			news_text = amk_freedom.get_strings()
			sender = "freedom"
		end
	elseif math_random()>0.95 then
		local name = amk_names_lists.get_strings(false)
		local reason, lname = amk_death_lists.get_strings()
		news_text = "%c[gray2]Погиб сталкер\\n%c[default]"..name..", "..lname..". "..reason
		sender = "death"
	else
		if math_random()>0.45 then    
			local uniq = amk_uniq_news_lists.get_strings()
			local name = amk_names_lists.get_strings(true)
			news_text = "%c[gray2]"..name.."\\n%c[default]"..uniq
		else
			news_text = amk_modders.get_strings()
		end
	--	sender = "uniq"
	end
	this.show_news_queue(news_text, nil, sender)
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      RADAR_FIX         **   **   **   **   **    **   **   **   **
--'*******************************************************************************
-- подключаем только на Радаре - через xr_s
function check_radar_off()
	if not has_alife_info("bar_deactivate_radar_done") then
		local pos = Actor:position()
		if pos.z>65 and pos.x>350 and pos.x<410 then
			if amk.load_variable("radar_fix",0)==0 then
				level.add_pp_effector("fire_hit.ppe", 1523, true)
				level.set_pp_effector_factor(1523, 0.5)
				amk.save_variable("radar_fix",1)
				start_real_timer("radar_fix",5)
			end
		end
	end
end

function radar_fix()
	level.remove_pp_effector(1523)
	local pos = Actor:position()
	if pos.z>65 and pos.x>350 and pos.x<410 then
		Actor:kill(Actor)
	end
	amk.del_variable("radar_fix")
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      ITEM_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************

local tramsform_items = {
--	["item1"] = {info = "info_portion_1", result = {"item_out_1", "item_out_2", "item_out_3", "item_out_4"}},
--	["item2"] = {info = "info_portion_2", result = {"item_out_2"}},
	["kaktus_izomorf"] = {info = "kaktus_izo_resept", result = {"bloodsucker_effector", "af_spirit_4", "af_arhara_globus", "mutant_krovosos_cocoon"}},
	["izom_globus"] = {info = "kaktus_izo_resept", result = {"af_babka_3", "af_spirit_4", "device_teleport"}},
	["psevdokristall"] = {info = "kaktus_izo_resept", result = {"af_spirit_3", "af_babka_2", "wpn_m4", "device_teleport"}},
	["izomorf_plastilin"] = {info = "molniya_plastilin_ok_start", result = {"korobka_sigars", "ammo_5.45x39_izomorf", "ammo_7.62x54_izomorf", "ammo_zhekan_izomorf"}},
    ["korobka_sigars"] = {info = "kluch_poluchen", result = {"9x39_izomorf", "ammo_9x39_izomorf", "ammo_9x39_izomorf", "ammo_9x39_izomorf"}}
}

-- проверка на упавший предмет/артефакт
function check_for_item_drop(obj)
	local obj_sect = obj:section()
	
	if tramsform_items[obj_sect] and Actor:has_info(tramsform_items[obj_sect].info) then
		local lv = obj:level_vertex_id()
		local gv = obj:game_vertex_id()
		if gv == 65535 then gv = Actor:game_vertex_id() end
		if gv == 65535 then return end -- похоже, что рядом нету вертекса
		
		-- предмет подходит - отправляем его на экспертизу
		-- узнаем не съели ли его или вvложили в нvчку
		local tbl	= {}
		tbl.obj_id	= obj:id()
		tbl.lv		= lv
		tbl.gv		= gv
		start_real_timer("timer_drop_obj_transform", 0.2, tbl)
	end
end

function item_transform(obj_id, lv, gv)
    local obj = level.object_by_id(obj_id)
    if obj then
        level.add_pp_effector("teleport.ppe", 1524, false)
        local result = tramsform_items[obj:section()].result
        local position = obj:position()
        for i = 1, #result do
            amk.spawn_item(result[i], position, gv, lv)
        end
        amk.remove_item(obj)
    end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **      AF_TRANSFORM         **   **   **   **   **    **   **   **
--'*******************************************************************************
-- список компонентов
-- желательно добавлять в алфавитном порядке
-- чтобы компонент не отображался в трансмутаторе - задать false
local afs={
["af_ameba_mica"] = true,
["af_ameba_slime"] = true,
["af_ameba_slug"] = true,
["af_armor_1"] = true,
["af_armor_2"] = true,
["af_armor_3"] = true,
["af_babka_1"] = true,
["af_babka_2"] = true,
["af_babka_3"] = true,
["af_blood"] = true,
["af_buliz"] = true,
["af_cristall"] = true,
["af_cristall_flower"] = true,
["af_cry_1"] = true,
["af_cry_2"] = true,
["af_cry_3"] = true,
["af_dik_1"] = true,
["af_dik_2"] = true,
["af_dik_3"] = true,
["af_drops"] = true,
["af_dummy_battery"] = true,
["af_dummy_battery_red"] = true,
["af_dummy_dummy"] = true,
["af_dummy_glassbeads"] = true,
["af_dummy_pellicle"] = true,
["af_dummy_pellicle_red"] = true,
["af_dummy_spring"] = true,
["af_dummy_spring_red"] = true,
["af_electra_flash"] = true,
["af_electra_moonlight"] = true,
["af_electra_sparkler"] = true,
["af_fireball"] = true,
["af_fuzz_kolobok"] = true,
["af_gold_fish"] = true,
["af_gravi"] = true,
["af_kamen_udachy"] = true,
["af_kol_1"] = true,
["af_kol_2"] = true,
["af_kol_3"] = true,
["af_life_heart"] = true,
["af_medusa"] = true,
["af_mincer_meat"] = true,
["af_night_star"] = true,
["af_part_monolit2"] = true,
["af_power"] = true,
["af_power_1"] = true,
["af_power_2"] = true,
["af_pudd_1"] = true,
["af_pudd_2"] = true,
["af_pudd_3"] = true,
["af_rusty_kristall"] = true,
["af_rusty_sea-urchin"] = true,
["af_rusty_thorn"] = true,
["af_simbion"] = true,
["af_soul"] = true,
["af_spirit_1"] = true,
["af_spirit_2"] = true,
["af_spirit_3"] = true,
["af_vyvert"] = true,
["af_black_angel"]=true,
["af_arhara_globus"]=true,
["bandage"] = true,
["bezoar"] = true,
["bread"] = true,
["conserva"] = true,
["energy_drink"] = true,
["gold_art"] = true,
["izomorf_kompas"] = true,
["kolba_pustay"] = true,
["kolba_siniy_poln"] = true,
["kolba_orand_poln"] = true,
["kolba_krasn_poln"]=true,
["kolbasa"] = true,
["mutant_boar_leg"] = true,
["mutant_burer_red_hand"] = true,
["mutant_chimera_kogot"] = true,
["mutant_deathclaw_antler"] = true,
["mutant_dog_tail"] = true,
["mutant_face_tushkano"] = true,
["mutant_flesh_eye"] = true,
["mutant_fracture_hand"] = true,
["mutant_hand_kontroler"] = true,
["mutant_krovosos_jaw"] = true,
["mutant_krovosos_red_jaw"] = true,
["mutant_poltergeist_glas"]=true,
["mutant_psevdodog_tail"] = true,
["mutant_psevdogigant_hand"] = true,
["mutant_snork_leg"] = true,
["mutant_spleen_rat"] = true,
["mutant_tail_cat"] = true,
["mutant_zombie_hand"] = true,
["mutant_zombie_teeth"] = true,
["part_digitis_biblio"] = true,
["part_tarakan"] = true,
["part_tarakan_strong"] = true,
["red_mozg"] = true,
["rudiment_big"] = true,
["snp_prime_maz"] = true,
["sweetness"] = true,
["vodka"] = true,
["wpn_bizon"] = false,
-- все эмбрионы нужные для варки
["mutant_boar_cocoon"] = true,
["mutant_burer_cocoon"] = true,
["mutant_cat_cocoon"] = true,
["mutant_chimera_cocoon"] = true,
["mutant_flesh_cocoon"] = true,
["mutant_gigant_cocoon"] = true,
["mutant_krovosos_cocoon"] = true,
["mutant_poltergeist_cocoon"] = true,
["mutant_psevdodog_cocoon"] = true,
["mutant_psydog_cocoon"] = true,
["mutant_snork_cocoon"] = true,
["mutant_zombie_cocoon"] = true,
-- emb
["mutant_rat_cocoon"] = true,
["mutant_tarakan_cocoon"] = true,
["mutant_tarakan2_cocoon"] = true,
["mutant_bloodsucker_cocoon"] = true,
["mutant_bloodsucker2_cocoon"] = true,
["mutant_deathclaw_cocoon"] = true,
["mutant_fracture_cocoon"] = true,
["mutant_bibliotekar_cocoon"] = true,
["mutant_mono_cocoon"] = true,
["mutant_babka_cocoon"] = true,
["mutant_ghost_cocoon"] = true,
["mutant_kachok_cocoon"] = true,
["mutant_big_cocoon"] = true,
["mutant_jumper_cocoon"] = true,
["mutant_electro_cocoon"] = true,
["mutant_x_ray_cocoon"] = true
}

-- проверка на упавший предмет/артефакт
function check_for_af_drop(obj)
	local obj_sect = obj:section()
	
	-- проверка не один ли это из компонентов
	if afs[obj_sect] ~= nil then
		local anom_id,anom_pos,anom_radius,dist = amk_anoms.get_nearest_anomaly(obj)
		
		if anom_id and anom_radius - dist > -2 then
			--local anom_sect = level.object_by_id(anom_id):section()
			--local obj_pos = obj:position()
			local lv = level.object_by_id(anom_id):level_vertex_id()
			local gv = level.object_by_id(anom_id):game_vertex_id()
			if gv == 65535 then gv = obj:game_vertex_id() end
			if gv == 65535 then gv = Actor:game_vertex_id() end
			if gv == 65535 then return end -- похоже, что рядом нету вертекса
			
			-- предмет подходит - отправляем его на экспертизу
			-- узнаем не съели ли его или вvложили в нычку
			local tbl		= {}
			tbl.obj_id		= obj:id()
			tbl.anom_id		= anom_id
			tbl.anom_radius	= anom_radius
			tbl.lv			= lv
			tbl.gv			= gv
			start_real_timer("timer_drop_obj_varka", 0.2, tbl)

			-- перенесено в amk.script
			--check_af_transform(obj, obj_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
		end
	end
end

-- проверка: является ли компонентом для варки
-- параметр - название секции
function is_komponent(sec)
     return afs[sec]
end

-- аномалия "узнаётся" по части названия!
-- komp - компоненты
-- удача v_udachi + вырождение в булыжник v_virogd <= 100 !!!
-- отторжение v_ottorg = 100 - (v_udachi + v_virogd) посему и не нужно прописывать в таблицу
-- cel - цель (может быть одновременно несколько целей)
-- info - инфопорция, которая будет выдана после L-L+=+Ј варки
-- virogd - во что вырождается (может быть одновременно несколько вырождений)
-- vremya = {дни, часы, минуты} - время варки/мутации
-- remove_anomaly - удалить ли аномалию (можно комбинировать вместе с варкой/мутацией)
-- not_for_mutator - рецепт никогда не попадёт в трансмутатор
local anom_recept_komp = {
	-- умолчание, если нет данных ближе к рецепту
	default = {
		cel = {},
		v_udachi = 80,
		v_virogd = 17,
		virogd = {["af_buliz"]=true},
		vremya = {0,0,5},
		remove_anomaly = false
	},
	
	anomalii = {
		["zharka"] = {
			-- умолчание, если нет данных ближе к рецепту,
			-- которое может переопределятья в рецепте
			name = "\"Жарка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["starik_zadanie_vzyt_done"] = {
					komp = {["mutant_boar_cocoon"]=true,["mutant_flesh_cocoon"]=true,["mutant_psevdodog_cocoon"]=true,["mutant_boar_leg"]=true},
					cel = {["mutant_kachok_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["voron_new_kvest_done"] = {
					komp = {["mutant_krovosos_cocoon"]=true,["mutant_burer_cocoon"]=true,["mutant_bloodsucker_cocoon"]=true,["mutant_deathclaw_antler"]=true},
					cel = {["mutant_bloodsucker2_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_electra_flash_zharka"] = {
					komp = {["af_medusa"]=true,["af_rusty_thorn"]=true,["af_vyvert"]=true,["vodka"]=true},
					cel = {["af_electra_flash"]=true}
				},
				["info_artmod_ameba_slime_zharka"] = {
					komp = {["af_medusa"]=true,["af_blood"]=true,["kolbasa"]=true,["mutant_dog_tail"]=true},
					cel = {["af_ameba_slime"]=true}
				},
				["info_artmod_gravi_zharka"] = {
					komp = {["af_medusa"]=true,["af_blood"]=true,["bandage"]=true,["conserva"]=true},
					cel = {["af_gravi"]=true}
				},
				["info_artmod_night_star_zharka"] = {
					komp = {["af_rusty_kristall"]=true,["af_vyvert"]=true,["af_electra_flash"]=true,["mutant_snork_leg"]=true},
					cel = {["af_night_star"]=true}
				},
				["info_artmod_electra_moonlight_zharka"] = {
					komp = {["af_gravi"]=true,["af_medusa"]=true,["af_electra_flash"]=true,["mutant_krovosos_jaw"]=true},
					cel = {["af_electra_moonlight"]=true}
				},
				["info_artmod_dummy_battery_zharka"] = {
					komp = {["af_electra_flash"]=true,["af_ameba_mica"]=true,["vodka"]=true,["mutant_dog_tail"]=true},
					cel = {["af_dummy_battery"]=true}
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_drops"] = {
					komp = {["af_soul"]=true},
					cel = {["af_spirit_1"]=true},
					vremya = {0,4,0}
				},
				["info_artmod_gusenica"] = {
					komp = {["bezoar"]=true},
					cel = {["af_caterpillar"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_probabka_burera"] = {
					komp = {["af_babka_3"]=true},
					cel = {["af_babka_4"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_fire"] = {
					komp = {["af_spirit_1"]=true},
					cel = {["af_spirit_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_cristal"] = {
					komp = {["af_spirit_2"]=true},
					cel = {["af_spirit_3"]=true},
					vremya = {0,7,0}
				},
				["info_amk_recipt_tears_fire"] = {
					komp = {["af_cry_1"]=true},
					cel = {["af_cry_2"]=true},
					vremya = {0,6,0}
				},
				["info_amk_recipt_dikoobraz"] = {
					komp = {["af_rusty_sea-urchin"]=true},
					cel = {["af_dik_1"]=true},
					vremya = {0,3,0}
				},
				["info_amk_recipt_giant_small_brother"] = {
					komp = {["af_kol_3"]=true},
					cel = {["af_kol_4"]=true},
					vremya = {0,3,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_controller_skalp"] = {
					komp = {["af_armor_3"]=true},
					cel = {["af_armor_4"]=true},
					vremya = {0,6,0},
					v_udachi = 100,
					v_virogd = 0
				}
			}
		},
		
		["witches_galantine"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Электра\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["info_red_battery"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["mil_trader_teleport_07_done"] = {
					komp = {["mutant_cat_cocoon"]=true,["mutant_chimera_kogot"]=true,["mutant_jumper_cocoon"]=true,["mutant_psydog_cocoon"]=true},
					cel = {["mutant_electro_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["embt_vp1_done"] = {
					komp = {["mutant_deathclaw_cocoon"]=true,["mutant_bibliotekar_cocoon"]=true,["red_mozg"]=true,["af_life_heart"]=true},
					cel = {["mutant_mono_cocoon"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_fireball_galant"] = {
					komp = {["af_blood"]=true,["af_medusa"]=true,["vodka"]=true,["mutant_dog_tail"]=true},
					cel = {["af_fireball"]=true}
				},
				["info_artmod_cristall_flower_galant"] = {
					komp = {["af_vyvert"]=true,["af_rusty_thorn"]=true,["conserva"]=true,["mutant_dog_tail"]=true},
					cel = {["af_cristall_flower"]=true}
				},
				["info_artmod_ameba_mica_galant"] = {
					komp = {["af_ameba_slime"]=true,["af_rusty_thorn"]=true,["af_medusa"]=true,["kolbasa"]=true},
					cel = {["af_ameba_mica"]=true}
				},
				["info_artmod_electra_moonlight_galant"] = {
					komp = {["af_gravi"]=true,["af_blood"]=true,["af_fireball"]=true,["mutant_psevdodog_tail"]=true},
					cel = {["af_soul"]=true}
				},
				["info_artmod_gold_fish_galant"] = {
					komp = {["af_medusa"]=true,["af_rusty_thorn"]=true,["af_cristall_flower"]=true,["mutant_flesh_eye"]=true},
					cel = {["af_gold_fish"]=true}
				},
				["info_artmod_dummy_spring_galant"] = {
					komp = {["af_cristall_flower"]=true,["af_cristall"]=true,["mutant_psevdodog_tail"]=true,["conserva"]=true},
					cel = {["af_dummy_spring"]=true}
				},
				["info_artmod_medusa_galant"] = {
					komp = {["mutant_face_tushkano"]=true,["bandage"]=true,["conserva"]=true,["mutant_dog_tail"]=true},
					cel = {["af_medusa"]=true}
				},
				-- ["info_amk_recipt_souls"] = {
				["info_amk_recipt_soul_bengal"] = {
					komp = {["af_spirit_3"]=true},
					cel = {["af_spirit_4"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_tears_electra"] = {
					komp = {["af_drops"]=true},
					cel = {["af_cry_1"]=true},
					vremya = {0,5,0}
				},
				["info_amk_recipt_grandmother_glassbeards"] = {
					komp = {["af_dummy_glassbeads"]=true},
					cel = {["af_babka_1"]=true},
					vremya = {0,5,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_fire"] = {
					komp = {["af_dummy_dummy"]=true},
					cel = {["af_pudd_1"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_bright"] = {
					komp = {["af_pudd_1"]=true},
					cel = {["af_pudd_2"]=true},
					vremya = {0,6,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_moon"] = {
					komp = {["af_pudd_2"]=true},
					cel = {["af_pudd_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_electra_dikoobraz"] = {
					komp = {["af_dik_1"]=true},
					cel = {["af_dik_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["buzz"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Холодец\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["hand_otdan"] = {
					komp = {["mutant_zombie_cocoon"]=true,["bezoar"]=true,["rudiment_big"]=true,["mutant_zombie_hand"]=true},
					cel = {["mutant_babka_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["test_quest_art_otdan"] = {
					komp = {["mutant_rat_cocoon"]=true,["part_tarakan_strong"]=true,["sweetness"]=true,["conserva"]=true},
					cel = {["mutant_tarakan_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_rusty_kristall_buzz"] = {
					komp = {["af_electra_sparkler"]=true,["af_medusa"]=true,["af_drops"]=true,["bread"]=true},
					cel = {["af_rusty_kristall"]=true}
				},
				["info_artmod_rusty_thorn_buzz"] = {
					komp = {["af_blood"]=true,["bandage"]=true,["bread"]=true,["mutant_dog_tail"]=true},
					cel = {["af_rusty_thorn"]=true}
				},
				["info_artmod_fireball_buzz"] = {
					komp = {["af_rusty_thorn"]=true,["af_vyvert"]=true,["mutant_snork_leg"]=true,["bread"]=true},
					cel = {["af_fireball"]=true}
				},
				["info_artmod_night_star_buzz"] = {
					komp = {["af_gravi"]=true,["af_blood"]=true,["af_electra_flash"]=true,["mutant_psevdodog_tail"]=true},
					cel = {["af_gold_fish"]=true}
				},
				["info_artmod_fuzz_kolobok_buzz"] = {
					komp = {["af_night_star"]=true,["af_soul"]=true,["af_electra_moonlight"]=true,["af_rusty_sea-urchin"]=true},
					cel = {["af_fuzz_kolobok"]=true}
				},
				["info_artmod_vyvert_buzz"] = {
					komp = {["mutant_face_tushkano"]=true,["bandage"]=true,["conserva"]=true,["mutant_dog_tail"]=true},
					cel = {["af_vyvert"]=true}
				},
				["info_amk_recipt_tears_chimaera"] = {
					komp = {["af_cry_2"]=true},
					cel = {["af_cry_3"]=true},
					vremya = {0,2,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_pra_grandmother_glassbeards"] = {
					komp = {["af_babka_1"]=true},
					cel = {["af_babka_2"]=true},
					vremya = {0,3,0}
				},
				-- ["info_amk_recipt_dummy"] = {
				["info_amk_recipt_dummy_puding"] = {
					komp = {["af_pudd_3"]=true},
					cel = {["af_pudd_4"]=true},
					vremya = {0,7,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_sopl_dikoobraz"] = {
					komp = {["af_dik_2"]=true},
					cel = {["af_dik_3"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_almaz_kolobok"] = {
					komp = {["af_kol_2"]=true},
					cel = {["af_kol_3"]=true},
					vremya = {0,8,0}
				},
				["info_amk_recipt_pancir"] = {
					komp = {["af_armor_2"]=true},
					cel = {["af_armor_3"]=true},
					vremya = {0,2,0}
				},
				["info_artmod_globus"] = {
					komp = {["af_simbion"]=true},
					cel = {["af_arhara_globus"]=true},
					vremya = {0,0,10},
					v_udachi = 75,   
					v_virogd = 25
				},
				["info_amk_recipt_simbion"] = {
					komp = {["af_medusa"]=true,["af_drops"]=true,["af_blood"]=true,["af_rusty_thorn"]=true},
					cel = {["af_simbion"]=true},
					vremya = {0,5,0}
				},
-- Akill begin Варим Изумрудную вспышку
				["izumrud_recept_start"] = {
					komp = {["af_electra_flash"]=true,["gold_art"]=true,["af_night_star"]=true,["mutant_boar_leg"]=true},
					cel = {["af_electra_green"]=true},
					vremya = {0,0,2},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					info = "izumrud_recept_have"
				},
-- Akill end
				["snp_kalmyk1_done"] = {
					komp = {["snp_prime_maz"]=true},
					cel = {["snp_prime_maz_green"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				}
			}
		},
		
		["fountain"] = {
			name = "\"Фонтан\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},

			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["emb0"] = {
					komp = {["mutant_x_ray_cocoon"]=true},
					cel = {["mutant_wolf_cocoon"]=true},
					vremya = {0,8,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_power_3"] = {
					komp = {["af_power_2"]=true,["af_buliz"]=true,["af_cry_1"]=true,["af_pudd_3"]=true,["af_dik_2"]=true},
					cel = {["af_power_3"]=true},
					vremya = {0,5,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["snp_receipt_parts6_done"] = {
					komp = {["kolba_pustay"]=true,["kolba_siniy_poln"]=true,["kolba_orand_poln"]=true,["rudiment_big"]=true,["part_tarakan"]=true,["part_tarakan_strong"]=true},
					cel = {["kolba_krasn_poln"]=true},
					vremya = {0,0,10},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_cristall_buzz"] = {
					komp = {["af_cristall_flower"]=true,["af_medusa"]=true,["af_fireball"]=true,["mutant_krovosos_jaw"]=true},
					cel = {["af_cristall"]=true}
				},
				["info_artmod_gold_art"] = {
					komp = {["af_mincer_meat"]=true,["af_ameba_slug"]=true,["af_electra_flash"]=true,["mutant_hand_kontroler"]=true},
					cel = {["gold_art"]=true},
					vremya = {0,2,0},
					v_udachi = 90,
					v_virogd = 0
				}
			}
		},
		
		["mincer"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Карусель\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["info_red_spring"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["af_dummy_spring_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["emb_container_done"] = {
					komp = {["mutant_big_cocoon"]=true},
					cel = {["mutant_jumper_cocoon"]=true},
					vremya = {0,4,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["kalmyak_need_done"] = {
					komp = {["mutant_zombie_cocoon"]=true,["vodka"]=true,["mutant_fracture_hand"]=true,["part_digitis_biblio"]=true},
					cel = {["mutant_fracture_cocoon"]=true},
					vremya = {0,0,30},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_cristall_flower_mincer"] = {
					komp = {["af_blood"]=true,["af_medusa"]=true,["bandage"]=true,["conserva"]=true},
					cel = {["af_cristall_flower"]=true}
				},
				["info_artmod_drops_mincer"] = {
					komp = {["af_vyvert"]=true,["bandage"]=true,["vodka"]=true,["mutant_dog_tail"]=true},
					cel = {["af_drops"]=true}
				},
				["info_artmod_rusty_kristall_mincer"] = {
					komp = {["af_electra_sparkler"]=true,["af_medusa"]=true,["conserva"]=true,["mutant_dog_tail"]=true},
					cel = {["af_rusty_kristall"]=true}
				},
				["info_artmod_electra_moonlight_mincer"] = {
					komp = {["af_fireball"]=true,["af_blood"]=true,["af_ameba_slug"]=true,["mutant_krovosos_jaw"]=true},
					cel = {["af_electra_moonlight"]=true}
				},
				["info_artmod_ameba_slug_mincer"] = {
					komp = {["af_electra_flash"]=true,["af_vyvert"]=true,["af_fireball"]=true,["mutant_psevdodog_tail"]=true},
					cel = {["af_ameba_mica"]=true}
				},
				["info_artmod_dummy_glassbeads_mincer"] = {
					komp = {["af_ameba_mica"]=true,["af_rusty_sea-urchin"]=true,["af_gold_fish"]=true,["af_night_star"]=true},
					cel = {["af_dummy_glassbeads"]=true}
				},
				["info_amk_recipt_burer_grandmother_glassbeards"] = {
					komp = {["af_babka_2"]=true},
					cel = {["af_babka_3"]=true},
					vremya = {0,0,10}
				},
				["info_amk_recipt_titan_kolobok"] = {
					komp = {["af_kol_1"]=true},
					cel = {["af_kol_2"]=true},
					vremya = {0,5,0}
				},
				["we_ne_chmuri"] = {
					komp = {["af_kamen_udachy"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					info = "spawn_hospit_live"
				},
				["mozno_varit"] = {
					komp = {["af_part_monolit2"]=true},
					cel = {["af_kamen_udachy"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					info = "spawn_kamen_udachy"
				},
		-- Akill begin
				["info_artmod_blood_mincer"] = {
					komp = {["kolbasa"]=true,["energy_drink"]=true,["mutant_spleen_rat"]=true,["mutant_psevdodog_tail"]=true},
					cel = {["af_blood"]=true}
				},
		-- Akill end
				["info_amk_recipt_cheshya"] = {
					komp = {["af_armor_1"]=true},
					cel = {["af_armor_2"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["mosquito_bald"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Трамплин\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["info_red_pellicle"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["af_dummy_pellicle_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["emb14"] = {
					komp = {["mutant_gigant_cocoon"]=true,["mutant_snork_cocoon"]=true,["mutant_kachok_cocoon"]=true,["mutant_psevdogigant_hand"]=true},
					cel = {["mutant_big_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["dar_password_info2"] = {
					komp = {["mutant_tarakan_cocoon"]=true,["part_tarakan"]=true},
					cel = {["mutant_tarakan2_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_mincer_meat_mosquito_bald"] = {
					komp = {["af_vyvert"]=true,["af_blood"]=true,["vodka"]=true,["mutant_dog_tail"]=true},
					cel = {["af_mincer_meat"]=true}
				},
				["info_artmod_electra_sparkler_mosquito_bald"] = {
					komp = {["af_drops"]=true,["bandage"]=true,["kolbasa"]=true,["mutant_dog_tail"]=true},
					cel = {["af_electra_sparkler"]=true}
				},
				["info_artmod_ameba_slug_mosquito_bald"] = {
					komp = {["af_medusa"]=true,["af_drops"]=true,["bandage"]=true,["vodka"]=true},
					cel = {["af_ameba_slug"]=true}
				},
				["info_artmod_cristall_mosquito_bald"] = {
					komp = {["af_mincer_meat"]=true,["af_vyvert"]=true,["af_fireball"]=true,["mutant_flesh_eye"]=true},
					cel = {["af_cristall"]=true}
				},
				["info_artmod_rusty_sea-urchin_mosquito_bald"] = {
					komp = {["af_ameba_slime"]=true,["af_blood"]=true,["af_rusty_kristall"]=true,["mutant_krovosos_jaw"]=true},
					cel = {["af_rusty_sea-urchin"]=true}
				},
				["info_artmod_dummy_dummy_mosquito_bald"] = {
					komp = {["af_ameba_mica"]=true,["af_cristall"]=true,["af_mincer_meat"]=true,["af_night_star"]=true},
					cel = {["af_dummy_dummy"]=true}
				},
				["info_amk_recipt_stone_dikoobraz"] = {
					komp = {["af_dik_3"]=true},
					cel = {["af_dik_4"]=true},
					vremya = {0,7,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_steel_kolobok"] = {
					komp = {["af_fuzz_kolobok"]=true},
					cel = {["af_kol_1"]=true},
					vremya = {0,2,0}
				},
				["info_amk_recipt_shkura"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_armor_1"]=true},
					vremya = {0,5,0}
				}
			}
		},
		
		["gravi_zone"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Воронка\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["info_red_battery"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["af_dummy_battery_red"]=true},
					remove_anomaly = true,
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true
				},
				["snp_almaz0"] = {
					komp = {["mutant_bloodsucker2_cocoon"]=true},
					cel = {["mutant_deathclaw_cocoon"]=true},
					vremya = {0,3,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["arhara_shaxter_start"] = {
					komp = {["part_tarakan"]=true,["bread"]=true,["mutant_tail_cat"]=true,["mutant_spleen_rat"]=true},
					cel = {["mutant_rat_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_power_2"] = {
					komp = {["af_power_1"]=true,["af_buliz"]=true,["af_gravi"]=true,["af_pudd_2"]=true,["af_rusty_thorn"]=true},
					cel = {["af_power_2"]=true},
					vremya = {0,1,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_ameba_slug_gravi_zone"] = {
					komp = {["af_vyvert"]=true,["af_medusa"]=true,["kolbasa"]=true,["mutant_dog_tail"]=true},
					cel = {["af_ameba_slug"]=true}
				},
				["info_artmod_ameba_slime_gravi_zone"] = {
					komp = {["af_medusa"]=true,["bandage"]=true,["conserva"]=true,["mutant_dog_tail"]=true},
					cel = {["af_ameba_slime"]=true}
				},
				["info_artmod_electra_flash_gravi_zone"] = {
					komp = {["af_vyvert"]=true,["af_blood"]=true,["mutant_dog_tail"]=true,["vodka"]=true},
					cel = {["af_electra_flash"]=true}
				},
				["info_artmod_night_star_gravi_zone"] = {
					komp = {["af_rusty_thorn"]=true,["af_medusa"]=true,["af_rusty_kristall"]=true,["mutant_psevdodog_tail"]=true},
					cel = {["af_night_star"]=true}
				},
				["info_artmod_soul_gravi_zone"] = {
					komp = {["af_electra_flash"]=true,["af_cristall_flower"]=true,["af_ameba_slug"]=true,["mutant_snork_leg"]=true},
					cel = {["af_soul"]=true}
				},
				["info_artmod_dummy_pellicle_gravi_zone"] = {
					komp = {["af_ameba_mica"]=true,["af_cristall"]=true,["af_gold_fish"]=true,["af_soul"]=true},
					cel = {["af_dummy_pellicle"]=true}
				}
			}
		},
		
		["ice"] = {
			-- умолчание, если нет данных ближе к рецепту
			name = "\"Снежная\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},
			
			recepti = {
				["anom_bizon_info"] = {
					komp = {["wpn_bizon"]=true},
					cel = {["wpn_bizon1"]=true},
					vremya = {2,0,0},
					v_udachi = 80,
					v_virogd = 0,
					not_for_mutator = true
				},
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["emb_kill_tm_done"] = {
					komp = {["mutant_babka_cocoon"]=true},
					cel = {["mutant_ghost_cocoon"]=true},
					vremya = {0,6,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_amk_recipt_power_1"] = {
					komp = {["af_power"]=true,["af_buliz"]=true,["af_blood"]=true,["af_pudd_1"]=true,["af_ameba_slug"]=true},
					cel = {["af_power_1"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["life_heart_final"] = {
					komp = {["af_dummy_dummy"]=true,["af_rusty_sea-urchin"]=true,["af_gold_fish"]=true,["af_night_star"]=true},
					cel = {["af_life_heart"]=true},
					vremya = {0,0,15},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_red_battery"] = {
					komp = {["af_dummy_battery"]=true},
					cel = {["af_dummy_battery_red"]=true},
					vremya = {0,0,10}
				},
				["info_red_spring"] = {
					komp = {["af_dummy_spring"]=true},
					cel = {["af_dummy_spring_red"]=true},
					vremya = {0,0,10}
				},
				["info_red_pellicle"] = {
					komp = {["af_dummy_pellicle"]=true},
					cel = {["af_dummy_pellicle_red"]=true},
					vremya = {0,0,10}
				}
			}
		},
		
		["sphere"] = {
			name = "\"Пузырь\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["emb8"] = {
					komp = {["mutant_fracture_cocoon"]=true},
					cel = {["mutant_bibliotekar_cocoon"]=true},
					vremya = {0,2,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["emb4"] = {
					komp = {["mutant_poltergeist_cocoon"]=true,["mutant_tarakan2_cocoon"]=true,["mutant_krovosos_red_jaw"]=true,["mutant_burer_red_hand"]=true},
					cel = {["mutant_bloodsucker_cocoon"]=true},
					vremya = {0,0,5},
					v_udachi = 100,
					v_virogd = 0
				},
				["info_artmod_art_acumm"] = {
					komp = {["af_rusty_thorn"]=true,["energy_drink"]=true,["kolbasa"]=true,["mutant_poltergeist_glas"]=true},
					cel = {["art_acumm"]=true},
					vremya = {0,0,7},
					v_udachi = 70,
					v_virogd = 25
				}
			}
		},

		["zavesa"] = {
			name = "\"Tорнадо\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
               },
				["emb17"] = {
					komp = {["mutant_chimera_cocoon"]=true,["mutant_electro_cocoon"]=true,["mutant_kachok_cocoon"]=true,["mutant_ghost_cocoon"]=true},
					cel = {["mutant_x_ray_cocoon"]=true},
					vremya = {0,2,0},
					v_udachi = 100,
					v_virogd = 0
				},
				["fima_mulo_nayti_done"] = {
					komp = {["mutant_zombie_teeth"]=true,["kolbasa"]=true},
					cel = {["rudiment_big"]=true},
					v_udachi = 80,
					v_virogd = 20,
					not_for_mutator = true
				}
			}				
		},

		["smallrain"] = {
			name = "\"Очаговый туман\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["snp_almaz3"] = {
					komp = {["mutant_mono_cocoon"]=true},
					cel = {["mutant_tm_cocoon"]=true},
					vremya = {0,7,0},
					v_udachi = 100,
					v_virogd = 0
				}
			}				
		},

		["radon_cloud"] = {
			name = "\"Радоново облако\"",
			default = {
				v_udachi = 80,
				v_virogd = 20,
				vremya = {0,0,5}
			},			
			recepti = {
				["info_izomorf_kompas"] = { -- артефакт удалит аномалию без результатов варки/мутации
					komp = {["izomorf_kompas"]=true},
					cel = {["izomorf_kompas"]=true},
					vremya = {0,0,1},
					v_udachi = 100,
					v_virogd = 0,
					not_for_mutator = true,
					remove_anomaly = true
				},
				["spatial_subway_doc"] = {
					komp = {["af_cry_3"]=true},
					cel = {["af_cry_4"]=true},
					vremya = {0,3,30},
					v_udachi = 90,
					v_virogd = 10
				},
				["gena_sakharov2_done"] = {
					komp = {["kolba_pustay"]=true,["kolba_siniy_poln"]=true,["kolba_orand_poln"]=true,["kolba_krasn_poln"]=true,["af_black_angel"]=true,["af_arhara_globus"]=true},
					cel = {["kolba_fiol_poln"]=true},
					vremya = {0,0,10},
					v_udachi = 100,
					v_virogd = 0
				}
			}
		}
	}
}
-- Может быть только три вида результата: значит, сохраняем только индекс,
-- а остальное вычитаем на финише из таблицы с рецептами.
local af_result = {
	komp   = 0, -- отторжение
	virogd = 1, -- вырождение
	cel    = 2  -- удача
}
local res2key = {}
for k, v in pairs(af_result) do
	res2key[v] = k
end

local bad_art_prob = 0.3
local good_art_prob = 0.15

-- возвращает значение, возможно из умолчаний
function get_af_transform_param(name, recept, recepti)
	local result
	--get_console():execute("load ~#I#:"..string.format(name.." имя"))
	if recept[name] ~= nil then
		result = recept[name]
	elseif recepti["default"] ~= nil and recepti["default"][name] ~= nil then
		result = recepti["default"][name]
	elseif anom_recept_komp["default"] ~= nil and anom_recept_komp["default"][name] ~= nil then
		result = anom_recept_komp["default"][name]
	else
		-- нет информации!!!
		amk.send_tip("нет информации для "..name.."!","варка артефактов",0,15,"gen_info")
		result = nil
	end
	return result
end

-- Получаем полный набор рецептов для аномалии anom_sect
function fill_recepti_est(anom_sect)
	local recepti_est = {} -- рецепты для заданной аномалии
	local anom_name = nil
	local anom_type = sys_ini:r_string_ex(anom_sect, "af_transform_type", nil)
	if anom_type and anom_recept_komp["anomalii"][anom_type] then
		local recepti = anom_recept_komp["anomalii"][anom_type]
		anom_name = recepti["name"]
		if recepti["recepti"] then
			for info, recept in pairs(recepti["recepti"]) do
				if (not recept["not_for_mutator"])
					and (not recept["remove_anomaly"])
					and Actor:has_info(info)
				then
					-- есть рецепт: заносим в таблицу
					recepti_est[info] = table.copy( {}, recept )
				end
			end
		end
	end
	return recepti_est,anom_name
end

-- проверяет рецепты и компонеты
-- если всё в порядке - запускает варку/мутацию
function check_af_transform(af, af_sect, obj_pos, anom_id, anom_sect, anom_pos, anom_radius, lv, gv)
	--поиск по аномалиям
	local anom_type = sys_ini:r_string_ex(anom_sect, "af_transform_type", nil)
	if not anom_type then return end

	local recepti = anom_recept_komp["anomalii"][anom_type]
	if not recepti then return end

	local finish = false -- флаг для выхода из циклов
	local recepti_est = {} -- рецепты в наличии у ГГ, в которых участвует данный компонент
	local recept_podhodit = false

	-- собираем рецепты, в которых участвует данный компонент
	for info, recept in pairs(recepti["recepti"]) do
		if Actor:has_info(info) and recept["komp"][af_sect] == true then --есть рецепт и этот компонент в нём участвует
			recept_podhodit = true
			-- копируем рецепт
			local t = table.copy( {}, recept )
			t["count"] = table.size(recept["komp"])
			t["count_cond"] = t["count"]
			t["comp_cond"] = nil
			recepti_est[info] = t
		end
	end

	if recept_podhodit then -- если нашли хоть один имеющийся подходящий рецепт
		--ищем рядом другие компоненты
		--если находим их в выбранных рецептах, то удаляем их из рецептов
		--как только какой-то рецепт остаётся без компонентов - рецепт сработал
		local obj
		local level_object = level.object_by_id
		local obj_sect
		for i=1,65534 do
			obj = level_object(i)
			if obj and AI:object(i) and afs[obj:section()]~=nil then
				if obj:parent() == nil and ((anom_radius - obj:position():distance_to(anom_pos)) > -2) then
					obj_sect = obj:section()
					--проверяем отобраннvе рецепты
					for info, recept in pairs(recepti_est) do
						-- если компонент есть в рецепте
						if recept["komp"][obj_sect] == true then
							-- добавляем ID компонента для будущего удаления из игры
							recept["komp"][obj_sect] = obj:id()
							-- уменьшаем количество компонентов в рецепте
							recept["count"] = recept["count"] - 1
							-- проверяем состояние артефактов
							recept["comp_cond"] = (recept["comp_cond"] or 0) + obj:condition()
							-- если рецепт пуст, то он сработал
							if recept["count"] == 0 then
								-- устанавливаем все параметры для рецепта, возможно из умолчаний
								local cel            = get_af_transform_param("cel", recept, recepti)
								local v_udachi       = get_af_transform_param("v_udachi", recept, recepti)
								local v_virogd       = get_af_transform_param("v_virogd", recept, recepti)
								if table.size(cel) == 0 or (v_udachi + v_virogd) > 100 then
									-- кривой рецепт  - выходим с сообщением в лог
									log("! Wrong transform recipe found: %s", info)
									table.print(recept)
									finish = true
									break
								end
								local vremya         = get_af_transform_param("vremya", recept, recepti)
								local remove_anomaly = get_af_transform_param("remove_anomaly", recept, recepti)
								local komp           = recept["komp"]
								local result_cond    = recept["comp_cond"]/recept["count_cond"]
								local result         = af_select_result(v_udachi, v_virogd, result_cond)

								local remove_anomaly_id
								if remove_anomaly then
									if result == af_result.cel then
										remove_anomaly_id = anom_id
									end
								else
									remove_anomaly_id = math.ceil(result_cond*1000)
								end

								level.add_pp_effector("teleport.ppe", 1524, false)

								-- запускаем варку/мутацию
								af_start_universal_transform_timer(info, result, vremya, obj_pos, gv, lv, remove_anomaly_id)

								-- удаляем из игры компоненты рецепта
								shiftCheckDropItem()
								for k,v in pairs(komp) do
									del_obj_by_id(v)
								end

								-- выходим
								finish = true
								break
							end
						end
					end
				end
			end

			if finish then break end
		end
	end
end

function af_flash(af)
	level.add_pp_effector("teleport.ppe", 1524, false)
	amk.remove_item(af)
end

-- случайно выбирает результат, возвращает индекс результата
function af_select_result(v_udachi, v_virogd, k_cond)
	local rnd = math_random(0,100)
	v_udachi = v_udachi * k_cond	-- если компоненты имеют среднее состояние меньше 1, то уменьшаем вероятность удачного исхода
	if rnd > v_udachi then --неудача
		if rnd > v_virogd + v_udachi then -- отторжение
			return af_result.komp
		else -- вырождение
			return af_result.virogd
		end
	else -- удача
		return af_result.cel
	end
end

-- запускаем трансофрмацию 
-- результаты могут быть многочисленны (несколько целей, полное отторжение компонентов, несколько вырождений)
local transform_params = nil
function get_transforms()
	if not transform_params then
		transform_params = xr_logic.pstor_get_custom(Actor, "af_var", "af_var")
	end
	return transform_params
end

function af_start_universal_transform_timer(rec_name, result, vremya, pos, gv, lv, remove_anomaly_id)
	-- сохраняемые данные
	local tbl = get_transforms()

	-- для возможности запускать несколько варок по одному и тому же рецепту...
	local i = 0
	local var = rec_name
	while tbl[var]~=nil do
		var = rec_name..":"..i
		i = i + 1
	end
	tbl[var] = {
		result	= result,
		pos		= pos,
		gv		= gv,
		lv		= lv,
		rem_anom = remove_anomaly_id,
	}
	start_game_timer("af_transform_universal", vremya[1], vremya[2], vremya[3], var)
end

-- завершаем варку/мутацию
-- может быть много результатов
function af_transform_universal_end(var)
	local tbl = get_transforms()
	local params = tbl[var]
		or abort("af_transform_universal_end: not found params for transform: %s", utils.to_str(var))

	local rec_name = string.match(var, "^([^:]+)")

	-- Прочитаем из таблицы, что же у нас сварилось
	local recept, info = nil, nil
	local result = {}
	local remove_anomaly = false
	for k,v in pairs(anom_recept_komp.anomalii) do
		if v['recepti'] and v['recepti'][rec_name] then
			recept = v['recepti'][rec_name]
			result = get_af_transform_param(res2key[params.result], recept, v)
			remove_anomaly = get_af_transform_param("remove_anomaly", recept, v)
			info = recept['info']
			break
		end
	end

	if recept == nil then
		abort("[amk_mod.af_transform_universal_end]: recept '%s' not found in [anom_recept_komp]", rec_name)
	end

	if info == nil then
		info = rec_name
	end

	-- если есть результаты
	if table.size(result) > 0 then
		if Actor:position():distance_to(params.pos) < 15 then
			level.add_pp_effector("teleport.ppe", 1524, false)
		end

		-- формируем строку с названиями компонентов
		local komp = {}
		for sect in pairs(recept['komp']) do
			table.insert( komp, game.translate_string(get_inv_name(sect)) )
		end
		local from_komp = table.concat(komp, ", ")
		local caption = game.translate_string("trans_finished_title")
		local text = caption.." из %c[red_sms]"..from_komp
			
		
		-- спавним результат(ы)
		local obj
		for sect in pairs(result) do
			obj = AI:create_free(sect, params.pos:add(vector():set(0,1,0)), params.lv, params.gv)
			obj = AI:object(obj.id)
			level.map_add_object_spot_ser(obj.id, "red_location", text)
			obj.is_transformed = true
			if isWeapon(obj) then
				local cond = params.rem_anom or math_random(200, 800)
				this.set_wpn_after_transform(obj, cond/1000)
			end
			
			if params.result == af_result.cel and string_find(sect, "^af_") then
				archievements.acv_count_event("acv_art", 100)
				actor_stats.add_points( "artefacts_2", get_inv_name(sect), 1, 1 )
				xr_statistic.add_actor_rank( xr_statistic.get_af_rank(sect) )
				local cls = obj:clsid()
				if cls == clsid.artefact_s or cls == clsid.art_gravi_s then
					if math_random() < bad_art_prob then
						obj.art_loss = math_random(10, 80)/100
					elseif math_random() < good_art_prob then
						obj.art_loss = -math_random(10, 80)/100
					end
				end
			end
			xr_statistic.set_id( obj.id, true )
		end

		local where = news_main.get_point_description( AI:level_name( GGraph:vertex(params.gv):level_id() ), params.pos )
		text = caption.."\\n"..
			"Из %c[red_sms]"..from_komp.."\\n"..
			"%c[default]"..where.."."
		news_manager.send_tip(text, 1, "nano")
	end
	
	-- даём инфопорцию, если есть
	if Actor:dont_has_info(info) and params.result == af_result.cel then
		Actor:give_info_portion(info)
	end
	
	-- удаляем аномалии, если нужно и она не в исключениях
	-- код взят из amk_anoms.turn_off_all()
	if remove_anomaly and params.rem_anom then
		amk_anoms.release_anomaly( AI:object(params.rem_anom) )
	end

	tbl[var] = nil
	if table.size(tbl) == 0 then
		xr_logic.pstor_clear_custom(Actor, "af_var")
		transform_params = nil
	end
end

function set_wpn_after_transform(sobj, cond_set)
	local tt = {}
	tt.condition = cond_set
	tt.ammo_elapsed = 0
	netpk:modify(sobj, tt, netpk.fState)
	level.client_spawn_manager():add(sobj.id, -1,
		function(id, item)
			item:set_condition(cond_set)
			item:unload_magazine()
		end
	)
end
--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **    AMK_METKA     **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function check_beacon_drop( obj )
	if AI:object( obj:id() ) ~= nil and _G['biznes_remove_special_item'] == nil then
		if not Actor:alive() then return end
		start_small_timer( 500, this.check_metka, obj:id() )
	end
end

function check_metka( obj_id )
	local obj=level.object_by_id( obj_id )
	if obj and obj:parent() == nil then
		local spwn = ui_dots.dots( get_hud(), obj_id )
		level.start_stop_menu( spwn, true )
	end  
end
local last_update=0 
local inert = 1000 
local clicks_prev = 200 music_section="" music_previous_section="" music_next_section_start_time=0 music_stop_previous=0 music=false music_init = 0 music_themes = {} music_phases={} musicflag=1 
local music_objs={[1]=nil,[2]=nil} 
local music_stor={ enemy_see_actor=0, actor_see_enemy=0, enemy_hit_actor=0, actor_hit_enemy=0 } music_lo_lvl=7 music_hi_lvl=17 
local music_graph={}  

function build_music_graph() 
local skip = false 
local lname = level.name() 
	local iniFileName = "scripts\\amk\\music\\music.ltx"
	local sect = "music_themes"
	local sini = ini_file(iniFileName) 
	if sini and iniLineSectionExist(sect, iniFileName) then 
		local result, id, value = nil, nil, nil
		for a=0,iniLinesCount(sect, iniFileName)-1 do
			result, id, value = getIniLine(sect,a,"","", iniFileName) 
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				id=trim(id)
				value1 = string.explode(trim(value), "|", true)
				value={}
				for k,v in pairs(value1) do 
					local tmp = string.explode(v, "=", true)
					value[tmp[1]]=tmp[2]
				end 
				if value.map then 
					local t = string.explode(value.map, ",", true)
					for kk,vv in pairs(t)do
						skip = skip or vv == lname
					end
					skip = not skip
				else
					skip = false
				end 
				if not skip then 
					table.insert(music_themes, id)
					--local t = amk.parse_ini_section_to_array(sini,id.."_music_files")
					local t = amk.parse_ini_section_to_array_new(iniFileName,id.."_music_files")
					t.null = ""
					for k,v in pairs(t) do
						music_phases[id.."_"..k]=v 
						if not music_graph[id.."_"..k] then
							music_graph[id.."_"..k] = {}
						end 
						--local tt = amk.parse_ini_section_to_array(sini,id.."_graph_"..k)
						local tt = amk.parse_ini_section_to_array_new(iniFileName,id.."_graph_"..k)
						for kk,vv in pairs(tt) do 
							local tmp = string.explode(vv, ",", true) 
							local lvl = tmp[1]
							lvl = amk_mod["music_"..lvl.."_lvl"]
							music_graph[id.."_"..k][id.."_"..kk] = {lvl,tmp[2]}
						end
					end
				end
			end
		end 
		if #music_themes > 0 then
			return true
		else
			return false
		end
	end
	
	return false
end  

function music_start(sound) 
	if not music then 
		if music_objs[1]==nil then
			music_objs[1]=amk_music.amk_music()
		end 
		if music_objs[2]==nil then
			music_objs[2]=amk_music.amk_music()
		end
		music_objs[musicflag]:initialize(music_phases[sound])
		music_next_section_start_time=music_objs[musicflag]:play()-200
		music_previous_section=music_section
		musicflag=3-musicflag
	end
	
	music = true
end  

function music_change(sound) 
	if music then
		music_objs[musicflag]:initialize(music_phases[sound])
		music_next_section_start_time=music_objs[musicflag]:play_at_time(music_next_section_start_time+200)-200
		musicflag=3-musicflag music_previous_section=music_section
	end
end  

function interactive_music()
	amk.oau_reason="music begin"

	if (game_options.DynMusic==false or amk_music==nil) then return end 
	if music_init==-1 then return end 
	if music_init==0 then 
		if build_music_graph() then 
			music_init=1
		else
			music_init=-1
			return
		end
	end 
	if not music then 
		if time_global() - last_update > inert then
			music_select_section(inert) last_update = time_global()
		end
	end 
	if not music and music_previous_section=="" and music_section~="" then
		music_start(music_section)
	end 
	if music and music_previous_section~="" and music_section=="" then
		music_previous_section=""
	end 
	if music then
		music_objs[1]:update() music_objs[2]:update() 
		if time_global() > music_next_section_start_time then
			music_select_section(music_objs[musicflag]:length()) 
			if music_section~="" then
				music_change(music_section)
			else
				music=false
			end
		end
	end

	amk.oau_reason=""
end  

function reset_music_cntrs(c)
	music_stor.actor_see_enemy=music_stor.actor_see_enemy-2*c
	music_stor.enemy_see_actor=music_stor.enemy_see_actor-2*c
	music_stor.actor_hit_enemy=music_stor.actor_hit_enemy-8*c
	music_stor.enemy_hit_actor=music_stor.enemy_hit_actor-4*c
	if music_stor.actor_see_enemy<0 then
		music_stor.actor_see_enemy=0
	elseif music_stor.actor_see_enemy>music_lo_lvl then
		music_stor.actor_see_enemy=music_lo_lvl
	end 
	if music_stor.enemy_see_actor<0 then
		music_stor.enemy_see_actor=0
	elseif music_stor.enemy_see_actor>music_lo_lvl then
		music_stor.enemy_see_actor=music_lo_lvl
	end 
	if music_stor.actor_hit_enemy<0 then
		music_stor.actor_hit_enemy=0
	elseif music_stor.actor_hit_enemy>music_hi_lvl then
		music_stor.actor_hit_enemy=music_hi_lvl
	end 
	if music_stor.enemy_hit_actor<0 then
		music_stor.enemy_hit_actor=0
	elseif music_stor.enemy_hit_actor>music_hi_lvl then
		music_stor.enemy_hit_actor=music_hi_lvl
	end
end 

local shoot_helper=0  

function calc_adrenaline(act,obj,typ) 
	local dist = obj:position():distance_to(Actor:position()) 

	if act=="actor_see_enemy" then
		music_stor.actor_see_enemy=music_stor.actor_see_enemy+50/dist
	elseif act=="enemy_see_actor" then
		music_stor.enemy_see_actor=music_stor.enemy_see_actor+50/dist
	elseif act=="actor_hit_enemy" then 
		if time_global()>shoot_helper then
			music_stor.actor_hit_enemy=music_stor.actor_hit_enemy+13
			shoot_helper=time_global()+500
		end
	elseif act=="enemy_hit_actor" then
		music_stor.enemy_hit_actor=music_stor.enemy_hit_actor+8
	end
end  

function music_select_section(time)
	reset_music_cntrs(time/inert) 
	
	local cs = music_section 
	local eseen = music_stor.enemy_see_actor 
	if eseen >= music_lo_lvl then
		eseen = music_lo_lvl
	end 
	local aseen = music_stor.actor_see_enemy 
	if aseen >= music_lo_lvl then
		aseen = music_lo_lvl
	end 
	local ehits = music_stor.enemy_hit_actor 
	if ehits >= music_hi_lvl then
		ehits = music_hi_lvl
	end 
	local ahits = music_stor.actor_hit_enemy 
	if ahits >= music_hi_lvl then
		ahits = music_hi_lvl
	end 

	local lvl = aseen + eseen 
	if lvl>music_hi_lvl*0.75 then
		lvl=music_hi_lvl*0.75
	end
	lvl = ehits + lvl + ahits 

	if music_section=="" then
		music_section=music_themes[math_random(#music_themes)].."_null"
	end 

	local last_sel_max=0 
	local last_sel_min=1000
	for k,v in pairs(music_graph[music_section]) do 
		if v[2]=="<" and v[1]<last_sel_min then 
			if v[1]>lvl then
				music_section=k last_sel_min=v[1]
			end
		end 
		if v[2]==">" and v[1]>=last_sel_max then 
			if v[1]<=lvl then
				music_section=k
				last_sel_max=v[1]
			end
		end
	end 
	
	if string_find(music_section,"null") then
		music_section=""
	end 
	if music and music_previous_section~="" and music_section=="" then
		music_previous_section=""
	end 
	
	local l=0 
	if music and music_objs[musicflag]~=nil then
		l=music_objs[musicflag]:length()
	end
end  

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **      BLOWOUT        **   **   **   **   **    **   **   **   **
--'*******************************************************************************
function blowout_phantoms()
	local blow = amk.load_variable("blowout", 0)
	local bt = blowout_type()
	if blow>1 and blow<4 and bt<2 then
		local lname = level.name()
		if not in_hide and amk_hideouts.blowouts_phantoms[lname] then
			local phantoms=amk_hideouts.blowouts_phantoms[lname]
			if phantoms and phantoms.count > 0 then
				if math_random()<phantoms.probability then
					if phantom_manager:phantom_count() < phantoms.count then
						local yaw	 			= math_pi*2.0*math_random()
						local radius 			= phantoms.radius*(math_random()/2.0+0.5)
						local height 			= phantoms.height*math_random()
						local a_pos 			= Actor:position()
						local pos 				= vector():set(math_sin(yaw)*radius+a_pos.x,a_pos.y+height,math_cos(yaw)*radius+a_pos.z)
						phantom_manager.spawn_phantom(pos)
					end
				end
			end
		end
	end
end

function blowout_scary_sounds()
	local blow = amk.load_variable("blowout",-1)
	if blow>0 and blow<4 then
		local snd_obj = xr_sound.get_safe_sound_object( table.random(amk_hideouts.blowout_sounds) )
		local a = vector():set(
			math_random(0,10),
			math_random(0,10),
			math_random(0,10)
		)
		snd_obj:play_at_pos(Actor, Actor:position():add(a))
		start_real_timer("blowout_ss",math_random(10,30),0)
	end
end

function blowout_psy_sound(action)
	if action=="start" then
		snd_obj_eq = sound_object([[ambient\earthquake]],sound_object.looped+sound_object.s2d)
		snd_obj_eq:play(Actor, 4, sound_object.looped+sound_object.s2d)
	end
	if action == "stop" then
		if snd_obj_eq then snd_obj_eq:stop() end
	end
	
	local lname = level.name()
	if not amk_hideouts.blowouts_phantoms[lname] then return end

	local psy_sound = amk_hideouts.blowouts_phantoms[lname].psy_sounds or false	
	if not psy_sound then return end

	if action == "start" then
		local level_vol = amk_hideouts.blowouts_phantoms[lname].level_vol or 1				
		sound_obj_right, sound_obj_left = xr_sound.get_sound_object("psy_voices", "random")
		sound_obj_left:play_at_pos (Actor, vector():set(-1, 0, 1), 0, sound_object.s2d + sound_object.looped)
		sound_obj_right:play_at_pos(Actor, vector():set( 1, 0, 1), 0, sound_object.s2d + sound_object.looped)
		snd_volume = level.get_snd_volume()
		level.set_snd_volume( level_vol )
	end
	if action == "stop" then
		if sound_obj_left then sound_obj_left:stop() end
		if sound_obj_right then sound_obj_right:stop() end
		if snd_volume then level.set_snd_volume(snd_volume) end
	end	
end

function Run_Blowout_pp()
	if game_options.RunBlowoutPP then
		local bt = blowout_type()
		if bt == 2 then start_blow_timer() return end
		sleep_manager.stopper()
		xr_s.subscribe("update", amk_mod.on_blowout_hit_actor)
		amk.save_variable("blowout",1)
		if bt < 1 then
			level.add_pp_effector("monolith_off.ppe", 2003, false)
			level.add_cam_effector("camera_effects\\shell_shock.anm", 2004, false, "")
			local snd_obj = xr_sound.get_safe_sound_object([[ambient\organic_moan1]])
			snd_obj:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 1.0)
		end
		start_real_timer( "blowout_ss" ,math_random( 5, 15 ), 0 )
		start_real_timer( "blowout", 11, 0 )
		blowout_modif_arts()
	end
	start_blow_timer()
end

function start_blow_timer()
	local basis = game_options.BlowTimeBasis
	local shift = game_options.BlowTimeShift
	local resuls = basis + math_random(-shift, shift)
	start_game_timer("blow_shift", 0, 0, resuls)

	news_main.next_blow(resuls)
end

function Blowout_pp(phase)
---------------------------------------------------
--' TimeFactor = 5
--' GameMin = 12 RealSec
--' TimeBlowout = 184 RealSec

--' начало (Timer = 36 sec)
--' первая фаза (Timer = 36 sec)
--' вторая фаза (Timer = 36 sec)
--' Tретья фаза (Timer = 36 sec)
--' четвертая фаза (Timer = 60 sec)
--' конечная фаза (Timer = 0 sec)
---------------------------------------------------

	amk.mylog("blowout "..phase)
	local basis = game_options.BlowPhaseBasis
	local shift = game_options.BlowPhaseShift
	local max = game_options.BlowPhaseMax
	local resuls = basis + (math_random()*shift) - (shift/2)
	resuls = math.clamp( resuls, 1, max )
	local blow = amk.load_variable("blowout", 0)
	local bt = blowout_type()

	if blow > 0 and blow < 4 and bt == 2 then
		start_game_timer("blowout", 0, 0, 3, 4)
		amk_mod.restore_weather()
		show_hideouts(false)
		return
	end

	if phase == 0 then
		Actor.blowout_outside = true
		amk_anoms.pre_blow_off()
		if bt < 1 then
			level.set_weather("pre_blow",true)
			level.set_weather_fx("amk_surge_day")
			show_hideouts(true)
		end 
		start_game_timer("blowout", 0, 0, resuls, 1)

	elseif phase == 1 then
		local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
		snd_obj:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 1.0)
		level.add_cam_effector("camera_effects\\earthquake.anm", 2002, true, "")
		snd_obj = xr_sound.get_safe_sound_object([[anomaly\blowout]])
		snd_obj:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 1.0)
		blowout_psy_sound("start")
		if bt < 1 then
			level.add_pp_effector("vibros.ppe", 2001, true)
		end
		in_hide = false
		start_game_timer("blowout", 0, 0, resuls, 2)
		amk.save_variable("blowout",2)

	elseif phase == 2 then
		start_game_timer("blowout",0,0,3,3)

	elseif phase == 3 then
		amk_anoms.after_blow_on()
		amk.save_variable("blowout",3)
		bind_crow.blowout_hit()
		start_game_timer("blowout", 0, 0, resuls, 4)

	elseif phase == 4 then
		amk.save_variable("blowout",4)
		level.remove_cam_effector(2002)
		if bt < 1 then
			level.remove_pp_effector(2001)
			level.add_pp_effector("monolith_off.ppe", 2003, false)
		end
		blowout_psy_sound("stop")
		start_real_timer("blowout",5,5)

	elseif phase == 5 then
		if bt < 1 then
			local snd_obj = xr_sound.get_safe_sound_object([[anomaly\teleport_work2]])
			snd_obj:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 1.0)
		end
		xr_s.unsubscribe("update", amk_mod.on_blowout_hit_actor)
        if game_options.ZombieTeam then
            tag_spb.zombie_team()
        end 
		if Actor.blowout_outside then
			archievements.acv_count_event("acv_blow", 5)
			Actor.blowout_outside = nil
		end
		amk.save_variable( "BLT", amk.load_variable( "BLT", 0 ) + 1 )
		start_real_timer("run", 7, "amk_mod.restore_weather()")
   		start_real_timer("autosave_data", 10, "Выброс") -- autosave
		show_hideouts(false)
	end
end

local hideout_sr_sid0 = 20100
local hideout_sr_sid
local function get_hideout_spot_sid()
	if hideout_sr_sid == nil then
		local i = hideout_sr_sid0 + 1
		while AI:story_object(i) ~= nil do
			i = i + 1
		end
		hideout_sr_sid = i
	else
		hideout_sr_sid = hideout_sr_sid + 1
	end
	return hideout_sr_sid
end
function show_hideouts(b)
	if b then
		if not game_options.HideoutSpot then return end
		if Actor:dont_has_info("map_hideouts") then return end

		local hides = amk_hideouts.hide[level.name()]
		if not hides then return end

		local obj
		for i, v in ipairs(hides) do
			if v.center then
				local pos = level.vertex_position(v.center)
				local gv = n_vertexes.get_nearest_gv(pos)
				obj = netpk:create_restrictor(pos, v.center, gv, "", 1, get_hideout_spot_sid())
				level.map_add_object_spot_ser(obj.id, "crlc_small", "st_hideout_spot_hint")
			elseif v.zone then
				local max_lv = n_vertexes.get_max_level_vertex()
				local lv, gv, min_dist, vdist
				for j, t in ipairs(v.zone) do
					local v1 = vector():set( unpack(t.p1) )
					local v2 = t.p3 and vector():set( unpack(t.p3) ) or vector():set( unpack(t.p2) )
					local pos = v1:sub(v2):div(2):add(v2)
					-- log("show_hideouts: %s::%s", i, j)
					-- xr_extensions.print_vector(pos)
					gv = n_vertexes.get_nearest_gv(pos)
					min_dist = math.huge
					for vv = 1, max_lv do
						vdist = level.vertex_position(vv):distance_to(pos)
						if vdist < min_dist then
							min_dist = vdist
							lv = vv
						end
					end
					obj = netpk:create_restrictor(pos, lv, gv, "", 1, get_hideout_spot_sid())
					level.map_add_object_spot_ser(obj.id, "crlc_small", "st_hideout_spot_hint")
				end
			else
				log("! wrong hideout #%s!", tostring(i))
				table.print(v)
			end
		end

	else
		local sid = hideout_sr_sid0 + 1
		local obj
		while true do
			obj = AI:story_object(sid)
			if not obj then break end
			AI:release(obj, true)
			sid = sid + 1
		end
	end
end

function restore_weather()
	amk.del_variable('blowout')
	if inventory.on_belt("af_idol_monolita") then
		level.set_weather( "grey", true )
	end
end

local next_actor_hit_time=0
function on_blowout_hit_actor()
	if next_actor_hit_time<time_global() then
		next_actor_hit_time=time_global()+1000
		on_blowout_hit(Actor)
		blowout_phantoms()
	end
end

function on_blowout_hit(npc,hide)
	local bt=blowout_type()
	if bt>0 or amk.load_variable("blowout",-1)~=3 then 
		if npc:id()==Actor:id() then in_hide = true end
		return false
	end
	
	local lname=level.name()
	local need_hit
	need_hit=true
	local khit=1
	if hide and hide.zone then
		need_hit = not check_npc_in_hideout(npc,hide)
		if not need_hit then
			if hide.defence then 
				khit=hide.defence
			else
				khit=0
			end
		end
	else
		local hides=amk_hideouts.hide[lname]
		local tmp
		if hides then
			for i,o in ipairs(hides) do
				if o.zone then
					for j,v in ipairs(o.zone) do
						if v.p3 then
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
						else
							tmp=amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
						end
						need_hit = need_hit and not tmp
						if tmp then
							if o.defence then 
								khit=o.defence
							else
								khit=0
							end
						end
					end
				end
			end
		end
	end

    if npc:id()==Actor:id() then
		if not need_hit then
			Actor.blowout_outside = nil
		else
			Actor.blowout_outside = true
		end
		if outfit_hideout() then -- защита от выброса броником
			need_hit = false
			khit = 0
		else
			khit = khit+khit*level.get_game_difficulty()/6	-- усиление хита для актора, чтобы вне укрытия не пережил
		end
		in_hide = not need_hit
	end
    if (need_hit or khit>0) and amk.load_variable("blowout",-1)==3 and not (hide and hide.hidden) then
		local h = hit()
    	h.power = (amk_hideouts.blowout_damages[lname] or 0.01)*khit
    	h.impulse = 0
		h.draftsman = npc
		h.direction = vector():set(0,0,0)
		h:bone("bip01_spine") -- чтобv учитvвалась броня
    	h.type = hit.strike
		npc:hit(h)
    	h.type = hit.telepatic
		npc:hit(h)
    	h.type = hit.radiation
		npc:hit(h)
    end
    return need_hit or khit>0
end

function outfit_hideout()
	local outfits = {
		["gagarin_outfit"] = true,
		["gagarin_outfit_m1"] = true,
		["voshod_outfit"] = true,
		["exo_knight_outfit"] = true
	}
	return actor_outfit and outfits[actor_outfit:section()]
end

function check_npc_in_hideout(npc,hide)
	local not_in_zone=true
	if hide and hide.zone then
		for k,v in pairs(hide.zone) do
			if v.p3 then 
				not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)),vector():set(unpack(v.p3)))
			else
				not_in_zone = not_in_zone and not amk.check_npc_in_box(npc,vector():set(unpack(v.p1)),vector():set(unpack(v.p2)))
			end
		end
	end
	return not not_in_zone
end

function initial_spawn(action)
	local fr=0
	for i=0,amk_hideouts.anom_count-1,1 do
		local sobj = AI:story_object(amk_hideouts.anom_sid0+i)
		if not sobj then 
			AI:create(i+amk_hideouts.anom_num0) 
			fr=1
		end
	end
	if fr==1 then create_anoms() end
end

function blowout_modif_arts()
	local obj, b
	local st_tbl = {}
	for i=1,65534 do
		obj = AI:object(i)
		if obj and isArtefact(obj) and obj.is_transformed then
			if math_random() < 0.2 then
				table.add(st_tbl, obj:section_name())
				if obj.parent_id == 65535 then
					b = AI:create_free("af_buliz", obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id)
				else
					b = AI:create("af_buliz", obj.position, obj.m_level_vertex_id, obj.m_game_vertex_id, obj.parent_id)
				end
				if xr_statistic.is_found_art(i) then
					xr_statistic.set_id(i, nil)
					xr_statistic.set_id(b.id, true)
				end
				AI:release(obj, true)
			end
		end
	end
	
	if not game_options.GarbagecollectorStat then return end
	local msg = ""
	if table.size(st_tbl)==0 then
		msg = "При выбросе ни один артефакт не пострадал."
	else
		local n = 0
		msg = "При выбросе выродилось артефактов:\\n"
		for k,v in pairs(st_tbl) do
			msg = msg.."%c[yellow]"..game.translate_string(get_inv_name(k))..
				"%c[default] - "..v.." шт.\\n"
			n = n + v
		end
		msg = msg.."ИТОГО: "..n.." шт.\\nНа всякий случай проверь рюкзак."
	end
	amk.send_tip(msg, "Уборщик:", 5, 10, "nano")
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       ANOMS SPAWN        **   **   **   **   **    **   **   **   
--'*******************************************************************************
anomalies_state={}

function remove_anoms()
	amk.save_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	update_anoms()
end

function create_anoms()
	anomalies_state={}
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
		anomalies_state[i]=math_random(0,1)==1
	end
	local str=pack_anoms(anomalies_state)
	amk.save_variable("blowout_anoms",str)
	update_anoms()
end

function update_anoms()
	local anoms=amk.load_variable("blowout_anoms",string.rep(string.char(128),math_ceil(amk_hideouts.anom_count/7)))
	anomalies_state=unpack_anoms(anoms)
	for i=amk_hideouts.anom_sid0,amk_hideouts.anom_sid0+amk_hideouts.anom_count-1,1 do
		local sobj=AI:story_object(i)
		if sobj then
			local obj=level.object_by_id(sobj.id)
			if obj then
				if anomalies_state[i] then
					obj:enable_anomaly()
				else
					obj:disable_anomaly()
				end
			end
		end
    end
end

-- anom_state[sid]==true для активнvх аномалий
function pack_anoms(anom_state)
	local str=""
	for i=0,amk_hideouts.anom_count-1,7 do
		local cval=128
		local mul=1
		for j=0,6,1 do
			if anom_state[i+j+amk_hideouts.anom_sid0] then
				cval=cval+mul
			end
		mul=mul*2
		end
    str=str..string.char(cval)
	end
	return str
end

function unpack_anoms(str)
	local anom={}
	for i=1,string.len(str),1 do
		local cval=string.byte(string_sub(str,i,i))
		local mul=1
		for j=0,6,1 do
			anom[(i-1)*7+j+amk_hideouts.anom_sid0]=bit_and(mul,cval)~=0
			mul=mul*2
		end
	end
	return anom
end

function blowout_type()
	local blow_type = amk_hideouts.blowout_types[level.name()]
	return blow_type or 0
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **    **      RECEPTS       **   **   **   **   **    **   **   **   ** 
--'*******************************************************************************
function generate_recipe(obj, who)
	if obj==nil or not IAmAStalker[obj:clsid()] then
		return
	end
	
	local info, prob
	local community = obj.character_community and obj:character_community()
	local lname = level.name()
	if lname=="l07_military" and community=="killer" then
		info="info_amk_recipt_titan_kolobok"
		prob=30
	elseif (lname=="l10_radar" or lname=="l11_pripyat") and community=="monolith" then
		info="info_amk_recipt_controller_skalp"
		prob=30
	else
		return
	end
	
	if info==nil then return end

	local recipes=amk.load_table("amk_body_recipe")

	if has_alife_info(info) then
		for id, inf in pairs(recipes) do
			if inf == info then
				recipes[id] = nil
				break
			end
		end
		amk.save_table("amk_body_recipe", recipes)
		return
	end
	
	local sobj
	local need_save = false
	-- Почистим таблицу...
	for id in pairs(recipes) do
		sobj = AI:object(id)
		if sobj==nil or IAmAStalker[sobj:clsid()]==nil or sobj:alive() then
			recipes[id] = nil
			need_save = true
		end
	end
	if need_save then amk.save_table("amk_body_recipe",recipes) end
	-- Проверим, не генерился ли уже этот рецепт
	for k, v in pairs(recipes) do
		if v==info then
			return
		end
	end
	-- Cгенерим рецепт
	if math_random(100)<=prob then
		recipes[obj:id()]=info
		amk.save_table("amk_body_recipe",recipes)
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **     SPAWN_OBJ        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************
function spawn_fuel()
	local ballons = {
	{108.16, -6.30, -18.17, 412158, 115},
	{370.12, 15.06, -39.48, 594401, 0},
	{58.30, 19.36, 156.50, 345136, 97},
	{-92.21, -1.18, -212.66, 115177, 268},
	{-74.17, 1.80, 8.45, 127766, 329},
	{3.18, 1.24, 42.48, 243919, 490},
	{15.35, -1.90, 2.40, 255433, 479},
	{77.54, 0.30, -108.47, 312366, 427},
	{-145.54, -0.00, -199.61, 92520, 650},
	{-130.08, 10.00, -196.67, 109214, 629},
	{-140.13, 10.00, -197.94, 98647, 629},
	{37.28, 1.02, -49.90, 220638, 1084},
	{476.68, -46.94, -0.23, 155714, 1919},
	{76.80, -2.54, -23.93, 36304, 1970},
	{94.78, 0.03, -6.88, 88986, 1514},
	{-3.24, -11.75, -263.07, 33794, 1448}
	}
	local kanisters = {
	{-293.80, -14.18, -15.36, 15703, 67},
	{-16.57, 2.48, 58.82, 260308, 88},
	{-74.81, -1.30, 160.52, 196218, 163},
	{-69.94, 0.97, 6.51, 131411, 329},
	{64.01, 0.60, 148.46, 235341, 364},
	{63.29, -0.20, 5.10, 299326, 461},
	{-28.52, -1.04, -181.84, 211644, 676},
	{2.93, -1.88, -13.30, 176553, 1047},
	{41.71, 4.54, -86.36, 227110, 1100},
	{7.90, 1.41, -71.93, 183138, 1041},
	{158.71, -0.76, -259.73, 358950, 962},
	{-342.92, -13.60, 390.01, 11235, 1847},
	{305.22, -36.99, -24.40, 68330, 1930},
	{55.02, 1.17, 40.35, 68094, 1511},
	{-114.14, -0.00, 121.75, 43453, 1315},
	{31.33, 5.60, -13.51, 4683, 1538}
	}
	for k,v in pairs(ballons) do
		if #v == 5 then
			local obj = AI:create_free("amk_ballon",vector():set(v[1], v[2], v[3]), v[4], v[5])
			if obj and is_debug==true then
				amk.add_spot_on_map(obj.id, "red_location", "ballon")
			end
		end
	end
	for k,v in pairs(kanisters) do
		if #v == 5 then
			local obj = AI:create_free("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
			if obj and is_debug==true then
				amk.add_spot_on_map(obj.id, "red_location", "kanistra")
			end
		end
	end
end

-- +Tі на блокпосту
function spawn_military_btr()
	spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-168.11, -29.71, -303.21),81808,38 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
	spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-237.85, -26.23, -378.81),17147,14 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
	spawn_military_tech_pack( AI:create("helicopter",vector():set(-150.0,-40.0,-620.0),128298,11 ) ,"helicopter", "scripts\\esc\\esc_blockpost_heli.ltx")
--	spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-189.55,-0.24,-140.49),46901,559),"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--	spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-93.81,0,-185.82),146369,607),"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--  spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-135.49, -30.13, -375.27),115062,20 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
--  spawn_military_tech_pack( AI:create("vehicle_btr",vector():set(-167.58, -29.48, -364.26),82401,31 ) ,"vehicle_btr", "scripts\\esc\\esc_blockpost_btr.ltx")
end

function spawn_military_tech_pack(obj, spawn_item, spawn_item_logic)	
	local t = {}

	t.object_flags = bit_not(5)
	t.custom_data = "[logic]\ncfg = "..spawn_item_logic
	t.story_id = story_ids.Invalid
	t.skeleton_name = "idle"

	if spawn_item == "helicopter" then
		t.startup_animation = "idle"
		t.engine_sound = "alexmx\\helicopter"
	elseif  spawn_item == "vehicle_btr" then
		t.health = 1
	end

	netpk:modify( obj, t, netpk.fState )

	return obj
end


--'*******************************************************************************
--'   **   **   **   **   **    **   **   **       AMK_RESPAWNS     **   **   **   **   **    **   **   **   
--'*******************************************************************************
function switch_monster_online(obj)
	se_monster.need_be_online[obj.id]=true
end

function switch_monster_offline(obj)
	se_monster.need_be_online[obj.id]=false
end

-- перенесено в se_monster и se_respawn для предопределения настроек до чтения spawn_ini объекта
function respawned(obj,respawner)
	if obj and IAmAMonster[obj:clsid()] then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			netpk:modify( obj, { custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx" }, netpk.fState )
		end
	elseif obj and IAmAStalker[obj:clsid()] then
		local sini = respawner:spawn_ini()
		if sini:line_exist ("respawn", "creature_binded_logic") == true then
			local cfg_name = utils.cfg_get_string(sini, "respawn", "creature_binded_logic", false, false, false, "")
			netpk:modify( obj, { custom_data = "[logic]\ncfg = scripts\\amk\\"..cfg_name..".ltx" }, netpk.fState )
		end
	end	
end

local respawners={}

function add_respawner(obj)
	local oini = obj:spawn_ini()
	if oini:section_exist("respawn") and oini:line_exist("respawn", "amk_name") then
		local amk_name = oini:r_string("respawn", "amk_name")
		if amk_name then respawners[amk_name]=true end
	end
end

function spawn_unspawned_respawners()
	local iniFileName = "scripts\\amk\\amk_respawns.ltx"
	local sini = ini_file(iniFileName)
	local result, id, value = nil, nil, nil
	
	local dv = {}
	if sini:section_exist("default_values") then
		for a = 0, sini:line_count("default_values")-1 do
			result, id, value = sini:r_line("default_values",a,"","")
			id = id and trim(id)
			if id and id ~= "" then
				dv[id] = trim(value)
			end
		end
	end

	if sini:section_exist("amk_respawns") then
		local tmp = {}
		for a=0, sini:line_count("amk_respawns")-1 do
			result, id, value = sini:r_line("amk_respawns",a,"","")
			id = id and trim(id)
			if id and id ~= "" then
				table.insert(tmp, id)
			end
		end
		
		for k,v in pairs(tmp) do
			--local flag = utils.cfg_get_bool(sini, "amk_respawns", v, true, false, false)
			local flag = sini:r_bool_ex("amk_respawns", v, false)
			if ( not respawners[v] ) and flag == true then
				local t = amk.parse_ini_section_to_array(sini, v)
				local xyzlg = string.explode(t.xyzlg, ",", true)
				local pos = vector():set(tonumber(xyzlg[1]),tonumber(xyzlg[2]),tonumber(xyzlg[3]))
				local respawner = amk.spawn_item("respawn",pos,tonumber(xyzlg[5]),tonumber(xyzlg[4]))
				t.xyzlg = nil
				t.amk_name = v

				for kkk,vvv in pairs(dv) do
					if t[kkk]==nil then
						t[kkk]=vvv
					end
				end

				local tbl = { custom_data = netpk:gen_custom_data({respawn=t}) }
				netpk:modify(respawner, tbl, netpk.fState)
				se_respawn.reinit_spawner_params(respawner:name())
				--amk.add_spot_on_map(respawner.id,"red_location", v)
				--amk.mylog("spawned respawn "..respawner.id)
			elseif flag==false then
				local o = se_respawn.get_respawner_by_name(v)
				if o then
					--amk.mylog("released respawn "..o.id)
					AI:release(o, true)
				end
			end
		end
	end
end

--'*******************************************************************************
--'   **   **   **   **   **    **   **   **   **          OTHER        **   **   **   **   **    **   **   **   **   
--'*******************************************************************************

function repair_armor(val)
	local armor = Actor:item_in_slot( inventory_slots.OUTFIT )
	if armor then
		armor:set_condition(val)
		inventory.force_update(armor:section())
	end
end

local exo_wpns = {
	["wpn_kord"] = true,
	["wpn_kord_m1"] = true,
	["wpn_m_134"] = true,
	["wpn_m_134_baty"] = true,
	["wpn_m134"] = true
}

function check_armor(section)
	if string_find(section, "exo")==nil then
		local wpn
		local chck_slots = { inventory_slots.PISTOL, inventory_slots.RIFLE }
		for i, v in ipairs( chck_slots ) do
			wpn = Actor:item_in_slot(v)
			if wpn and exo_wpns[wpn:section()] then
				Actor:move_to_ruck(wpn)
				news_manager.send_tip("wpn-m_134-no_exo_message", nil, "nano", 5000)
			end
		end
	end
end

function dezombify(id, v)
--	log("attempt to dezombify %s", id)
	local sobj = AI:object(id)
	if not ( sobj and IsStalker(sobj) and sobj:alive() ) then
		return
	end
--	log("dezombify %s", sobj:name())
--	table.print(v)

	local npc = level.object_by_id(id)
	if npc then
		npc:set_character_community(v.cm,0,0)
	else
		netpk:modify(sobj, {community_index = v.ci}, netpk.fSate)
	end
	relation_registry.set_goodwill(sobj.id, Actor:id(), v.gw)
end


btrs_friends={}

function build_btrs_table(obj)
	if obj and (IAmAStalker[obj:clsid()] and obj:character_community()=="military" and obj:alive()) or obj:section()=="vehicle_btr" then
			btrs_friends[obj:id()] = obj:section()
	end
end

local time_shift = 0
function firebated(obj, amount, local_direction, who, bone_index)
	if time_shift < time_global() then return end
	time_shift = time_global() + 50
	if bone_index>0 and who and IAmAStalker[who:clsid()] then --false для отклічения
		local weapon = who:active_item()
		if not weapon or weapon:section()~="wpn_flame" then return end
		
		if not obj then return end
		local cls = obj:clsid()
		local file = (IAmAMonster[cls] and bind_monster)
			or (IAmAStalker[cls] and bind_stalker)
			or nil

		if file then
			if string_find(obj:section(), "zomb") and obj.health<0.2 then
				obj:kill(obj)
			end
			file.play_particle(obj,
			{
				obj=obj,
				particle="amk\\flame",
				bone="bip01_spine1"
			})
		end
	end
end

local zomby_blow_sections = {
	zombie_blow = true,
	zombie_beee = true,
	zombie_hell = true,
	zombie_hospital1 = true,
	zombie_hospital2 = true,
	zombie_hospital3 = true
}
function zomby_blow(obj)
	local sobj = AI:object(obj:id())
	if sobj == nil then return end
	
	if obj:object("wpn_flame") then
		amk_particle.amk_particle({
				particle="explosions\\explosion_fuelcan",
				pos=obj:position(),
				sound=[[weapons\t_rgd5_explosion]]
			})
		local dist = Actor:position():distance_to(obj:position())
		if dist < 15 then
			local h = hit()
			h.impulse = 5
			h.draftsman = Actor
			h.direction = vector():set(0,0,0)
			h:bone("bip01_spine") -- чтобv учитvвалась броня
			h.power = 1/dist
			h.type = hit.strike --chemical_burn
			Actor:hit(h)
			h.power = 15/dist
			h.type = hit.burn
			Actor:hit(h)
		end
		AI:release(sobj, true)
		return
	end
	
	if zomby_blow_sections[obj:section()]then
		amk_particle.amk_particle({
			particle="monsters\\polter_death_00",
			pos=obj:bone_position("bip01_head"),
			sound="anomaly\\anomaly_gravy_hit1"
		})
		local dist = Actor:position():distance_to(obj:position())
		if dist < 20 then
			local h = hit()
			h.impulse = 1
			h.draftsman = Actor
			h.direction = vector():set(0,0,0)
			h:bone("bip01_spine")
			h.power = 1/dist
			h.type = hit.strike
			Actor:hit(h)
			h.power = 10/dist
			h.type = hit.chemical_burn
			Actor:hit(h)
		end
		local se_obj = AI:object( obj:id() )
		if se_obj then
			AI:release( se_obj, true )
		end
	end
end

function repair_weapon (arr)
	local oid = arr[1]
	local repbox_health = arr[2]
	local slot = arr[3]
	if AI:object(oid)==nil then
		local repair_coef = 0                                   
		local item_in_slot = Actor:item_in_slot(slot)  
		if repbox_health==1 then                                 
			repair_coef=0.25                                           
		elseif repbox_health<1 then                       
			repair_coef=0.2                                         
		elseif repbox_health<0.8 then                       
			repair_coef=0.15                                            
		elseif repbox_health<0.6 then                        
			repair_coef=0.1                                         
		elseif repbox_health<0.4 then                        
			repair_coef=0.05         
		end	 
		--------------------------------------------------------------------------- 
		local rem
		
		if item_in_slot == nil then
			amk.send_tip(game.translate_string("rep_no_weapon_in_slot"),nil,nil,5)
			rem = amk.spawn_item_in_inv("repbox_s"..slot)
			start_real_timer("repbox_cond",0.1, {rem.id, repbox_health} )
		else
			if item_in_slot:condition()>0.95 then
				amk.send_tip(game.translate_string("rep_not_need"),nil,nil,5)
				rem = amk.spawn_item_in_inv("repbox_s"..slot)
				start_real_timer("repbox_cond",0.1, {rem.id, repbox_health} )
			else 
				if item_in_slot:condition()>=0.7 then
					item_in_slot:set_condition(item_in_slot:condition() + repair_coef)
					if repbox_health>0.3 then
						rem = amk.spawn_item_in_inv("repbox_s"..slot)
						start_real_timer("repbox_cond",0.1, {rem.id, repbox_health-0.2} )
					end
				else
					amk.send_tip(game.translate_string("rep_need_big"),nil,nil,5)
					rem = amk.spawn_item_in_inv("repbox_s"..slot)
					start_real_timer("repbox_cond",0.1, {rem.id, repbox_health} )
				end
			end
		end
	end

end

function after_repair_weapon (arr)
	local oid = arr[1]
	local repbox_health = arr[2]
	local lobj = level.object_by_id(oid)
	if lobj then
		lobj:set_condition(repbox_health)
	end
end

function fake_weapon (st)
monnoroch.fake_weapon (st)
end

-- На апдейте перебирать весь инвентарь... Гениальное решение!
function firebat_ammo()

--	local ammo=Actor:object("ammo_flame") -- фикс перезарядок огнемета Шурупа и Шмеля
	local ammo=Actor:object("ammo_rpo-a")
	if ammo then
		Actor:iterate_inventory(
			function(dummy,item)
--				if item:section()=="ammo_flame" then -- фикс перезарядок огнемета Шурупа и Шмеля
				if item:section()=="ammo_rpo-a" then
					del_obj_by_id(item:id())
				end
			end
			, Actor)
	end
end
