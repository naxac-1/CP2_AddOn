-- -*- mode: lua; encoding: windows-1251 -*-

prefetch('xr_extensions')

log1( "# LUA version: [".._VERSION.."]" )

math.randomseed(os.time())


schemes = {} -- соответствие схем модулям
stypes = {} -- типы схем

-- Загружает схему из файла на диске и активирует в мотиваторе.
-- Здесь:
--  filename - имя файла, в котором реализована схема, без расширения
--  scheme - имя схемы
function load_scheme(filename, scheme, stype)
  schemes[scheme] = filename
  stypes[scheme] = stype
end
-------======= ini reading functions by sapsan =======------
iniLines = {
    ["float"]   = {},
    ["u32"]   = {},
    ["string"]  = {},
    ["string_wq"]  = {},
    ["boolean"] = {},
    ["line"] = {}
}
iniOtherLines = {}
iniStat = {}
iniCaching = true
iniStatistic = false
iniSections = { -- если пустая - кешируется ВСЁ!
    ["af_ameba_slug "]              = true,
    ["af_blood"]                    = true,
    ["af_electra_sparkler"]         = true,
    ["af_gravi"]                    = true,
    ["af_medusa"]                   = true,
    ["af_vyvert"]                   = true,
    ["art_acumm"]                   = true,
    ["ammo_11.43x23_hydro"]         = true,
    ["ammo_12x70_buck"]             = true,
    ["ammo_12x76_dart"]             = true,
    ["ammo_12x76_zhekan"]           = true,
    ["ammo_5.45x39_ap"]             = true,
    ["ammo_5.45x39_fmj"]            = true,
    ["ammo_5.56x45_ap"]             = true,
    ["ammo_5.56x45_ss190"]          = true,
    ["ammo_9x18_fmj"]               = true,
    ["ammo_9x18_pmm"]               = true,
    ["ammo_9x19_fmj"]               = true,
    ["ammo_9x19_pbp"]               = true,
    ["ammo_9x39_ap"]                = true,
    ["ammo_9x39_pab9"]              = true,
    ["ammo_9x39_sp5"]               = true,
    ["ammo_m209"]                   = true,
    ["ammo_vog-25"]                 = true,
    ["ammo_vog-25p"]                = true,
    ["antirad"]                     = true,
    ["balalaika_a"]                 = true,
    ["bandage"]                     = true,
    ["bandit_gaz_outfit_m1"]        = true,
    ["bandit_master_outfit"]        = true,
    ["bandit_outfit"]               = true,
    ["beer_a"]                      = true,
    ["bolt"]                        = true,
    ["bread"]                       = true,
    ["breakable_object"]            = true,
    ["cigara"]                      = true,
    ["climable_object"]             = true,
    ["conserva"]                    = true,
    ["device_pda"]                  = true,
    ["device_torch"]                = true,
    ["energy_drink"]                = true,
    ["flaska"]                      = true,
    --["generic_sell"]                = true,
    ["grenade_f1"]                  = true,
    ["grenade_gd-05"]               = true,
    ["grenade_rgd5"]                = true,
    ["guitar_a"]                    = true,
    ["harmonica_a"]                 = true,
    ["inventory_box"]               = true,
    ["killer_outfit"]               = true,
    ["kolbasa"]                     = true,
    ["lights_hanging_lamp"]         = true,
    ["logic"]                       = true,
    ["medkit"]                      = true,
    ["medkit_army"]                 = true,
    ["medkit_scientic"]             = true,
    ["mob_home"]                    = true,
    ["monolit_exoskeleton"]         = true,
    ["monolit_gaz_outfit_m1"]       = true,
    ["mutant_dog_tail"]             = true,
    ["mutant_face_tushkano"]        = true,
    ["mutant_spleen_rat"]           = true,
    ["ph_door@locked"]              = true,
    ["ph_door@open"]                = true,
    ["ph_idle@enable"]              = true,
    ["ph_skeleton_object"]          = true,
    ["physic_destroyable_object"]   = true,
    ["physic_object"]               = true,
    --["random_task"]                 = true,
    --["remark@val_rob_leader_call"]  = true,
    ["respawn"]                     = true,
    ["sandwich"]                    = true,
    ["smart_terrain"]               = true,
    ["space_restrictor"]            = true,
    ["stalker"]                     = true,
    ["stalker_outfit"]              = true,
    ["suvorotka"]                   = true,
    ["sweetness"]                   = true,
    ["vodka"]                       = true,
    ["oceanic815"]                  = true,
    --["walker@val_rob_leader_start"] = true,
    ["wpn_abakan"]                  = true,
    ["wpn_addon_grenade_launcher"]  = true,
    ["wpn_addon_grenade_launcher_m203"] = true,
    ["wpn_ak47"]                    = true,
    ["wpn_ak74 "]                   = true,
    ["wpn_ak74u"]                   = true,
    ["wpn_beretta_m1"]              = true,
    ["wpn_bm16"]                    = true,
    ["wpn_fort"]                    = true,
    ["wpn_g36"]                     = true,
    ["wpn_groza"]                   = true,
    ["wpn_l85"]                     = true,
    ["wpn_lr300"]                   = true,
    ["wpn_m16a2_sk1"]               = true,
    ["wpn_m4super90"]               = true,
    ["wpn_mp5"]                     = true,
    ["wpn_pb"]                      = true,
    ["wpn_pm"]                      = true,
    ["wpn_tavor"]                   = true,
    ["wpn_sig220"]                  = true,
    ["wpn_sig550"]                  = true,
    ["wpn_spas12"]                  = true,
    ["wpn_val"]                     = true,
    ["wpn_walther"]                 = true,
    ["yad"]                         = true
}
iniSectionsCount = 0
for sect, val in pairs(iniSections) do
    iniSectionsCount = iniSectionsCount + 1
end
-- if not iniLines then iniLines = {} end
-- if not iniOtherLines then iniOtherLines = {} end
--cfg_get_number(char_ini, section, field, object, mandatory, default_val)
--getIniValueFloat(sect, line, default, iniFileName)

--cfg_get_string(char_ini, section, field, object, mandatory, gulag_name, default_val)
--getIniValueString(sect, line, default, iniFileName)
-- getIniValueString("trader", "sell_condition", "", "misc\\trade_generic.ltx")
function getIniValueFloat(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueFloat: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["float"] or not iniOtherLines[iniFileName]["float"][sect] or not iniOtherLines[iniFileName]["float"][sect][line]) or
                (not iniLines["float"][sect] or not iniLines["float"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("float", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_float(sect, line)
                else
                    sectLines[line] = default
                end
            end

            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["float"][sect][line]
            else
                return iniLines["float"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_float(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueU32(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueU32: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["u32"] or not iniOtherLines[iniFileName]["u32"][sect] or not iniOtherLines[iniFileName]["u32"][sect][line]) or
                (not iniLines["u32"][sect] or not iniLines["u32"][sect][line]) then
                -- amk.dump_table(iniLines)
                local ini, sectLines = getIniValuePrepare("u32", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_u32(sect, line)
                else
                    sectLines[line] = default
                end
            end
        
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["u32"][sect][line]
            else
                return iniLines["u32"][sect][line]
            end
         else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_u32(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueString(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueString: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string"] or not iniOtherLines[iniFileName]["string"][sect] or not iniOtherLines[iniFileName]["string"][sect][line]) or
                (not iniLines["string"] or not iniLines["string"][sect] or not iniLines["string"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string"][sect][line]
            else
                return iniLines["string"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueStringWQ(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueStringWQ: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["string_wq"] or not iniOtherLines[iniFileName]["string_wq"][sect] or not iniOtherLines[iniFileName]["string_wq"][sect][line]) or
                (not iniLines["string_wq"] or not iniLines["string_wq"][sect] or not iniLines["string_wq"][sect][line]) then
                local ini, sectLines = getIniValuePrepare("string_wq", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_string_wq(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["string_wq"][sect][line]
            else
                return iniLines["string_wq"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_string_wq(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function getIniValueBool(sect, line, default, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniValueBool: "..tostring(sect)..", "..tostring(line)..", "..tostring(default)..", "..tostring(iniFileName))
    if sect and line then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["boolean"] or not iniOtherLines[iniFileName]["boolean"][sect] or iniOtherLines[iniFileName]["boolean"][sect][line] == nil) or
                (not iniLines["boolean"][sect] or iniLines["boolean"][sect][line] == nil) then
                local ini, sectLines = getIniValuePrepare("boolean", sect, iniFileName)
                if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                    sectLines[line] = ini:r_bool(sect, line)
                else
                    sectLines[line] = default
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["boolean"][sect][line]
            else
                return iniLines["boolean"][sect][line]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) and ini:line_exist(sect, line) then
                return ini:r_bool(sect, line)
            else
                return default
            end
        end
    else
        return default
    end
end

function iniLinesCount(sect, iniFileName)
   -- get_console():execute("load ~~~ iniCaching iniLinesCount: "..tostring(sect)..", "..tostring(iniFileName))
    if sect then
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or not iniOtherLines[iniFileName]["line"][sect]["count"]) or
                (not iniLines["line"] or not iniLines["line"][sect] or not iniLines["line"][sect]["count"]) then
                --get_console():execute("load ~~~ iniCaching iniLinesCount: 1")
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                
                if iniLineSectionExist(sect, iniFileName) then
                    sectLines["count"] = ini:line_count(sect)
                else
                    sectLines["count"] = 0
                end
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["count"]
            else
                return iniLines["line"][sect]["count"]
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) then
                return ini:line_count(sect)
            else
                return 0
            end
        end
    else
        return 0
    end
end

function iniLineSectionExist(sect, iniFileName)
    --get_console():execute("load ~~~ iniCaching iniLineSectionExist: "..tostring(sect)..", "..tostring(iniFileName))
    if sect then
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or iniOtherLines[iniFileName]["line"][sect]["exist"] == nil) or
                (not iniLines["line"] or not iniLines["line"][sect] or iniLines["line"][sect]["exist"] == nil) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                sectLines["exist"] = (ini and ini:section_exist(sect))
            end
            
            -- amk.dump_table(iniLines)
            if iniFileName then
                return iniOtherLines[iniFileName]["line"][sect]["exist"] -- > -1
            else
                return iniLines["line"][sect]["exist"] -- > -1
            end
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            return (ini and ini:section_exist(sect))
        end
    else
        return false
    end
end

function getIniLine(sect, lineNumber, defaultKey, defaultValue, iniFileName)
    --get_console():execute("load ~~~ iniCaching getIniLine: "..tostring(sect)..", "..tostring(lineNumber)..", "..tostring(defaultKey)..", "..tostring(defaultValue)..", "..tostring(iniFileName))
    if sect and lineNumber then
        if iniStatistic then
            if iniStat[sect] then
                iniStat[sect] = iniStat[sect] + 1
            else
                iniStat[sect] = 1
            end
        end
        
        if iniCaching and (iniSections[sect] or iniSectionsCount == 0) then
            if iniFileName and (not iniOtherLines[iniFileName] or not iniOtherLines[iniFileName]["line"] or not iniOtherLines[iniFileName]["line"][sect] or not iniOtherLines[iniFileName]["line"][sect]["lines"] or not iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber]) or
                (not iniLines["line"] or not iniLines["line"][sect] or not iniLines["line"][sect]["lines"] or not iniLines["line"][sect]["lines"][lineNumber]) then
                local ini, sectLines = getIniValuePrepare("line", sect, iniFileName)
                if not sectLines["lines"] then
                    sectLines["lines"] = {}
                end
                local result, key, value = ini:r_line(sect, lineNumber, defaultKey, defaultValue)
                sectLines["lines"][lineNumber] = {result, key, value}
            end
            
            -- amk.dump_table(iniLines)
            local t
            if iniFileName then
                t = iniOtherLines[iniFileName]["line"][sect]["lines"][lineNumber]
            else
                t = iniLines["line"][sect]["lines"][lineNumber]
            end
            return t[1], t[2], t[3]
        else
            local ini
            if iniFileName then
                ini = ini_file(iniFileName)
            else
                ini = sys_ini
            end
            
            if ini and ini:section_exist(sect) then
                return ini:r_line(sect, lineNumber, defaultKey, defaultValue)
            else
                return false, defaultKey, defaultValue
            end
        end
    else
        return false, defaultKey, defaultValue
    end
end

function getIniValuePrepare(valueType, sect, iniFileName)
    local ini
    local sectLines
    if iniFileName then
        ini = ini_file(iniFileName)
        if not iniOtherLines[iniFileName] then
            iniOtherLines[iniFileName] = {}
        end
        if not iniOtherLines[iniFileName][valueType] then
            iniOtherLines[iniFileName][valueType] = {}
        end
        if not iniOtherLines[iniFileName][valueType][sect] then
            iniOtherLines[iniFileName][valueType][sect] = {}
        end
        sectLines = iniOtherLines[iniFileName][valueType][sect]
    else
        ini = sys_ini
        if not iniLines[valueType] then
            iniLines[valueType] = {}
        end
        if not iniLines[valueType][sect] then
            iniLines[valueType][sect] = {}
        end
        sectLines = iniLines[valueType][sect]
    end
	return ini, sectLines
end
-------======= / ini reading functions by sapsan =======------
----------------------------------------------------------------------
log = function(fmt, ...)
	log1( string.format(fmt, ...) )
end

function printf(fmt,...)
--[[ Раскомментить это для включения расширенного лога
	log(string.format(fmt,...))
--]]

--[[
	local arg={...}
	if arg==nil or arg[0]==nil then
		log(fmt)
	else
		log(string.format(fmt,...))
	end
--]]
end

local bufferedmessages={}

function mylog(msg)
--[[
  if msg==nil then
    return 
  end
  if db and Actor then
    if bufferedmessages then
      for k,v in ipairs(bufferedmessages) do
        Actor:give_game_news(v, "ui\\ui_iconsTotal", Frect():set(0,0,200,200), 0, 15000)
      end
      bufferedmessages=nil
    end
  Actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(0,0,200,200), 0, 15000)
  else
    if bufferedmessages then
      table.insert(bufferedmessages,msg)
    end
  end
]]
	log(msg)
end

function dbglog(fmt,...)
  local msg = string.format(fmt, ...)
--  local msg_no_ws = string.gsub(msg, "%s", "_")
--  get_console():execute("dbg:" .. msg_no_ws)
	log(msg)
end

----------------------------------------------------------------------
if nil == time_global then
  time_global = function () return device():time_global() end
end

function wait_game(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = game.time() + time_to_wait
        while game.time() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function wait(time_to_wait)
    verify_if_thread_is_running()
    if (time_to_wait == nil) then
        coroutine.yield()
    else
        local time_to_stop = time_global() + time_to_wait
        while time_global() <= time_to_stop do
            coroutine.yield()
        end
    end
end

function action(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,false)
    end
    return  entity_action(act)
end

function action_first(obj,...)
    local arg = {...}
    local act = entity_action()
    local i = 1
    while true do
        if (arg[i] ~= nil) then
            act:set_action(arg[i])
        else
            break
        end
        i = i + 1
    end
    if (obj ~= nil) then
        obj:command(act,true)
    end
    return  entity_action(act)
end

function round (value)
    local min = math.floor (value)
    local max = min + 1
    if value - min > max - value then return max end
    return min
end

function debug_get_level_object(obj_name)
    local res = level.debug_object(obj_name)
    while res == nil do

-- НЕ ЗАКОММЕНТАРИВАЙТЕ, ИНАЧЕ НЕ БУДЕТ ВИДНО ОШИБОК ПРИ РАССТАНОВКЕ ОБЪЕКТОВ!
        printf("get_level_object() is waiting for object \"%s\"", obj_name)

        res         = level.object(obj_name)
        wait        ()
    end
    return          res
end

function debug_get_actor()
    local res       = level.debug_actor()
    while res == nil do
        res         = level.debug_actor()
        wait        ()
    end
    return          res
end

function distance_between(obj1, obj2)
    return obj1:position():distance_to(obj2:position())
end

--// Если один объект nil, например нет актера, то считаем, что он далеко
function distance_between_safe(obj1, obj2)
    if(obj1 == nil or obj2 == nil) then return 100000 end
  return obj1:position():distance_to(obj2:position())
end


--' Проверка на инфопоршны, даже если игрока не существует
function has_alife_info(info_id)
	if AI == nil then
		return false
	end
	return AI:has_info(0, info_id)
end

-------------------------------------------------------------------
function reset_action (npc, script_name)
    if npc:get_script () then
       npc:script (false, script_name)
    end
    npc:script (true, script_name)
end

--------------------------------------------------
-- Functions and variables added by Zmey
--------------------------------------------------

-- Константа, которую использовать в местах, где нужно задать неограниченное время действия
time_infinite = 100000000

-- Название скрипта, который в данный момент находится в отладке
-- (в этом скрипте будут срабатывать вызовы функции debug_log)
debug_script_name = ""

-- Выводит в лог строчку, если script_name == debug_script_name
-- Lспользуется для отладки сценариев
function debug_log(script_name, fmt, ...)
  if debug_script_name == script_name then
    log(string.format(fmt, ...))
  end
end

-- Если в данный момент выполняется какое-то действие, прерывает его и отключает скриптовый режим
function interrupt_action(who, script_name)
  if who:get_script() then
    who:script(false, script_name)
  end
end

function random_choice(...)
    local arg = {...}
    local r = math.random(1, #arg)
    return arg[r]
end

function new_action(...)
    local arg = {...}
    local act = entity_action()
    for i = 1, #arg do
        act:set_action(arg[i])
    end
    return act;
end

obj_last_actions = {};

function perform_action(obj, action_name, action)
  if (obj ~= nil) then
    obj_last_actions[obj] = action_name
    obj:command(act, false)
  end
end

function last_action(obj)
  return obj_last_actions[obj]
end

function if_then_else(cond, if_true, if_false)
    if cond then
        return if_true
    end
    return if_false
end

function update_action (npc, script, ...)
    local arg = {...}
    if npc == nil then return end
    local act = npc:action ()
    if arg.n == 0 then return end

    if act == nil then act = entity_action () end

    for a = 1, arg.n, 1 do
        if arg[a] ~= nil then act:set_action (arg[a]) end
    end
    reset_action (npc, script)
    npc:command (act, false)

end


function set_current_time (hour, min, sec)
    local current_time_factor = level.get_time_factor ()

    printf ("Need time : %d:%d:%d", hour, min, sec)

    local current_time = game.time ()
    local c_day = math.floor (current_time / 86400000)
    local c_time = current_time - c_day * 86400000
    local n_time = (sec + min * 60 + hour * 3600) * 1000

    if c_time > n_time then c_day = c_day + 1 end
    n_time = n_time + c_day * 86400000

    level.set_time_factor (10000)
    while game.time () < n_time do wait () end

    level.set_time_factor (current_time_factor)
end

-- Имитация движкового класса Fvector2
class "vector2"
function vector2:__init()
	self.x = 0
	self.y = 0
end
function vector2:__finalize()
end
function vector2:set(x, y)
	self.x = x
	self.y = y
	return self
end
function vector2:add(vec2)
	self.x = self.x + vec2.x
	self.y = self.y + vec2.y
	return self
end
function vector2:sub(vec2)
	self.x = self.x - vec2.x
	self.y = self.y - vec2.y
	return self
end
function vector2:div(x, y)
	if not y then y = x end
	self.x = self.x/x
	self.y = self.y/y
	return self
end
function vector2:mul(x, y)
	if not y then y = x end
	self.x = self.x*x
	self.y = self.y*y
	return self
end
function vector2:get()
	return self.x, self.y
end
function vector2:distance_to(vec2)
	local dx, dy = (self.x - vec2.x), (self.y - vec2.y)
	return math.sqrt(dx*dx + dy*dy)
end
function vector2:clamp(rect)
	self.x = math.clamp(self.x, rect.x1, rect.x2)
	self.y = math.clamp(self.y, rect.y1, rect.y2)
	return self
end

class "pp_effector" (effector)

function pp_effector:__init(effector_type,start_time,dest_power,life_time) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.max_power  = dest_power
end

function pp_effector:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.max_power.dual.h         * d
    dual.v          = self.max_power.dual.v         * d

    noise.grain     = self.max_power.noise.grain        * d
    noise.intensity     = self.max_power.noise.intensity    * d
    noise.fps       = self.max_power.noise.fps      * d

    base.r          = self.max_power.color_base.r       * d
    base.g          = self.max_power.color_base.g       * d
    base.b          = self.max_power.color_base.b       * d

    gray.r          = self.max_power.color_gray.r       * d
    gray.g          = self.max_power.color_gray.g       * d
    gray.b          = self.max_power.color_gray.b       * d

    add.r           = self.max_power.color_add.r        * d
    add.g           = self.max_power.color_add.g        * d
    add.b           = self.max_power.color_add.b        * d

    pp.gray         = self.max_power.gray           * d
    pp.blur         = self.max_power.blur           * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return              true
end

function pp_effector:finished()
    return          self.stop_time < time_global()
end

--
-- postprocess for rainbow
--
class "pp_linear_lerp" (effector)

function pp_linear_lerp:__init(effector_type,start_time,life_time,start_power,dest_power) super(effector_type,start_time)
    self.start_time = start_time
    self.stop_time  = start_time + life_time
    self.min_power  = start_power
    self.max_power  = dest_power
end

function pp_linear_lerp:process(pp)
    effector.process(self,pp)

    local curr_time = time_global()
    local d         = 0.0

    if curr_time < self.start_time then
        d           = 0.0
    else
        if curr_time < self.stop_time then
            d           = (curr_time - self.start_time) / (self.stop_time - self.start_time)
        else
            self.info   = self.max_power
            return      true
        end
    end

    local dual      = duality()
    local noise     = noise()
    local base      = color()
    local gray      = color()
    local add       = color()

    dual.h          = self.min_power.dual.h         + (self.max_power.dual.h        - self.min_power.dual.h     )   * d
    dual.v          = self.min_power.dual.v         + (self.max_power.dual.v        - self.min_power.dual.v     )   * d

    noise.grain     = self.min_power.noise.grain        + (self.max_power.noise.grain       - self.min_power.noise.grain    )   * d
    noise.intensity     = self.min_power.noise.intensity    + (self.max_power.noise.intensity   - self.min_power.noise.intensity)   * d
    noise.fps       = self.min_power.noise.fps      + (self.max_power.noise.fps         - self.min_power.noise.fps  )   * d

    base.r          = self.min_power.color_base.r       + (self.max_power.color_base.r      - self.min_power.color_base.r   )   * d
    base.g          = self.min_power.color_base.g       + (self.max_power.color_base.g      - self.min_power.color_base.g   )   * d
    base.b          = self.min_power.color_base.b       + (self.max_power.color_base.b      - self.min_power.color_base.b   )   * d

    gray.r          = self.min_power.color_gray.r       + (self.max_power.color_gray.r      - self.min_power.color_gray.r   )   * d
    gray.g          = self.min_power.color_gray.g       + (self.max_power.color_gray.g      - self.min_power.color_gray.g   )   * d
    gray.b          = self.min_power.color_gray.b       + (self.max_power.color_gray.b      - self.min_power.color_gray.b   )   * d

    add.r           = self.min_power.color_add.r        + (self.max_power.color_add.r       - self.min_power.color_add.r    )   * d
    add.g           = self.min_power.color_add.g        + (self.max_power.color_add.g       - self.min_power.color_add.g    )   * d
    add.b           = self.min_power.color_add.b        + (self.max_power.color_add.b       - self.min_power.color_add.b    )   * d

    pp.gray         = self.min_power.gray           + (self.max_power.gray          - self.min_power.gray       )   * d
    pp.blur         = self.min_power.blur           + (self.max_power.blur          - self.min_power.blur       )   * d

    pp.dual         = dual
    pp.noise        = noise
    pp.color_base       = base
    pp.color_gray       = gray
    pp.color_add        = add

    self.info       = pp

    return          true
end

function pp_linear_lerp:finished()
    return          self.stop_time < time_global()
end
--
-- end of postprocess for rainbow
--

----------------------------------------------------------------------------------------------------------------------
-- Evaluators
----------------------------------------------------------------------------------------------------------------------
-- зарезервированы id с номерами от 0 до 256 для создания стандартных эвалуаторов.

--Constant evaluator
class "const_evaluator" (property_evaluator)

function const_evaluator:__init (name, value) super (nil, name)
    self.value = value
end

function const_evaluator:evaluate()
    return          self.value
end

--Wait evaluator
class "wait_evaluator" (property_evaluator)

function wait_evaluator:__init (wait_time) super ()
    self.wait_time = wait_time
    self.first_call = true
    self.current_time = 0
end

function wait_evaluator:evaluate ()
    if self.first_call == true then
       self.first_call = false
       self.current_time = device ():time_global ()
       return false
    end

    local t = device():time_global () - self.current_time;
    if t > self.wait_time then return true end
    return false
end
--------------------------------------------------------------------------------
class "enabled_evaluator" (property_evaluator)

function enabled_evaluator:__init (name, storage) super ()
    self.a = storage
end

function enabled_evaluator:evaluate()
    return  self.a.enabled
end


-- хэш функция для строки (посмотреть литературу, на предмет оптимальной)
function stringhash(str)
	local mpl = 1
	local hash = 0
	for i = 1, string.len(str), 1 do
		local val = string.byte(str,i)
		hash = hash+mpl*val
		mpl = mpl*2
		if mpl == 512 then mpl = 1 end
	end
	return bit_and(hash, 65535)
end


function str_split (str)

    local strlen = string.len (str)

    local parts = {{}, {}, {}, {}}
    local cpart = 1

    for a = 1, strlen, 1 do
        local char = string.byte (str, a)
        if char ~= 95 then
           table.insert (parts[cpart], char)
        else
           cpart = cpart + 1
           if cpart > 4 then break end
        end
    end

    if cpart ~= 4 then return "unknown", "stalker", 0, 0 end

    local str1 = string.char ()
    local str2 = string.char ()
    local str3 = string.char ()
    local str4 = string.char ()

    local ref = parts[1]
    for a = 1, #ref, 1 do
        str1 = string.format ("%s%c", str1, ref[a])
    end

    ref = parts[2]
    for a = 1, #ref, 1 do
        str2 = string.format ("%s%c", str2, ref[a])
    end

    ref = parts[3]
    for a = 1, #ref, 1 do
        str3 = string.format ("%s%c", str3, ref[a])
    end

    ref = parts[4]
    for a = 1, #ref, 1 do
        str4 = string.format ("%s%c", str4, ref[a])
    end

    printf ("%s %s %d %d", str1, str2, str3, str4)
    return str1, str2, (str3 + 1) - 1, (str4 + 1) - 1
end

function random_number (min_value, max_value)
    if min_value == nil and max_value == nil then
      return math.random ()
    else
      return math.random (min_value, max_value)
    end
end

-- Время суток в мс
-- Чугай
local ms_per_day = 24 * 60 * 60 * 1000
function day_time()
    return math.mod( game.time(), ms_per_day )
end

--Time in hours
function local_hours()
    return math.floor( math.mod( game.time()/1000, 86400 )/ 3600 )
end

-- парсит строку вида "ааа, ббб, ввв..." в таблицу { "ааа", "ббб", "ввв", ... }
-- Чугай
function parse_names( s )
    local t = {}
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
    --for name in string.gfind( s, "%s*([^%,]+)%s*" ) do
        table.insert( t, name )
    end

    return t
end


function parse_key_value( s )
    local t = {}
  if s == nil then
    return nil
  end
    local key, nam = nil, nil
    for name in string.gfind( s, "([%w_\\]+)%p*" ) do
    if key == nil then
      key = name
    else
      t[key] = name
      key = nil
    end
    end
    return t
end


-- парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - целые числа
-- Чугай
--[[function parse_nums( s )
    local t = {}

    for entry in string.gfind( s, "([%w_\\]+)%p*" ) do
        table.insert( t, tonumber( entry ) )
    end

    return t
end]]

-- парсит строку вида "n1, n2, n3..." в таблицу { n1, n2, n3, ... } где n1, n2, n3... - дробные числа
function parse_nums( s )
  local t = {}

  for entry in string.gfind( s, "([%d%.]+)%,*" ) do
    table.insert( t, tonumber( entry ) )
  end

  return t
end

-- проверяет, есть ли объект в онлайне
function is_object_online(obj_id)
  return level.object_by_id(obj_id) ~= nil
end

function get_clsid(npc)
    if npc == nil then return nil end
	return npc:clsid()
end

--Вычисляет yaw в радианах
function yaw( v1, v2 )
    return  math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) )
end

function yaw_degree( v1, v2 )
    return  (math.acos( ( (v1.x*v2.x) + (v1.z*v2.z ) ) / math.sqrt((v1.x*v1.x + v1.z*v1.z ) * (v2.x*v2.x + v2.z*v2.z )) ) * 57.2957)
end
function yaw_degree3d( v1, v2 )
    return  (math.acos((v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)/math.sqrt((v1.x*v1.x + v1.y*v1.y + v1.z*v1.z )*(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z)))*57.2957)
end

function vector_cross (v1, v2)
    return vector ():set (v1.y  * v2.z  - v1.z  * v2.y, v1.z  * v2.x  - v1.x  * v2.z, v1.x  * v2.y  - v1.y  * v2.x)
end

--//Вращает вектор вокруг оси y против часовой стрелки

function vector_rotate_y (v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

-- очистка таблицы
function clear_table (t)
    local table_remove = table.remove
    while #t > 0 do
          table_remove (t, #t)
    end
end

-- Использует для монстров. Выбор точки, куда идти в некотором радиусе и чтоб точка была дальше на расстоянии
-- min_radius от текущей позиции(если это получится). center_id - центр позиции, вокруг которой живем,
-- position_id - тукущая позиция, radius - в каком радиусе выбирать точку, min_radius - минимальное расстояние, от текущей позиции до новой точки.
function new_point(center_id, position_id,radius, min_radius)
    local math_random = math.random
    local dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
    local pos = level.vertex_in_direction(center_id, dir, radius)
    local i   = 1

    while(level.vertex_position(position_id):distance_to(level.vertex_position(pos) ) < min_radius and i < 20) do
        dir = vector():set(math_random(-1000, 1000)/1000.0, 0.0001, math_random(-1000, 1000)/1000.0)
        pos = level.vertex_in_direction(center_id, dir, radius)
        i   = i + 1
    end

    return (level.vertex_position(pos))
end

function stop_play_sound(obj)
  if obj:alive() == true then
    obj:set_sound_mask(-1)
    obj:set_sound_mask(0)
  end
end

function object_type(obj)
    local otype = get_clsid(obj)
    local type

    if  otype == clsid.actor or
        otype == clsid.script_stalker or
        otype == clsid.script_trader
    then
        type = "stalker"
    elseif  otype == clsid.crow or
        otype == clsid.zombie or
        otype == clsid.flesh or
        otype == clsid.controller or
        otype == clsid.bloodsucker or
        otype == clsid.burer or
        otype == clsid.fracture or
        otype == clsid.chimera or
        otype == clsid.boar or
        otype == clsid.flesh_group or
        otype == clsid.dog_red or
        otype == clsid.dog_black or
        otype == clsid.cat or
        otype == clsid.pseudo_gigant
    then
        type = "monstr"
    elseif  otype == clsid.wpn_fn2000 or
        otype == clsid.wpn_ak74 or
        otype == clsid.wpn_lr300 or
        otype == clsid.wpn_hpsa or
        otype == clsid.wpn_pm or
        otype == clsid.wpn_fort or
        otype == clsid.wpn_binocular or
        otype == clsid.wpn_shotgun or
        otype == clsid.wpn_svd or
        otype == clsid.wpn_svu or
        otype == clsid.wpn_rpg7 or
        otype == clsid.wpn_val or
        otype == clsid.wpn_vintorez or
        otype == clsid.wpn_walther or
        otype == clsid.wpn_usp45 or
        otype == clsid.wpn_groza or
        otype == clsid.wpn_knife or
        otype == clsid.wpn_scope or
        otype == clsid.wpn_silencer or
        otype == clsid.wpn_grenade_launcher or
        otype == clsid.obj_physic or
        otype == clsid.obj_breakable or
        otype == clsid.device_pda or
        otype == clsid.device_torch or
        otype == clsid.device_detector_simple or
        otype == clsid.obj_bolt or
        otype == clsid.obj_medkit or
        otype == clsid.obj_food or
        otype == clsid.obj_bottle or
        otype == clsid.obj_antirad or
        otype == clsid.obj_explosive or
        otype == clsid.obj_document or
        otype == clsid.obj_attachable or
        otype == clsid.wpn_grenade_f1 or
        otype == clsid.wpn_grenade_rpg7 or
        otype == clsid.wpn_grenade_rgd5 or
        otype == clsid.wpn_grenade_fake or
        otype == clsid.equ_scientific or
        otype == clsid.equ_stalker or
        otype == clsid.equ_military or
        otype == clsid.equ_exo or
        otype == clsid.wpn_ammo or
        otype == clsid.wpn_ammo_vog25 or
        otype == clsid.wpn_ammo_og7b or
        otype == clsid.wpn_ammo_m209
    then
        type = "item"
    else
        type = "none"
    end

    -- проверяем не труп ли это
    if type == "stalker" or
       type == "monstr" then
        if obj:alive() == false then
            type = "corpse"
        end
    end

    return type
end


--// Является ли оbj монстром
function is_object_monster(obj)
  local otype = get_clsid(obj)
  if(otype == clsid.crow      or
    otype == clsid.zombie   or
    otype == clsid.flesh    or
    otype == clsid.controller or
    otype == clsid.bloodsucker  or
    otype == clsid.burer    or
    otype == clsid.fracture    or
    otype == clsid.chimera    or
    otype == clsid.boar     or
    otype == clsid.dog_red    or
    otype == clsid.dog_black  or
	otype == clsid.cat		or

    otype == clsid.poltergeist  or
    otype == clsid.pseudo_gigant  )
  then
    return true
  end

  return false
end

--возвращает произвольную точку пути у которой установлен бит
function point_with_bit(patrol_path, bit, old_point)      -- old_point - индекс точки, которую не надо выбирать,
  local points = {}                                       -- параметр не обязательный( например текущей точки )

    for i = 0, patrol_path:count()-1 do
      --Добовляем в таблицу точки с нужным битом
      if( patrol_path:flag(i, bit)) then
            --Добавляем точку если old_point == nil или новая точка не совпадает с old_point
            if old_point == nil or old_point ~= i then
                table.insert(points, patrol_path:point(i))
            end
        end
    end

    local number_point = #points

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return points[1]
    else
        return points[math.random(1, number_point)]
    end
end

--возвращает произвольную точку пути у которой установлен бит
function point_with_bit_id(patrol_path, bit, old_point)        -- old_point - индекс точки, которую не надо выбирать,
    local points = {}                                          -- параметр не обязательный( например текущей точки )

    for i = 0, patrol_path:count()-1 do
      --Добовляем в таблицу точки с нужным битом
      if( patrol_path:flag(i, bit)) then
            --Добавляем точку если old_point == nil или новая точка не совпадает с old_point
            if old_point == nil or old_point ~= i then
                table.insert(points, i)
            end
        end
    end

    local number_point = #(points)

    if(number_point == 0) then
        return nil
    elseif(number_point == 1) then
        return patrol_path:level_vertex_id(points[1])
    else
        return patrol_path:level_vertex_id(points[math.random(1, number_point)])
    end
end

--Возвращает индекс самой ближней точки пути с заданым битом, от текущей точки
function near_point_with_bit(point, patrol_path, bit)
    local new_point = nil
    local index     = nil
    local dist      = 1000.0

    for i = 0, patrol_path:count()-1 do
        if( patrol_path:flag(i, bit) ) then
            if(new_point == nil or patrol_path:point(i):distance_to(point) < dist) then
                -- сли эта точка первая из нашедшихся, либо от нее путь ближе, то запоминаем ее
                new_point   = patrol_path:point(i)
                index       = i
                dist        = new_point:distance_to(point)
             end
        end
    end

    return index
end

-- Рекурсивная распечатка таблицы
function print_table(table, subs)
  local sub
  if subs ~= nil then
    sub = subs
  else
    sub = ""
  end
  for k,v in pairs(table) do
    if type(v) == "table" then
      printf(sub.."%s:", tostring(k))
      print_table(v, sub.."    ")
    elseif type(v) == "function" then
      printf(sub.."%s:function", tostring(k))
    elseif type(v) == "userdata" then
      printf(sub.."%s:userdata", tostring(k))
    elseif type(v) == "boolean" then
  if v == true then
    printf(sub.."%s:true", tostring(k))
  else
    printf(sub.."%s:false", tostring(k))
  end
    else
      if v ~= nil then
        printf(sub.."%s:%s", tostring(k),v)
      else
        printf(sub.."%s:nil", tostring(k),v)
      end
    end
  end
end

-------------------------------------------------------------------------------------------
function switch_online (id)
    if id == -1 then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (id, true)
       sim:set_switch_offline (id, false)
    end
end
-------------------------------------------------------------------------------------------
function switch_offline (npc)
    if npc == nil or npc:alive () == false then return end
    local sim = alife ()
    if sim ~= nil then
       sim:set_switch_online  (npc:id (), false)
       sim:set_switch_offline (npc:id (), true)
    end
end
-------------------------------------------------------------------------------------------
function get_actor_id()
  if(level.actor() == nil) then return -1 end
  return level.actor():id()
end
-------------------------------------------------------------------------------------------
IAmAStalker = {}
IsHuman = {}
IAmAMonster = {}
IAmAnArtefact = {}
IAmAnOutfit = {}
IAmAnEatable = {}
IAmAGrenade = {}
IAmAScope = {}
IAmAKnife = {}
IAmAWeapon = {}
anom_classes = {}
clsid_magazined_weapon = {}

function InitObjectTypeTables()
	IAmAStalker = {
        [clsid.actor] = true,
        [clsid.script_stalker] = true
    }
	IsHuman = {
		[clsid.actor] = true,
		[clsid.script_stalker] = true,
		[clsid.script_trader] = true
	}
    IAmAMonster = {
       [clsid.boar_s] = true,
       [clsid.bloodsucker_s] = true,
       [clsid.dog_s] = true,
       [clsid.flesh_s] = true,
       [clsid.pseudodog_s] = true,
       [clsid.psy_dog_s] = true,
       [clsid.burer_s] = true,
       [clsid.cat_s] = true,
       [clsid.chimera_s] = true,
       [clsid.controller_s] = true,
       [clsid.fracture_s] = true,
       [clsid.poltergeist_s] = true,
       [clsid.gigant_s] = true,
       [clsid.zombie_s] = true,
       [clsid.tushkano_s] = true,
       [clsid.snork_s] = true
    }
    IAmAWeapon = {
		[clsid.wpn_ak74_s]              = "magazined_w_gl",
		[clsid.wpn_bm16_s]              = "shotgun",
		[clsid.wpn_grenade_f1]          = "grenade",
		[clsid.wpn_grenade_fake]        = "grenade_fake",
		[clsid.wpn_grenade_rgd5]        = "grenade",
		[clsid.wpn_grenade_rpg7]        = "grenade",
		[clsid.wpn_groza_s]             = "magazined_w_gl",
		[clsid.wpn_hpsa_s]              = "magazined",
		[clsid.wpn_knife_s]             = "knife",
		[clsid.wpn_lr300_s]             = "magazined",
		[clsid.wpn_pm_s]                = "magazined",
	    [clsid.wpn_rg6_s]               = "shotgun",
		[clsid.wpn_rpg7_s]              = "magazined",
		[clsid.wpn_shotgun_s]           = "shotgun",
		[clsid.wpn_svd_s]               = "magazined",
		[clsid.wpn_svu_s]               = "magazined",
		[clsid.wpn_usp45_s]             = "magazined",
		[clsid.wpn_val_s]               = "magazined",
		[clsid.wpn_vintorez_s]          = "magazined",
		[clsid.wpn_walther_s]           = "magazined",
		[clsid.wpn_binocular_s]         = "magazined"
	}
	clsid_magazined_weapon = {
	    [clsid.wpn_ak74_s]              = true,
	    [clsid.wpn_bm16_s]              = true,
	    [clsid.wpn_groza_s]             = true,
	    [clsid.wpn_hpsa_s]              = true,
	    [clsid.wpn_lr300_s]             = true,
	    [clsid.wpn_pm_s]                = true,
	    [clsid.wpn_rpg7_s]              = true,
	    [clsid.wpn_shotgun_s]           = true,
	    [clsid.wpn_svd_s]               = true,
	    [clsid.wpn_svu_s]               = true,
	    [clsid.wpn_usp45_s]             = true,
	    [clsid.wpn_val_s]               = true,
	    [clsid.wpn_vintorez_s]          = true,
	    [clsid.wpn_walther_s]           = true,
	    [clsid.wpn_binocular_s]         = true,
	    [clsid.wpn_rg6_s]               = true
	}
	IAmAnArtefact = {
		[clsid.art_bast_artefact]	= true,
		[clsid.art_black_drops]		= true,
		[clsid.art_dummy]			= true,
		[clsid.art_electric_ball]	= true,
		[clsid.art_faded_ball]		= true,
		[clsid.art_galantine]		= true,
		[clsid.art_gravi]			= true,
		[clsid.art_gravi_black]		= true,
		[clsid.art_mercury_ball]	= true,
		[clsid.art_needles]			= true,
		[clsid.art_rusty_hair]		= true,
		[clsid.art_thorn]			= true,
		[clsid.art_zuda]			= true,
		[clsid.artefact]			= true,
		[clsid.artefact_s]			= true,
		[clsid.art_gravi_s]			= true
	}
	IAmAnOutfit = {
		[clsid.equ_exo]			= true,
		[clsid.equ_military]	= true,
		[clsid.equ_scientific]	= true,
		[clsid.equ_stalker_s]	= true,
		[clsid.equ_stalker]		= true
	}
	IAmAnEatable = {
		[clsid.obj_antirad]	= true,
		[clsid.obj_bandage]	= true,
		[clsid.obj_bottle]	= true,
		[clsid.obj_food]	= true,
		[clsid.obj_medkit]	= true
	}
	IAmAGrenade={
		[clsid.wpn_grenade_f1]		= true,
		[clsid.wpn_grenade_fake]	= true,
		[clsid.wpn_grenade_rgd5]	= true,
		[clsid.wpn_grenade_rpg7]	= true
	}
	IAmAKnife={
		[clsid.wpn_knife]	=true,
		[clsid.wpn_knife_s]	=true
	}
	IAmAScope = {
		[clsid.wpn_scope_s]	= true,
		[clsid.wpn_scope]	= true
	}
	IAmAnAmmo = {
		[clsid.wpn_ammo]		= true,
		[clsid.wpn_ammo_vog25]	= true,
		[clsid.wpn_ammo_og7b]	= true,
		[clsid.wpn_ammo_m209]	= true
	}
	anom_classes = {
		[clsid.ameba_zone] 			 = false,
		[clsid.torrid_zone] 		 = false,
		[clsid.zone_bfuzz] 			 = false,
		[clsid.zone_dead] 			 = false,
		[clsid.zone_galantine] 		 = false,
		[clsid.zone_mincer] 		 = false,
		[clsid.zone_mosquito_bald] 	 = false,
		[clsid.zone_mosquito_bald_s] = false,
		[clsid.zone_rusty_hair] 	 = false,
		[clsid.zone_ogon_s]          = true,
		[clsid.zone_buzz_s]			 = true,
		[clsid.zone_sakbuzz_s]		 = true,
		[clsid.zone_bfuzz_s]		 = true,
		[clsid.zone_electra_s]		 = true,
		[clsid.zone_galant_s]		 = true,
		[clsid.zone_sphere_s]		 = true,
		[clsid.zone_ice_s]			 = true,
		[clsid.zone_mbald_s]		 = true,
		[clsid.zone_mincer_s]		 = true,
		[clsid.zone_zharka_s]		 = true,
		[clsid.zone_fountain_s]		 = true,
		[clsid.zone_smallrain_s]	 = true,
		[clsid.zone_radioactive]	 = true
	}
end

function IsAnomaly(object, class_id, is_dynamic)
    local id = class_id or get_clsid (object)
	if is_dynamic then
		return anom_classes[id] == true
	end
	return anom_classes[id] ~= nil
end

function IsMonster (object, class_id)
    local id = class_id or get_clsid (object)
	return IAmAMonster[id]~=nil
end
function IsStalker (object, class_id)
    local id = class_id or get_clsid (object)
	return IAmAStalker[id]~=nil
end
function isWeapon(object, class_id)
	local id = class_id or get_clsid (object)
    return IAmAWeapon[id]~=nil
end
function isMagazinedWeapon(object, class_id)
	local id = class_id or get_clsid (object)
    return clsid_magazined_weapon[id]~=nil
end
function isArtefact(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAnArtefact[id]~=nil
end
function isOutfit(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAnOutfit[id]~=nil
end
function isEatable(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAnEatable[id]~=nil
end
function isGrenade(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAGrenade[id]~=nil
end
function isKnife(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAKnife[id]~=nil
end
function isScope(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAScope[id]~=nil
end
function isAmmo(object, class_id)
	local id = class_id or get_clsid (object)
	return IAmAnAmmo[id]~=nil
end

-------------------------------------------------------------------------------------------
function level_object_by_sid( sid )
	if AI then
		local se_obj = AI:story_object( sid )
		if se_obj then
			return level.object_by_id( se_obj.id )
		end
	end
	return nil
end

function id_by_sid( sid )
	if AI then
		local se_obj = AI:story_object( sid )
		if se_obj then
			return se_obj.id
		end
	end
	return nil
end

-- быстрый if
function iif(t,t1,t2)
	if t then
		return t1
	else
		return t2
	end
end

-- Крешнуть игру (после вывода сообщения об ошибке в лог)
function abort(fmt, ...)
	local reason = (...==nil and fmt) or string.format(fmt, ...)
	log1("! "..reason)
	get_console():execute("flush")
	if Actor then
		local msg = "!!!АХТУНГ!!!\\n%c[red]"..reason
		Actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(913,752,83,47), 0, 80000) 
	end
	fail("! ERROR: " .. reason)
	string.format("%s")
end

function ASSERT(obj, ...)
	if not obj then abort(...) end
end

function set_postprocess(name_ini_file)
  bind_actor.post_process = postprocess.PostProcess(ini_file(name_ini_file))
end
function remove_postprocess()
  bind_actor.post_process = nil
end

function set_inactivate_input_time(delta)
  db.storage[Actor:id()].disable_input_time = game.get_game_time()
  db.storage[Actor:id()].disable_input_idle = delta
  level.disable_input()
end
-- Принимает: позицию положения, позицию куда смотреть, время сна в минутах.
function set_sleep_relocate(point, look, timeout)
  db.storage[Actor:id()].sleep_relocate_time = game.get_game_time()
  db.storage[Actor:id()].sleep_relocate_idle = timeout*60
  db.storage[Actor:id()].sleep_relocate_point = point
  db.storage[Actor:id()].sleep_relocate_look = look

  --set_inactivate_input_time(timeout*60)
  --Actor:actor_sleep(0, timeout)
end

-- проверяет целую часть числа на нечётность
function odd( x )
  return math.floor( x * 0.5 ) * 2 == math.floor( x )
end

--' Усталость
function on_actor_critical_power()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_11_weakness")
  end
  if not has_alife_info("encyclopedy_tutorial_weakness") then
    Actor:give_info_portion("encyclopedy_tutorial_weakness")
  end
end

function on_actor_critical_max_power()
end

--' Кровотечение
function on_actor_bleeding()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_8_wound")
  end
  if not has_alife_info("encyclopedy_tutorial_wound") then
    Actor:give_info_portion("encyclopedy_tutorial_wound")
  end
end

function on_actor_satiety()
end

--' Радиация
function on_actor_radiation()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_6_radiation")
  end
  if not has_alife_info("encyclopedy_tutorial_radiation") then
    Actor:give_info_portion("encyclopedy_tutorial_radiation")
  end
end

--' Заклинило оружие
function on_actor_weapon_jammed()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_9_weapon")
  end
  if not has_alife_info("encyclopedy_tutorial_weapon") then
    Actor:give_info_portion("encyclopedy_tutorial_weapon")
  end
end

--' не может ходить изза веса
function on_actor_cant_walk_weight()
  if has_alife_info("esc_trader_newbie") then
    game.start_tutorial("part_14_overload")
  end
  if not has_alife_info("encyclopedy_tutorial_overload") then
    Actor:give_info_portion("encyclopedy_tutorial_overload")
  end
end

--' пси воздействие
function on_actor_psy()
end

function set_actor_rank(rank)
  if rank == "novice" then
    Actor:set_character_rank(0)
  elseif rank == "stalker" then
    Actor:set_character_rank(300)
  elseif rank == "veteran" then
    Actor:set_character_rank(600)
  elseif rank == "master" then
    Actor:set_character_rank(900)
  end
end

function get_texture_info(id_name, id_default)
  if id_default == nil then id_default = id_name end

  local task_info = GetTextureInfo(id_name, id_default)
  local r = task_info:get_rect()

  r.x2 = r.x2 - r.x1
  r.y2 = r.y2 - r.y1
  return task_info:get_file_name(), r
end

function need_show_condition(item)
	local b = sys_ini:r_bool_ex(item:section(), "show_condition", nil)
	return ( ( item:is_weapon() or item:is_outfit() ) and b ~= false ) or b == true
end

local upg_str = {"_kalibr", "_otdaca", "_ves", "_m1", "_m2", "_m3"}
function is_upgraded(section)
	for i, v in ipairs(upg_str) do
		if string.find(section, "^.-("..v..")$") ~= nil then
			return true
		end
	end
	return false
end

function set_story_id( obj, sid )
	AI:assign_story_id( nil, nil, obj.id, sid )
end

function is_story_object( obj )
	local sid
	if obj.m_story_id then
		sid = obj.m_story_id
	else
		sid = obj:story_id()
	end
	return sid < 4294967296
end

function object_level_name(obj)
	if not GGraph:valid_vertex_id(obj.m_game_vertex_id) then
		log("~ [object_level_name]: object '%s' has invalid vertex id[%s]", obj:name(), obj.m_game_vertex_id)
		return "unknown"
	end
	return AI:level_name( GGraph:vertex(obj.m_game_vertex_id):level_id() )
end

function del_obj_by_id(id)
	local obj = AI:object(id)
	if obj then
		AI:release(obj, true)
	end
end

function get_inv_name(section)
	if sys_ini:line_exist(section, "inv_name") then
		return sys_ini:r_string_wq(section, "inv_name")
	end
	return section
end
function GetIconParams(section)
	if section~=nil and section~=""
		and sys_ini:section_exist(section)
		and sys_ini:line_exist(section, "inv_grid_x")
	then
		return {x = sys_ini:r_u32(section, "inv_grid_x") *50,
				y = sys_ini:r_u32(section, "inv_grid_y") *50,
				w = sys_ini:r_u32(section, "inv_grid_width") *50,
				h = sys_ini:r_u32(section, "inv_grid_height") *50}
	end
	return {x=0, y=0, w=1, h=1}
end

function ShowMessageBox(...)
	ui_messagebox_new.UIMessageBox(...)
end

function shiftCheckDropItem(timeout)
	_G['biznes_remove_special_item']= true
	start_small_timer(timeout or 300,
		function() _G['biznes_remove_special_item'] = nil end
	)
end

local IsBlocked = false
function BlockUIDescr( b )
	if b == nil then
		return IsBlocked
	else
		IsBlocked = b
	end
end

local ShiftHold = false
function ShiftPressed( b )
	if b == nil then
		return ShiftHold
	else
		ShiftHold = b
	end
end

local en = [[qwertyuiop[]asdfghjkl;'zxcvbnm,./QWERTYUIOP{}|ASDFGHJKL:"ZXCVBNM<>?@#$^&]]
local ru = [[йцукенгшщзхъфывапролджэячсмитьбю.ЙЦУКЕНГШЩЗХЪ/ФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,"№;:?]]
local tt = {}
for i=1,#en do tt[en:sub(i,i)] = ru:sub(i,i) end
function translit(l) return tt[l] or l end

function format_text_pairs(text, fmt)
	for k, v in pairs(fmt) do
		text = string.gsub(text, "%$"..k, v)
	end
	return text
end

local kAlt   = { [DIK_keys.DIK_LMENU]  = true, [DIK_keys.DIK_RMENU]  = true }
local kShift = { [DIK_keys.DIK_LSHIFT] = true, [DIK_keys.DIK_RSHIFT] = true }
function check_input_language(wnd, dik, keyboard_action)
	if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		if kAlt[dik] then
			wnd.__alt_pressed = true
			if wnd.__shift_pressed then
				local l = get_input_language()
				set_input_language( l==1 and 0 or 1 )
			end
		elseif kShift[dik] then
			wnd.__shift_pressed = true
			if wnd.__alt_pressed then
				local l = get_input_language()
				set_input_language( l==1 and 0 or 1 )
			end
		end
	elseif keyboard_action == ui_events.WINDOW_KEY_RELEASED then
		if kAlt[dik] then
			wnd.__alt_pressed = nil
		elseif kShift[dik] then
			wnd.__shift_pressed = nil
		end
	end
	return true
end

-- флаги трассировки
rq_target = {
	rqtNone,
	rqtObject		= 1,
	rqtStatic		= 2,
	rqtShape		= 4,
	rqtObstacle		= 8,
	rqtBoth			= 3, -- rqtObject + rqtStatic
	rqtDyn			= 13, -- rqtObject + rqtShape + rqtObstacle
}
ray_pick = {}
-- устанавливает базовые параметры трассировки
function ray_pick.init(pos, dir, range, flags, obj)
	ray_pick.set_position(pos)
	ray_pick.set_direction(dir)
	ray_pick.set_range(range)
	ray_pick.set_flags(flags)
	ray_pick.set_ignore_object(obj)
end
-- устанавливает стартовую точку трассировки
function ray_pick.set_position(pos)
	Actor:set_vector_global_arg_2(pos)
end
-- устанавливает направление трассировки
function ray_pick.set_direction(dir)
	Actor:set_vector_global_arg_1(dir)
end
-- устанавливает диапазон трассировки
function ray_pick.set_range(range)
	set_float_args_12(range, 0)
end
-- устанавливает флаги трассировки (rq_target)
function ray_pick.set_flags(flags)
	set_int_arg1(flags)
end
-- устанавливает игнорируемый игровой объект для трассировки
function ray_pick.set_ignore_object(obj)
	Actor:set_object_arg_1(obj)
end
-- выполняет запрос на трассировку и возвращает true, если она была успешна
function ray_pick.check()
	return level.perform_ray_pick_query()
end
-- если трассировка была успешна, возвращает дистанцию до точки, иначе возвращает ранее заданный диапазон трассировки
function ray_pick.get_distance()
	return level.get_ray_pick_dist()	
end
-- если трассировка была успешна, возвращает игровой объект
function ray_pick.get_object()
	return level.get_ray_pick_obj()
end
-- если луч пересек игровой объект, то возвращает номер кости, иначе возвращает номер полигона статической геометрии (при неудачной трассировке возвращает -1)
function ray_pick.get_element()
	return level.get_ray_pick_element()
end
-- malandrinus
--[[counter = 0
prev_watch = 0
function watch_condition()
    counter = (bind_actor.watch_value == prev_watch) and (counter + 1) or 0
    prev_watch = bind_actor.watch_value
    if counter > 100 then
        get_console():execute("load ~~~ malandrinus bind_actor.watch_value: "..tostring(prev_watch)..", counter: "..tostring(counter))
        if Actor and not device():is_paused() then
            local snd_obj = xr_sound.get_safe_sound_object("detectors\\da-2_beep1")
            snd_obj:play_no_feedback(Actor, sound_object.s2d, 0, vector(), 2.5)
        end
    end
    return false
end
function dummy_action()
    return false
end
-- /malandrinus
]]
function start_game_callback()
	_G.AI		= alife()
	_G.GGraph	= game_graph()
	_G.netpk	= naxac_netpk.init()

	-- malandrinus
	--level.add_call(watch_condition, dummy_action)
	--/ malandrinus
	-- printf  ("start_game_callback called")
	InitObjectTypeTables()
	task_manager.clear_task_manager()
	treasure_manager.clear_treasure_manager()
	xr_sound.clear_all_sound_object()
	dialog_manager.fill_phrase_table() 

	amk.getStartTime()

	-- Пишем версию мода в лог
	local mm = _G.main_menu.get_main_menu()
	log1( "# X-Ray Engine v"..mm:GetGSVer().." .. XE r232 .. xrLua Ext. by RvP" )
	log1( "# "..meceniy_utils.read_mod_ver() )
end

