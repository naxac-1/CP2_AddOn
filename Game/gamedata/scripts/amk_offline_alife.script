-- -*- mode: lua; encoding: windows-1251 -*-
-- файл из мода "Народной солянки 2009" от 14.06. Адаптирован для мода 'Метки с хабаром 2.1.4' 06.07.2009
-- Адаптирован для Менеджера оружия. Rulix aka Bak от 2.07.09
-- Адатировал: Idler.

local table_sort = table.sort
local table_remove = table.remove
local math_random = math.random
local math_floor = math.floor
local math_abs = math.abs
local math_ceil = math.ceil
local string_find = string.find

off_npcs={}
items={}
local no_sell_table = {}

local wpn_fp = {}
-- Пора апдейт делать
local bFlag = false
-- Номер последнего отработанного обьекта
local iCounter = 1
-- Время последнего глобального апдейта
local iTime = -1
-- Как часто делать апдейты, игровые минуты
local iFreq = 60

local monster_params = {}

local maps={
	"l01_escape",
	"l02_garbage",
	"l03_agroprom",
--	"l03u_agr_underground",
	"l04_darkvalley",
--	"l04u_labx18",
	"l05_bar",
	"l06_rostok",
	"l07_military",
	"l08_yantar",
	--"l08u_brainlab",
	"l10_radar",
	--"l10u_bunker",
	"l11_pripyat",
	--"l12_stancia",
	--"l12_stancia_2",
	--"l12u_control_monolith",
	--"l12u_sarcofag"
	"marsh",
	"atp_for_test22",
	"limansk",
	"red_forest",
	"zaton",
	"l41_darkscape_ogse",
	"generators",
	"aver"
}

protected = {
	names = {		-- имена объектов
		"agro_taynik_konteyner_03",
		"dead_city_banda_yzik3",
		"esc_inventory_box_0003",
		"lima_podval_seif",
		"obmorok_seif"
	},
	ids = {},		-- ID объектов
	story_ids = {	-- story ID объектов
		story_ids.bar_arena_inventory_box,
		story_ids.esc_secret_0008,
		story_ids.esc_secret_0013,
		story_ids.esc_secret_0014,
		story_ids.gar_secret_0011,
		story_ids.agr_secret_0000,
		story_ids.agr_secret_0019,
		story_ids.agr_u_secret_0004,
		story_ids.mil_secret_0005,
		story_ids.mil_secret_0022,
		story_ids.mil_secret_0026,
		story_ids.yan_secret_0008,
		story_ids.yan_secret_0009,
		story_ids.x16_secret_0000,
		story_ids.x16_secret_0001,
		story_ids.rad_secret_0000,
		story_ids.rad_secret_0001,
		story_ids.rad_secret_0002,
		story_ids.rad_secret_0003,
		story_ids.rad_secret_0004,
		story_ids.rad_secret_0005,
		story_ids.pri_secret_0003,
		story_ids.pri_secret_0004,
		story_ids.val_secret_0008,
		story_ids.val_secret_0013,
		story_ids.val_secret_0028,
		story_ids.x18_secret_0000,
		story_ids.x18_secret_0001,
		story_ids.bar_secret_0009,
		story_ids.bar_secret_0011,
		story_ids.ros_secret_0015,
		story_ids.ros_secret_0016,
		story_ids.ros_secret_0017,
		story_ids.ros_secret_0018,
		story_ids.ros_secret_0019,
		story_ids.agr_sak_inventory_box,
		story_ids.kontik_vodka_box
	},
	sections = {	-- секции объектов
		"volna_shron",
		"taynik_kuznec7",
		"dyak_mines_box",
		"radiodetail_box2",
		"radiodetail_box4",
		"keis_key_box",
		"computer_flash",
		"notebook_flash",
		"disk_flash",
		"pda_flash",
		"taynik_podarok"
	}
}

local smart_filters = {
	"esc_bridge", "esc_blokpost", "amk_embankment"
}


local rel_enemy,rel_friend

local look_radius = 60			-- Радиус "обзора"
local look_radius_box = 50		-- Радиус поиска нычек

local search_intensivity = 60	--интенсивность поиска (количество отрабатываемых неписей)

local max_rounds = 10			-- продолжительность боев

local health_wound = 0.20		-- При каком уровне здоровья НПС считается раненым
local health_wound_set = 0.02

local base_fp = 1400			-- Эталон firepower\distance при distance = 1 который снимет 100% health

local dist_coeff = 8			-- Коэффициент для расстояния

local sell_limit = 6000			-- Вещи дешевле продает торговцам, дороже - через новости

local rate_kill_base = 100		-- Рейтинг за убийство. При убийстве более слабого - 0.5 * rate_kill_base, более сильного - 2 * rate_kill_base
local rate_art_found = 100		-- Рейтинг за артефакты

local to_actor = 150			-- расстояние до актёра, на котором работает оффлайн-алайф

local function insert_npc_item(se_obj)
	local npc_id = se_obj.parent_id
	if items[npc_id] then
		local obj_id = se_obj.id
		for i, v in ipairs( items[npc_id] ) do
			if v.id == obj_id then
				return false
			end
		end
	else
		items[npc_id] = {}
	end
	table.insert( items[npc_id], { id = se_obj.id, name = se_obj:name() } )
	return true
end

function update()
	if (bFlag == false and iTime ~= -1) then
		if (game_time_minutes - iTime > iFreq) then
			bFlag = true			
			off_npcs={}	
			items={}
			iCounter = 1
		--	amk.mylog("Updating offline-ALife started")
		end
	end
	if (bFlag == true) then
		if (iCounter >= 65535) then
			bFlag = false
			iTime = game_time_minutes
			iCounter = 1
		--	amk.mylog("Updating offline-ALife finished")
		else
			add_fresh_meat( AI:object(iCounter) )
			iCounter = iCounter + 1
		end
	end
end

--on_death - не убиваем! off_npcs
--on_hit - не обрабатываем!
function add_fresh_meat(obj)
	if obj and obj.m_game_vertex_id and GGraph:valid_vertex_id(obj.m_game_vertex_id)
		and ( not protected_items.actor_items_keep(obj:section_name()) )
		and ( not protected_items.is_no_offline_alife_npc(obj) )
	then
		local map = object_level_name(obj)
		local cls = obj:clsid()
		if not off_npcs[map] then off_npcs[map]={monsters={},stalkers={},weapons={},artefacts={},inv_boxes={}} end
		if IAmAMonster[cls] and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if bit_and(flags, 1) ~= 1 then --Уберем тех, у кого on_hit есть.
					table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
				end
		elseif cls==clsid.script_stalker and obj.alive and obj:alive() and obj.health and obj:health()>0 and obj.m_story_id == 4294967296 then
				local flags = get_flags(obj.id)
				if bit_and(flags, 1) ~= 1 then --Уберем тех, у кого on_hit есть.
					if obj:community()~="zombied" then
						table.insert(off_npcs[map].stalkers, {id = obj.id, name = obj:name()})
					else
						table.insert(off_npcs[map].monsters, {id = obj.id, name = obj:name()})
					end
				end
		elseif IAmAWeapon[cls] then
			if obj.m_story_id == 4294967296 then
				if obj.parent_id then
					local p_obj = AI:object(obj.parent_id)
					if p_obj then
						if p_obj.m_game_vertex_id and GGraph:valid_vertex_id(p_obj.m_game_vertex_id) then
							if p_obj:clsid() == clsid.inventory_box then
								-- НПС "не видят" этого
								map = ""
							else
								local p_map = object_level_name(p_obj)
								if p_map ~= map then
									if not off_npcs[p_map] then
										off_npcs[p_map] = {	monsters={},stalkers={},weapons={},artefacts={},inv_boxes={} }
									end
									map = p_map
								end	
							end
						end
					end
				end
				if map ~= "" then
					table.insert(off_npcs[map].weapons, {id=obj.id, name = obj:name()}) 
				end
			end
		elseif string_find(obj:section_name(),"^af_") then
			if obj.parent_id then
				local p_obj = AI:object(obj.parent_id)
				if p_obj then
					if p_obj.m_game_vertex_id and GGraph:valid_vertex_id(p_obj.m_game_vertex_id) then
						if p_obj:clsid() == clsid.inventory_box then
							-- НПС "не видят" этого
							map = ""
						else
							local p_map = object_level_name(p_obj)
							if p_map ~= map then
								if not off_npcs[p_map] then off_npcs[p_map]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}} end
								map = p_map
							end	
						end
					end
				end
			end
			if map ~= "" then table.insert(off_npcs[map].artefacts, {id = obj.id, name = obj:name()}) end
		elseif cls == clsid.inventory_box and not box_is_protected(obj) then
			table.insert(off_npcs[map].inv_boxes, {id = obj.id, name = obj:name()})
		end
			
		if obj.parent_id and obj.m_story_id == 4294967296
			and not (IAmAMonster[cls] or IAmAStalker[cls])
		then
			local zz = AI:object(obj.parent_id)
			if zz then
				insert_npc_item(obj)
				gps_habar.insert_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
			end
		end
	end
end

--строим таблицу неписей, монстров и оружия
function build_tables()
	rel_enemy = sys_ini:r_float("game_relations", "goodwill_enemy")
	rel_friend = sys_ini:r_float("game_relations", "goodwill_friend")

	--' Предметы, которые нельзя продавать (квестовые например)
	-- уже было загружено в death_manager, возьмём оттуда
	no_sell_table = death_manager.get_keep_items()
	-- Добавим в таблицу, что нельзя продавать.
	local sini = ini_file("misc\\trade_generic.ltx")
	local cfg_sell = sini:r_string("trader", "sell_condition")
	if sini and sini:section_exist(cfg_sell) then
		local result, id, value
		for a = 0, sini:line_count(cfg_sell)-1 do
			result, id, value = sini:r_line(cfg_sell,a,"","")
			if id and (value==nil or value=="") then
				no_sell_table[id] = true
			end
		end
	end
end

function update_trade()
	local obj
	for a=1,65534 do
		obj = AI:object(a)
		if obj then
			process_trade(obj)
		end
	end
end

function update_tables(level)
	off_npcs[level]={monsters={},stalkers={},weapons={},artefacts={}, inv_boxes={}}
	local obj, p_obj
	for a=1,65534 do
		obj = AI:object(a)
		if obj then
			if GGraph:valid_vertex_id(obj.m_game_vertex_id) and object_level_name(obj) == level then
				add_fresh_meat(obj)
			elseif obj.parent_id then
				p_obj = AI:object(obj.parent_id)
				if p_obj and GGraph:valid_vertex_id(p_obj.m_game_vertex_id)	and object_level_name(p_obj) == level then
					add_fresh_meat(obj)
				end
			end
		end
	end	
end

--генерируем оффлайн события
function offline_alife()
	amk.oau_reason="cn offline_alife start"
	local lname = table.random(maps)
--	update_tables(lname)
--	log("# Offline_alife -> %s", lname)
	amk.oau_reason="cn offline_alife chp1"

	local st = 0
	local npcs = off_npcs[lname]
	if npcs then st = #npcs.stalkers end
	if st == 0 then return end

--	log("stalkers found [%s]", st)
	amk.oau_reason="cn offline_alife chp2"
	local idxs = {}
	for i = 1, st do
		table.insert(idxs, i)
	end
	local rnd = 0
	for search = 1, math.min(st, search_intensivity) do
		amk.oau_reason="cn offline_alife chp3"
		rnd = table.remove(idxs, math_random(#idxs))
		amk.oau_reason="cn offline_alife chp4"
		if npcs.stalkers[rnd] then 
			amk.oau_reason="cn offline_alife chp5"
			local victim = AI:object(npcs.stalkers[rnd].id)
			amk.oau_reason="cn offline_alife chp6"
			local victim_name = victim and victim:name()
			if victim and (not victim.online) and victim.health and victim.can_switch_online
				and victim:health()>0 and victim:can_switch_online()
				and victim_name == npcs.stalkers[rnd].name
			then
			--	log("- process offline_alife for [%s]", victim_name)
				amk.oau_reason="cn offline_alife chp7 "..victim_name
				local vdata = collect_info(victim,lname)
				amk.oau_reason="cn offline_alife chp8 "..victim_name
			--	table.print(vdata)
				if #vdata.enemies>0 then
					--есть вражина - воюем нах!
					amk.oau_reason="cn offline_alife chp9 "..victim_name
					on_enemies_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.monsters>0 then
					--есть монстрятина - видели, слышали, убили, сдохли...
					amk.oau_reason="cn offline_alife chp10 "..victim_name
					on_monsters_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.corpses.stalkers>0 then
					--есть труп сталкера
					amk.oau_reason="cn offline_alife chp11 "..victim_name
					on_npc_corpses_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.corpses.monsters>0 then
					--есть труп монстра
					amk.oau_reason="cn offline_alife chp12 "..victim_name
					on_monster_corpses_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.weapons.seen>0 then
					--есть бесхозное оружие
					amk.oau_reason="cn offline_alife chp13 "..victim_name
					on_weapons_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.artefacts>0 then
					--есть арты
					amk.oau_reason="cn offline_alife chp14 "..victim_name
					on_artifacts_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif #vdata.inv_boxes>0 then
					--есть контейнеры. Надо обыскать.
					amk.oau_reason="cn offline_alife chp18 "..victim_name
					on_inv_boxes_found(victim, vdata)
					break	--прерываем цикл - событие отработано
				elseif items[victim.id] and #items[victim.id] > 0 then
					--попробуем продать всякого
					amk.oau_reason="cn offline_alife chp15 "..victim_name
					process_trade(victim)
					-- amk.mylog("Offline: trade done")
					break
				else
					--amk.mylog("__")
				end
			end
		end
	end
	amk.oau_reason="cn offline_alife end"
end

--собираем инфу о неписе
function collect_info(victim,map)
	local vdata = {}
	vdata.rank = victim:rank() --ранг
	vdata.health = victim:health()  --хелсы
	vdata.community = victim:community()  --группировка

	--пытаемся определить пушку
	local wp = #off_npcs[map].weapons
	--условная огневая мощь
	vdata.fire_power = 0

	vdata.weapons={own={},seen={}}
	-- если есть пушки в карманах, выбираем лучшую (по условной мощности)
	if wp>0 then
		for w=1,wp do
			if off_npcs[map].weapons[w] then
				local www = AI:object(off_npcs[map].weapons[w].id)
				if www and www:name()==off_npcs[map].weapons[w].name then
					if www.parent_id == victim.id then
						table.insert(vdata.weapons.own, {id = www.id, name = www:name()})
						local fp = get_weapon_firepower(www)
						if vdata.fire_power<fp then vdata.fire_power=fp end
					elseif www:can_switch_online()
						and victim.position:distance_to(www.position)<look_radius
						and sobj_is_far(www, to_actor)
					then
						local p_id = www.parent_id
						local p_obj = p_id and AI:object(p_id)
						-- Безхозное оружие
						if p_id==nil or p_id==65535
							-- В нычках без замков можно что-нибудь стырить
							or ( p_obj and p_obj:clsid() == clsid.inventory_box
							and ( not box_is_protected(p_obj) )
							and victim.position:distance_to(p_obj.position) < look_radius_box )
						then
							table.insert(vdata.weapons.seen, {id = www.id, name = www:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем списки друзей и врагов в зоне "видимости"
	-- Для тех, у кого смарт в фильтрах - не собираем врагов
	-- Для остальных - не учитываем врагов из смартов
	local npc_peaceful = npc_smart_is_peaceful(victim)
	
	vdata.friends={}
	vdata.enemies={}
	vdata.corpses={monsters={},stalkers={}}
	if #off_npcs[map].stalkers>0 then
		for a=1,#off_npcs[map].stalkers do
			if off_npcs[map].stalkers[a] then
				local opponent = AI:object(off_npcs[map].stalkers[a].id)
				if opponent
					and opponent.id~=victim.id
					and opponent.health
					and opponent.can_switch_online
					and opponent:can_switch_online()
					and opponent:name() == off_npcs[map].stalkers[a].name
				then
					if victim.position:distance_to(opponent.position)<look_radius then
						if opponent:health()>0 then
							local rel = relation_registry.get_goodwill(victim.id, opponent.id)
							if rel>=rel_friend then
								table.insert(vdata.friends, {id = opponent.id, name = opponent:name()})
							elseif rel<=rel_enemy then
								if npc_peaceful == false and npc_smart_is_peaceful(opponent) == false then
									table.insert(vdata.enemies, {id = opponent.id, name = opponent:name()})
								end
							end
						else
							if (sobj_is_far(opponent, to_actor)) then
								table.insert(vdata.corpses.stalkers, {id = opponent.id, name = opponent:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список монстряков в зоне "видимости"
	vdata.monsters={}
	if off_npcs[map].monsters then
		if #off_npcs[map].monsters>0 then
			for a=1,#off_npcs[map].monsters do
				if off_npcs[map].monsters[a] then
					local monster = AI:object(off_npcs[map].monsters[a].id)
					if monster
						and monster.health
						and monster.can_switch_online
						and monster:can_switch_online()
						and monster:name() == off_npcs[map].monsters[a].name
						and victim.position:distance_to(monster.position)<look_radius
					then
						if monster:health()>0 then
							table.insert(vdata.monsters, {id = monster.id, name = monster:name()})
						else
							if (sobj_is_far(monster, to_actor)) then
								table.insert(vdata.corpses.monsters, {id = monster.id, name = monster:name()})
							end
						end
					end
				end
			end
		end
	end
	
	--составляем список артов в зоне "видимости"
	vdata.artefacts={}
	if off_npcs[map].artefacts then
		if #off_npcs[map].artefacts>0 then
			for a=1,#off_npcs[map].artefacts do
				if off_npcs[map].artefacts[a] then
					local artefact = AI:object(off_npcs[map].artefacts[a].id)
					if (artefact
						and artefact.can_switch_online
						and artefact:can_switch_online()
						and artefact:name() == off_npcs[map].artefacts[a].name
						and victim.position:distance_to(artefact.position)<look_radius
						and sobj_is_far(artefact, to_actor))
					then
						local parent_id = artefact.parent_id
						local parent_obj = (parent_id and parent_id~=65535) and AI:object(parent_id)
						if (not parent_obj)
								or ( ( parent_obj:clsid() == clsid.inventory_box
								and not box_is_protected(parent_obj) )
								or IsAnomaly(parent_obj) )
						then
							table.insert(vdata.artefacts, {id = artefact.id, name = artefact:name()})
						end
					end
				end
			end
		end
	end
	
	--составляем список контейнеров в зоне "видимости"
	vdata.inv_boxes={}
	if off_npcs[map].inv_boxes then
		if #off_npcs[map].inv_boxes>0 then
			for a=1,#off_npcs[map].inv_boxes do
				if off_npcs[map].inv_boxes[a] then
					local inv_box = AI:object(off_npcs[map].inv_boxes[a].id)
					if ( inv_box
						and inv_box.can_switch_online
						and inv_box:can_switch_online()
						and inv_box:name() == off_npcs[map].inv_boxes[a].name
						and victim.position:distance_to(inv_box.position)<=look_radius_box
						and sobj_is_far(inv_box, to_actor) )
					then
						local zdist = victim.position:distance_to(inv_box.position)/100
						if math_random() > zdist then
							if inv_box.parent_id==nil or inv_box.parent_id==65535 then
								table.insert(vdata.inv_boxes, {id = inv_box.id, name = inv_box:name()})
							end
						end
					end
				end
			end
		end
	end

	return vdata
end

-- Вокруг враги! Что же делать..
function on_enemies_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found enemy ("..#vdata.enemies..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	-- Собираем weapons
	-- Учитываем rank, weapon, distance...
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			if v_obj then
				obj = AI:object(v_obj.id)
				if (obj and obj:name()==v_obj.name) then
					wpn = get_npc_weapon(obj)
					rank = obj:rank()
					health = obj:health()
					firepower = get_weapon_firepower(wpn)
					player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
					table.insert(team_A, player)
				end
			end
		end
	end
	for i=1, #vdata.enemies do
		v_obj = vdata.enemies[i]
		obj = AI:object(v_obj.id)
		if (obj and obj:name() == v_obj.name) then
			wpn = get_npc_weapon(obj)
			if (wpn == nil) then
				wpn = list_npc_items(obj)
			end
			rank = obj:rank()
			health = obj:health()
			firepower = get_weapon_firepower(wpn)
			player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
			table.insert(team_B, player)
		end
	end
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower / (dist / dist_coeff))
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender 
			local attack_info 
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance			
			if (#team_B > index) then index = #team_B end
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					--amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					-- master to novice - 30% max
					-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
						if (attack_info.fp >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp)
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if bit_and(defender.flags, 2) == 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
								-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
								local itA, v_itA
								local l_objA
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = AI:object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)
											else
												if(itA) then
													local mm = itA.parent_id
													if mm == nil then mm = "nil" end
													-- amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itA:name().." parent_id="..mm)
												end
											end	
										end
									end
								end
								process_trade(attacker.player)
							end
						end
						--amk.mylog(attacker.player:name().." [team_A] попал в "..defender.player:name().." [team_B] ("..defender.health..")")
					else
						--amk.mylog(attacker.player:name().." [team_A] промазал в "..defender.player:name().." [team_B] ("..defender.health..")")
					end
				end
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						--amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Попал или нет? Зависит от: расстояния, рангов
						-- master to novice - 30% max
						-- 100 метров - 33% 10 метров - 100% 1 метр - 115% Каждый метр - минус 1.5% попасть.
						rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
						distance_hit_chance = 100 - math_floor((attack_info.distance) / 1.5)					
						hit_chance = distance_hit_chance + rank_hit_chance
						if math_random() * 100 < hit_chance then
							-- Попал таки, гад. Посмотрим, как сильно.
							if attack_info.fp >= base_fp then
								-- Все, убил.
								defender.health = 0
							else
								defender.health = defender.health - (attack_info.fp / base_fp)
								if (defender.health < 0 ) then defender.health = 0 end
							end
							if (defender.health <= 0) then
								if bit_and(defender.flags, 2) == 2 then
									defender.health = health_wound
								else								
									-- Если сталкер - дадим опыт.
									if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
										local m_comm  = attacker.player:community()
										if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
											-- Будет теперь опытным.
											local coeff = 1
											if (defender.rank < attacker.rank) then coeff = 0.5 end
											if (defender.rank > attacker.rank) then coeff = 2 end
											attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))							
										end
									end
									-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
									news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
									-- Заберем вещички с трупа
									local itB, v_itB
									local l_objB
									if (items[defender.player.id] and #items[defender.player.id] > 0) then
										-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
										for a=1,#items[defender.player.id] do
											v_itB = items[defender.player.id][a]
											if (v_itB) then
												itB = AI:object(v_itB.id)
												if (itB and itB:name() == v_itB.name and itB.parent_id == defender.player.id) then
													l_objB = pick_item(attacker.player, itB)
												else
													if(itB) then
														local mm = itB.parent_id
														if mm == nil then mm = "nil" end
														-- amk.mylog("В трупе "..defender.player:name().." странная вещичка - "..itB:name().." parent_id="..mm)													
													end
												end
											end
										end
									end
									process_trade(attacker.player)
								end
							end
							--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
						else
							--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
		-- Почистим таблицы от трупов
		local vv
		for kk = #team_A, 1, -1 do
			vv = team_A[kk]
			if (vv.health <=0) then
				-- amk.mylog("Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
			end
		end
		for kk = #team_B, 1, -1 do
			vv = team_B[kk]
			if (vv.health <=0) then
				-- amk.mylog("Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
			end
		end		
	end
	-- amk.mylog("Бой закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- Вокруг монстры! Что же делать..
function on_monsters_found(victim, vdata)
	local rsn = "on_monsters_found ["..victim:name().."] "
	amk.oau_reason=rsn.."begin"
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = object_level_name(victim)
		local s = "found monsters ("..#vdata.monsters..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
		--amk.add_spot_on_map(victim.id,"red_location", s)
	end
	-- Собираем комманды.
	local obj, v_obj
	local team_A = {}
	local team_B = {}
	local wpn = get_npc_weapon(victim)
	local rank = victim:rank()
	local health = victim:health()
	local firepower = get_weapon_firepower(wpn)
	local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
	table.insert(team_A, player)
	amk.oau_reason=rsn.."chp1"
	if (vdata.friends and #vdata.friends > 0) then
		for i=1, #vdata.friends do
			v_obj = vdata.friends[i]
			obj = AI:object(v_obj.id)
			if (obj and obj:name()==v_obj.name) then
				wpn = get_npc_weapon(obj)
				rank = obj:rank()
				health = obj:health()
				firepower = get_weapon_firepower(wpn)
				player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
				table.insert(team_A, player)
			end
		end
	end
	amk.oau_reason=rsn.."chp2"
	local params
	for i=1, #vdata.monsters do
	amk.oau_reason=rsn.."chp2.1"
		v_obj = vdata.monsters[i]
		obj = AI:object(v_obj.id)
	amk.oau_reason=rsn.."chp2.2"
		if (obj and obj:name() == v_obj.name) then
	amk.oau_reason=rsn.."chp2.3 "..v_obj.name
			params = get_monster_params(obj)
	amk.oau_reason=rsn.."chp2.4"
			if (params) then
	amk.oau_reason=rsn.."chp2.5"
				rank = obj:rank()
	amk.oau_reason=rsn.."chp2.6"
				health = obj:health()
	amk.oau_reason=rsn.."chp2.7"
				firepower = params.attack * base_fp
	amk.oau_reason=rsn.."chp2.8"
				player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id) }
	amk.oau_reason=rsn.."chp2.9"
				table.insert(team_B, player)
	amk.oau_reason=rsn.."chp2.10"
			else
	amk.oau_reason=rsn.."chp2.11"
				-- amk.mylog("get_monster_params returns nil for "..obj:name())
	amk.oau_reason=rsn.."chp2.12"
		end
	end
	end
	amk.oau_reason=rsn.."chp3"
	local distances = {}
	for a=1, #team_A do
		local from = team_A[a].player
		distances[from.id] = {}
		for b=1, #team_B do
			local to = team_B[b].player
			distances[to.id] = {}
			if (from and to and from.id and to.id) then
				local dist = math_floor(from.position:distance_to(to.position))
				local fp_A = math_floor(team_A[a].firepower / (dist / dist_coeff))
				local fp_B = math_floor(team_B[b].firepower)
				local item = {distance = dist, fpA = fp_A, fpB = fp_B}
				distances[from.id][to.id] = {distance = dist, fp = fp_A}
				distances[to.id][from.id] = {distance = dist, fp = fp_B}
			end
		end
	end
	amk.oau_reason=rsn.."chp4"
	-- Берем тех, у кого самый высокий rank и мин. distance
	table_sort(team_A, function(a,b) return a.rank > b.rank end)
	table_sort(team_B, function(a,b) return a.rank > b.rank end)
	-- 10 раундов
	local size_A = #team_A
	local size_B = #team_B
	local died_A = 0
	local died_B = 0
	amk.oau_reason=rsn.."chp5"
	for i=1, max_rounds do
		if (#team_A >0 and #team_B > 0) then
			local index = #team_A
			local attacker
			local defender
			local attack_info
			local rank_hit_chance
			local distance_hit_chance
			local hit_chance
			if (#team_B > index) then index = #team_B end
	amk.oau_reason=rsn.."chp5.1 : "..i
			for j = 1, index do
				attacker = team_A[j]
				defender = team_B[math_random(#team_B)]
	amk.oau_reason=rsn.."chp5.2 : "..i..":"..j
				if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
					-- amk.mylog(attacker.player:name().." [team_A] нападает на "..defender.player:name().." [team_B] ("..defender.health..")")
					attack_info = distances[attacker.player.id][defender.player.id]
					-- Попал или нет? Зависит от: расстояния, рангов
					rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
					local dii = math_floor(attack_info.distance - defender.speed * i * 5)
					if (dii <=8) then dii = 45 end -- Вблизи еще и фиг попадешь...
					distance_hit_chance = 100 - math_floor(dii / 1.5)					
					hit_chance = distance_hit_chance + rank_hit_chance
					if ((math_random() * 100) < hit_chance) then
						-- Попал таки, гад. Посмотрим, как сильно.
	amk.oau_reason=rsn.."chp5.3 : "..i..":"..j
						if ( math_floor(attack_info.fp * defender.immunity) >= base_fp) then
							-- Все, убил.
							defender.health = 0
						else
							defender.health = defender.health - (attack_info.fp / base_fp) * defender.immunity
							if (defender.health < 0 ) then defender.health = 0 end							
						end
						if (defender.health <= 0) then
							if bit_and(defender.flags, 2) == 2 then
								defender.health = health_wound
							else
								-- Если сталкер - дадим опыт.
								if attacker.player and IAmAStalker[attacker.player:clsid()] and attacker.player.community then
									local m_comm  = attacker.player:community()
									if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
										-- Будет теперь опытным.
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										attacker.player:set_rank(attacker.player:rank() + math_floor(rate_kill_base * coeff))
									end
								end
  amk.oau_reason=rsn.."chp5.4.0"
								-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", "..attacker.weapon:name())
								news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
								-- Заберем вещички с трупа
  amk.oau_reason=rsn.."chp5.4 : "..i..":"..j
								if (items[defender.player.id] and #items[defender.player.id] > 0) then
									local itA, v_itA
									local l_objA
									-- amk.mylog("В трупе "..defender.player:name().." "..#items[defender.player.id].." вещичек.")
									amk.oau_reason=rsn.."chp5.4 : pick_items"
									for a=1,#items[defender.player.id] do
										v_itA = items[defender.player.id][a]
										if (v_itA) then
											itA = AI:object(v_itA.id)
											if (itA and itA:name()==v_itA.name and itA.parent_id == defender.player.id) then
												l_objA = pick_item(attacker.player, itA)									
											end			
										end
									end
								end
								process_trade(attacker.player)
							end
						end
					end
				end
  amk.oau_reason=rsn.."chp5.5 : "..i..":"..j
				-- team_B - защищается
				if (team_B[j] ~= nil) then
					attacker = team_B[j]
					defender = team_A[math_random(#team_A)]
					if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
						-- amk.mylog(attacker.player:name().." [team_B] нападает на "..defender.player:name().." [team_A] ("..defender.health..")")
						attack_info = distances[attacker.player.id][defender.player.id]
						-- Для начала неплохо бы узнать, добежал ли монстрик до дистанции атаки.
						if (attack_info.distance - attacker.speed * i * 5 < attacker.attack_dist) then
							rank_hit_chance = math_floor((attacker.rank - defender.rank) / 50)
							distance_hit_chance = 100
							hit_chance = distance_hit_chance + rank_hit_chance
							if math_random() * 100 < hit_chance then
								-- Попал таки, гад. Посмотрим, как сильно.
								if attack_info.fp >= base_fp then
									-- Все, убил.
									defender.health = 0
								else
									defender.health = defender.health - (attack_info.fp / base_fp)
									if (defender.health < 0 ) then defender.health = 0 end
								end
								if (defender.health == 0) then
									if bit_and(defender.flags, 2) == 2 then
										defender.health = health_wound
									else
										local coeff = 1
										if (defender.rank < attacker.rank) then coeff = 0.5 end
										if (defender.rank > attacker.rank) then coeff = 2 end
										-- amk.mylog("on_offline_death - "..defender.player:name()..", "..attacker.player:name()..", nil")
  amk.oau_reason=rsn.."chp5.5.1 : "..i..":"..j
										news_main.on_offline_death(defender.player, attacker.player, nil)
  amk.oau_reason=rsn.."chp5.5.2 : "..i..":"..j
										-- Забитрать вещички с трупа не будем. Хотя, может некоторые клептоманы...
										-- А вот труп грохнуть... Надо подумать :)
									end
								end
								--amk.mylog(attacker.player:name().." [team_B] попал в "..defender.player:name().." [team_A] ("..defender.health..")")
							else
								--amk.mylog(attacker.player:name().." [team_B] промазал в "..defender.player:name().." [team_A] ("..defender.health..")")
							end
						else
							-- amk.mylog(attacker.player:name().." [team_B] еще не добежал "..(attack_info.distance - attacker.speed * i * 5).." метров до "..defender.player:name().." [team_A] ("..defender.health..")")
						end
					end
				end
			end
		else
			-- Теперь и событие можно сформировать для новостей
			break
		end
 amk.oau_reason=rsn.."chp5.6 : "..i
		-- Почистим таблицы от трупов
		local vv
		for kk = #team_A, 1, -1 do
			vv = team_A[kk]
			if (vv.health <=0) then
				-- amk.mylog("Участник команды А погиб. "..vv.player:name())			
				set_npc_health(vv.player, 0)
				table_remove(team_A, kk)
				died_A = died_A + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды А ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_A, kk)
			end
		end
 amk.oau_reason=rsn.."chp5.7 : "..i
		for kk = #team_B, 1, -1 do
			vv = team_B[kk]
			if (vv.health <=0) then
				-- amk.mylog("Участник команды B погиб. "..vv.player:name())
				set_npc_health(vv.player, 0)
				table_remove(team_B, kk)
				died_B = died_B + 1
			elseif (vv.health <= health_wound and vv.health > 0) then
				-- amk.mylog("Участник команды B ранен. "..vv.player:name())
				set_npc_health(vv.player, health_wound_set)
				news_main.on_offline_wound(vv.player)
				table_remove(team_B, kk)
			end
		end		
	end	
  amk.oau_reason=rsn.."end"
	-- amk.mylog("Бой с монстрами закончен. Команда А - было "..size_A.." осталось "..size_A-died_A..". Команда Б - было "..size_B.." осталось "..size_B-died_B..".")
end

-- О, трупик. Щас шмонать будем.
function on_npc_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.stalkers == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found stalker's corpse ("..#vdata.corpses.stalkers..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.stalkers do
		v_obj = vdata.corpses.stalkers[i]
		local corpse = AI:object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = AI:object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, трупик монстра. Будем шмонать?
function on_monster_corpses_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (vdata.corpses == nil) then return end
	if (vdata.corpses.monsters == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found monster's corpse ("..#vdata.corpses.monsters..") for "..victim.id.." ["..victim:community().."] on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local id
	local v_id = victim.id
	for i=1, #vdata.corpses.monsters do
		v_obj = vdata.corpses.monsters[i]
		local corpse = AI:object(v_obj.id)
		if (corpse and corpse:name() == v_obj.name) then
			news_main.on_offline_corpse_found(victim, corpse)		
			id = corpse.id
			if (id and items[id]) then
				for a=1, #items[id] do
					local v_itA = items[id][a]
					if (v_itA) then
						local itA = AI:object(v_itA.id)
						if (itA and itA:name() == v_itA.name and itA.parent_id == id) then
							local l_objA = pick_item(victim, itA)
						end			
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- Хорошая пушка - не помешает.
function on_weapons_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	if (amk.is_debug == true) then
		local lname = news_main.get_object_levelname(victim)
		local s = "found weapons ("..#vdata.weapons.seen..") for "..victim.id.." on map "..lname
		amk.mylog(s)
	end
	local obj, v_obj
	local object
	local v_id = victim.id
	for i=1, #vdata.weapons.seen do
		v_obj = vdata.weapons.seen[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
			end
		end
	end
	process_trade(victim)
end

-- Моя прелесссть
function on_artifacts_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, #vdata.artefacts do
		v_obj = vdata.artefacts[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				obj = pick_item(victim, object)
				if (obj) then
					if (b_stalker == true) then
						victim:set_rank(victim:rank() + rate_art_found)
					end
				end
			end
		end
	end
	process_trade(victim)
end

-- О, нычка - это гуд.
-- Idler ++
-- проверим, а сможет ли непись долезть до  тайника.
-- если есть аномалии в радиусе 20м, меньше шансов или если тайник высоко, тоже не факт что долезет.
function inv_box_is_avail(victim, box)
	if (victim == nil or box == nil or box.id == 0) then return false end

	-- отсекаем сюжетные тайники
	if box_is_protected(box) then return false end

	local n_rnd
	if victim.position and box.position then 
		n_rnd = math_random(2, 5)
		--get_console():execute("load ~~~ Непись пробует добраться до тайника " .. tostring(box.id) .. ". npc.y = " .. tostring(victim.position.y) .. " box.y = " .. tostring(box.position.y) .. " rnd = " .. tostring(n_rnd))
		if math_abs(box.position.y - victim.position.y) > n_rnd then
			--get_console():execute("load ~~~ Не добрался. Высоко")
			return false
		end 
	end

	local anom_list=amk_anoms.get_anomaly_list_for_pos(box.position,20) 
	local n_anoms = #anom_list
	n_rnd = math_random(1, 100)
	--get_console():execute("load ~~~ Непись пробует добраться до тайника " .. tostring(box.id) .. ". Рядом " .. tostring(n_anoms) .. " аномалий. " .. tostring(n_rnd))
	if n_rnd < n_anoms * 20 then -- смотрим вероятность. Чем больше аномалий, тем меньше шансов. При 5 - точно до ящика не доберется
		--get_console():execute("load ~~~ Не решился лезть в аномалии.")
		return false
	end
	
	
	--get_console():execute("load ~~~ Долез настырный")
	return true
end
-- Idler --

function on_inv_boxes_found(victim, vdata)
	if (victim == nil or vdata == nil) then return end
	local obj, v_obj
	local object
	local v_id = victim.id
	local b_stalker = false
	-- Если сталкер - дадим опыт.
	if victim and IAmAStalker[victim:clsid()] and victim.community then
		local m_comm  = victim:community()
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom") then
			b_stalker = true
		end
	end
	for i=1, #vdata.inv_boxes do
		v_obj = vdata.inv_boxes[i]
		if (v_obj) then
			object = AI:object(v_obj.id)
			if (object and object:name() == v_obj.name) then
				if inv_box_is_avail(victim, object) then  -- Idler ++-- если нычка доступна - можно шмонать
					if items[v_obj.id] and #items[v_obj.id]>0 then
						for a=1,#items[v_obj.id] do
							local v_itA = items[v_obj.id][a]
							if (v_itA) then
								local itA = AI:object(v_itA.id)
								if (itA and itA:name()==v_itA.name and itA.parent_id == v_obj.id) then
									--news_main.trace("on_inv_boxes_found - found "..itA:section_name().." in "..object:name())
									-- Решим, подбираем или нет?
									if is_valuable(itA) then
										local l_objA = pick_item(victim, itA)
									end
								else
									if(itA) then
										local mm = itA.parent_id
										if mm == nil then mm = "nil" end
										-- amk.mylog("В контейнере "..object:name().." странная вещичка - "..itA:name().." parent_id="..mm)
									end											
								end			
							end
						end
					else
						invbox_new.offline_npc_found_box(victim, object)
					end
				end
			end
		end
		if (b_stalker == true) then
			victim:set_rank(victim:rank() + rate_art_found)
		end
	end
	process_trade(victim)
end

function pick_fake_item(npc, sect)
	local new = AI:create(sect, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
	if new and new.parent_id then
		insert_npc_item(new)
	end
	return new
end

function pick_item(npc, obj)
	local new = nil
	if (npc and obj and Actor and obj.id ~= Actor:id()) then
		local section = obj:section_name()
		if protected_items.is_grab_body_item_keep(section) then
			return nil
		end
		new = AI:create(section, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id)
		if (new) then
			if (obj.parent_id and items[obj.parent_id] and #items[obj.parent_id]>0) then
				for z=1, #items[obj.parent_id] do
					if (items[obj.parent_id][z] and items[obj.parent_id][z].id == obj.id) then
						gps_habar.remove_item(obj.parent_id, obj) -- Idler++-- корректируем хабар в помеченных тайниках
						table_remove(items[obj.parent_id], z)
						if section == "zamok" then
							zamok.remove_offline(obj.parent_id)
						end
						break
					end
				end
			end
			del_obj_by_id(obj.id)

			if (new.parent_id) then
				insert_npc_item(new)
				gps_habar.insert_item(new.parent_id, new) -- Idler++-- корректируем хабар в помеченных тайниках
			end
		end
	end
	return new
end

function get_npc_weapon(npc)
	local obj = nil
	local fp = 0
	if (npc) then
		if items ~= nil and npc.id ~= nil and items[npc.id] ~= nil then -- заплатка от вылета //[fR4g]
			for k,v in ipairs(items[npc.id]) do --- вылет был тут
				local wpn = AI:object(v.id)
				if wpn and IAmAWeapon[wpn:clsid()] and wpn:name() == v.name and wpn.parent_id == npc.id then
					local sect = wpn:section_name()
					local cur_fp = 0				
					local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
					local params = rx_wmgr.read_wpn_params(sect)
					if modes.mode1 == "1" then
						cur_fp = params.cst + modes.addcost
					elseif modes.mode1 == "2" then
						local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
						cur_fp = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
					elseif modes.mode1 == "3" then
						cur_fp = rx_wmgr.wm_modes.priors[modes.priors][sect] or 0
					end
					if cur_fp > fp then
						fp = cur_fp
						obj = wpn
					end			
				end
			end
		end
	end
	return obj
end

function get_weapon_firepower(wpn)
	if wpn and IAmAWeapon[wpn:clsid()] then
		local sect = wpn:section_name()
		if wpn_fp[sect] then
			return wpn_fp[sect]
		else
			if not table.find(xrs_grenade.gr_types, sect) then
				local priority = sys_ini:r_u32_ex(sect, "ef_weapon_type", 1)
				local priority2 = sys_ini:r_u32_ex(sect, "ef_main_weapon_type", 0)
				local fd = sys_ini:r_float_ex(sect, "fire_distance", 1)
				local bs = sys_ini:r_float_ex(sect, "bullet_speed", 1)
				local rpm = sys_ini:r_float_ex(sect, "rpm", 1)
				if priority>1 then
					if priority2>0 then
						priority = priority + priority2
					end
				end
				local fp = priority*1000 + math.sqrt(fd*bs*rpm)
				wpn_fp[sect] = fp
				
				return fp
			end
		end
	end
	return 0
end

function get_weapon_cost(weapon)
	if (weapon and IAmAWeapon[weapon:clsid()]) then
		return sys_ini:r_float_ex(weapon:section_name(), "cost", 0)
	end
	return 0
end

function get_item_cost(item)
	if item then
		return sys_ini:r_float_ex(item:section_name(), "cost", 0)
	end
	return 0
end

function set_npc_health(obj, health)
	if (obj and health >=0 and health <=2) then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			netpk:modify( obj, { health = health, upd = { health = health } } )
		end
		if health == 0 then
			on_death(obj.id)
		end
	end
end

function list_npc_items(obj)
	if (obj) then
		log1("! amk_offline_alife: can't find weapon for "..obj:name()..":")
		local it
		for a=1,65534 do
			it = AI:object(a)
			if (it and it.parent_id == obj.id) then
				log1("~ -> "..it:name().." "..it:section_name())
				if (IAmAWeapon[it:clsid()]) then
					insert_npc_item(it)
					return it
				end
			end			
		end
	end
end

function dbg_show_team(team)
	if(team) then
		for k, player in pairs(team) do
			if (player.weapon) then
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon="..player.weapon:name().." firepower="..player.firepower)
			else
				mylog("Team: "..player.player:name().." health="..player.health.." rank="..player.rank.." community="..player.player:community().." weapon=none firepower="..player.firepower)
			end
		end
	end
end

--[[
	Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.	
	Отсортировали оружие по firepower (можем еще ef_weapon_type добавить.)
	Оставили себе то, для которого есть патроны. (а) - wpn..ammo_class + item_dependence
	Оставили одно, которое лучше (а), но патронов нет (б) (%)
	Одно, которое лучше (а), но хуже (б) - в новости на продажу
	Остальное на продажу
	Патроны оставили только те, что подходят к (а), остальные на продажу
	Для вояк - только родной калаш надо бы... Не продавать вобще?
	Оставляем не более 2 аптечек и бинтов, антирада
	Оставляем 1-2 гранаты (%)
	Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
	Еда, водка - не более 1-2 шт (%)	
	Броники наверное продаем...
	Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
]]
function process_trade(npc)
	-- Имеет смысл проверять на наличие trade в секции [logic]...
	amk.oau_reason="on offline_alife: process_trade chp1"
	if npc and IAmAStalker[npc:clsid()] and npc:alive()
		and npc.m_story_id and npc.m_story_id == 4294967296
		and items[npc.id] and #(items[npc.id])>0
		and not protected_items.is_no_offline_alife_npc(npc)
	then
		local rsn = "on offline_alife: process_trade "..npc:name()
	--	log("# [amk_offline_alife.process_trade] %s", npc:name())
		amk.oau_reason=rsn.." chp2"
		local item_list = {}
		local sell_list = {}
		local m_comm = npc:community()
		local b_stalker = false		
		if (m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom" or m_comm == "nebo" or m_comm == "green") then
			if (npc.name and npc:name() ~= "agr_ratcatcher") then
				b_stalker = true
			end
		elseif m_comm == "zombied" then
			return
		end
			
		amk.oau_reason=rsn.." chp3"
		--Фильтруем квестовые items - no_sell_table
		local nid = npc.id
		local npc_items = items[nid]
		local obj, sect
		local t_remove = {}
		for ok,ov in ipairs(npc_items) do
			obj = AI:object(ov.id)
			if obj and obj.parent_id and obj.parent_id == nid then
				if obj and obj:name()==ov.name then
					sect = obj:section_name()
					if ( not protected_items.actor_items_keep(sect) )
						and no_sell_table[sect] == nil
					then
						table.insert(item_list, obj)
					end
				end
			else
				table.insert(t_remove, ok)
			end
		end
		amk.oau_reason=rsn.." chp4"
		if #t_remove>0 then
		--	table.print(t_remove)
			for i = #t_remove, 1, -1 do
				table_remove(npc_items, t_remove[i])
			end
		end
	--	log1("item_list")
	--	table.print(item_list)
		amk.oau_reason=rsn.." chp5"
		if #item_list > 0 then
			table_sort(item_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)		
			-- Выберем, что за оружие оставит себе NPC.
			local cnt_medkit = 0
			local cnt_antirad = 0
			local cnt_bandage = 0
			local cnt_grenade = 0
			local cnt_food = 0
			local cnt_drink = 0
			local cnt_torch = 0
			local cnt_pda = 0
			local cnt_radio = 0
			local cnt_guitar = 0
			local cnt_harmonica = 0
			local cnt_binocular = 0
			local cnt_knife = 0
			local cnt_arts = 0
			local cnt_detector = 0
			local cnt_addons = 0
			local cnt_mparts = 0
			
			amk.oau_reason=rsn.." chp6"
			local weapons = {}
			local ammoss = {}
			for k,v in ipairs(item_list) do			
				local sect = v:section_name()
				local cls = v:clsid()
				if IAmAWeapon[cls] and not (table.find(xrs_grenade.gr_types, sect) or sect == "wpn_knife") then
					local ac = getIniValueString(sect, "ammo_class", "", nil)
					if ac and ac ~= "" then
						table.insert(weapons, { obj = v, ammo = string.explode(ac, ",", true) } )
					else
						table.insert(weapons, {obj = v, ammo = nil})
					end
				elseif isAmmo(nil, cls) then
					if ammoss[sect] == nil then 
						ammoss[sect] = 1
					else
						ammoss[sect] = ammoss[sect] + 1
						if ammoss[sect] > 1 then
							table.insert(sell_list, v)
						end
					end
				elseif string_find(sect, "^af_") then
					-- 3 самых хороших арта оставили себе (+здоровье), остальные на продажу (фильтруем булыжник)				
					if sect ~= "af_buliz" then
						cnt_arts = cnt_arts + 1
						if cnt_arts > 3 then
							table.insert(sell_list, v)
						end	
					else	-- булыжники на продажу без фильтра
						table.insert(sell_list, v)
					end		
				elseif sect == "device_torch" then
					cnt_torch = cnt_torch + 1
					if cnt_torch > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "device_pda" then
					cnt_pda = cnt_pda + 1
					if cnt_pda > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "hand_radio" then
					cnt_radio = cnt_radio + 1
					if cnt_radio > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "harmonica_a" then
					cnt_harmonica = cnt_harmonica + 1
					if cnt_harmonica > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "guitar_a" then
					cnt_guitar = cnt_guitar + 1
					if cnt_guitar > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "binocular_a" or sect == "wpn_binoc" then
					cnt_binocular = cnt_binocular + 1
					if cnt_binocular > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "wpn_knife" then
					cnt_knife = cnt_knife + 1
					if cnt_knife > 1 then
						table.insert(sell_list, v)
					end
				elseif sect == "medkit" or sect == "medkit_army" or sect == "medkit_scientic" then
					cnt_medkit = cnt_medkit + 1
					if cnt_medkit > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "antirad" then
					cnt_antirad = cnt_antirad + 1
					if cnt_antirad > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "bandage" then
					cnt_bandage = cnt_bandage + 1
					if cnt_bandage > 3 then
						table.insert(sell_list, v)
					end
				elseif table.find(xrs_grenade.gr_types, sect) then
					cnt_grenade = cnt_grenade + 1
					if cnt_grenade > 2 then
						table.insert(sell_list, v)
					end
				elseif sect == "bread_a" or sect =="bread" or sect == "kolbasa" or sect == "kolbasa_a" or sect == "conserva" then
					cnt_food = cnt_food + 1
					if cnt_food > 4 then
						table.insert(sell_list, v)
					end
				elseif sect == "vodka_a" or sect =="vodka" or sect == "energy_drink" then
					cnt_drink = cnt_drink + 1
					if cnt_drink > 3 then
						table.insert(sell_list, v)
					end
				elseif sect == "detector_simple" or sect =="detector_advances" or sect == "detector_elite" then
					cnt_detector = cnt_detector + 1
					if cnt_detector > 1 then
						table.insert(sell_list, v)
					end
				elseif rx_addons and rx_addons.item_is_addon(v, cls) then
					cnt_addons = cnt_addons + 1
					if cnt_addons > 2 then
						table.insert(sell_list, v)
					end
				elseif sys_ini:line_exist(sect, "monster_part") then
					cnt_mparts = cnt_mparts + 1
					if cnt_mparts > 2 then
						table.insert(sell_list, v)
					end
				else
					--news_main.trace("Process trade - unknown - "..sect.." "..v:name())
				end			
			end
		--	log("~ amk_offline_alife.process_trade '%s'", npc:name())

			amk.oau_reason=rsn.." chp6.1"
		--	log("\nweapons:")
		--	table.print(weapons)
			local modes = rx_wmgr.read_wm_modes(npc:community(),ranks.get_obj_rank_name(npc),npc:section_name())
			local weapons_types = {}
			for z,i in ipairs(modes.types) do
				weapons_types[i.t] = {}
			end
			for i,w in ipairs(weapons) do
				local sect = w.obj:section_name()				
				local params = rx_wmgr.read_wpn_params(sect)
				local prm = 0
				if modes.mode1 == "1" then
					prm = params.cst + modes.addcost
				elseif modes.mode1 == "2" then
					local kf = rx_wmgr.wm_modes.koeffs[modes.koeffs]
					prm = (params.dmg*kf.dmg)+(params.rpm*kf.rpm)+(params.dst*kf.dst)+((100/params.dsp)*kf.dsp)
				elseif modes.mode1 == "3" then
					prm = rx_wmgr.wm_modes.priors[modes.priors][sect] or 0
				end
				for k,v in ipairs(modes.types) do
					if v.t == params.typ then
						prm = prm + prm*v.p/100
						break
					end
				end
				if weapons_types[params.typ] then
					table.insert(weapons_types[params.typ],{obj = w.obj,ammo = w.ammo,prm = prm})
				end
			end
			amk.oau_reason=rsn.." chp6.2"
		--	log("\ncheck weapon types:")
		--	table.print(weapons_types)
			-- Так, теперь у нас отсортированны все пушки НПС. Найдем ту, для которой есть патроны...
			local wpn_cnt = 2	-- максимальное количество оружия, которое оставим нпс
		--	local npc_wpns = {}
			for k,v in pairs(weapons_types) do
				table_sort(v,function(a,b) return a.prm > b.prm end)
			--	log("sort types: %s", k)
			--	table.print(v)
				local b_best = false
				for i,w in ipairs(v) do
					-- Будем выбирать по одному лучшему стволу каждого типа (они в начале таблицы)
					if b_best == false and wpn_cnt > 0 then
						local b_ammo = false
						local vac = w.ammo
						if vac and #vac>0 then
							for kk, vv in ipairs(vac) do
								if ammoss[vv] and ammoss[vv] > 0 then -- Так, патроны есть.
									b_ammo = true
									break
								end
							end
						end
						--	log1("* best weapon: "..w.obj:name())
						-- Нет патронов, надо доспавнить
						if b_ammo == false and vac and vac[1] then
							local o = AI:create(vac[1], npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, nid)
							if o then
								table.insert(npc_items, {id = o.id, name = o:name()})
							--	log("* spawn ammo: %s", o:section_name())
							end
						end
						wpn_cnt = wpn_cnt - 1
						b_best = true
					--	table.insert(npc_wpns, w.obj)
					else
						table.insert(sell_list, w.obj)
					end
				end
			end

			-- Так, с оружием закончили...
			-- Все, что осталось - надо продать.
			-- 1 самое дорогое можно попробовать через новости...
			amk.oau_reason=rsn.." chp7"
			item_list = nil
			local money = 0
		--	log1("sell_list:")
		--	table.print(sell_list)
			if #sell_list>0 then
			--	log("~ amk_offline_alife: npc %s can trade", npc:name())
				table_sort(sell_list, function(a,b) return get_item_cost(a) > get_item_cost(b) end)
			--	table.print(sell_list)
			--	log("\n has weapons:")
			--	table.print(npc_wpns)
				local zz = sell_list[1]
				if zz and b_stalker == true and (get_item_cost(zz) >= sell_limit) then
					-- Продадим через новости.
				--	log("~ news_main.on_offline_trade: %s -> %s", npc:name(), zz:name())
					amk.oau_reason=rsn.." chp7.1"
					news_main.on_offline_trade(npc, zz)
					table_remove(sell_list, 1)
				end
			end
			amk.oau_reason=rsn.." chp7"
			for kk,vv in ipairs(sell_list) do
				local cost = get_item_cost(vv)
				if (cost > 0) then
					local coeff = math_random(30,50) / 100
					local price = math_floor(cost * coeff)
					money = money + price
					-- Почистим items
					if #npc_items>0 then
						for z=1, #npc_items do
							if npc_items[z].id == vv.id then
								gps_habar.remove_item(nid, npc_items[z]) -- Idler++-- корректируем хабар в помеченных тайниках
								table_remove(npc_items, z)
								break
							end
						end
					end
				--	log("* sell [%s]", vv:name())
					AI:release(vv, true)
				end
			end
			amk.oau_reason=rsn.." chp8"
			if (money > 0) then
				local tbl = netpk:get( npc, netpk.fState )
				tbl.money = tbl.money + money
				netpk:set( npc, tbl )
			--	log("- give money %d \n", money)
			end
		end
	end
end

-- Строим таблицы, если надо.
-- В них - макс. скорость, сила атаки, дистанция атаки.
-- Не забываем про иммунитеты.
-- Поучаем immunities_sect
-- В immunities_sect читаем fire_wound_immunity. Все повреждения множим на него.
function get_monster_params(obj)
 -- amk.oau_reason="get_monster_params chp1"
  local sect = obj:section_name()
	if (obj and IAmAMonster[obj:clsid()]) or (obj and obj.community and obj:community()=="zombied") then
 -- amk.oau_reason="get_monster_params chp2"
		if (monster_params and monster_params[sect]) then
 -- amk.oau_reason="get_monster_params chp3"
			return monster_params[sect]
		else
 -- amk.oau_reason="get_monster_params chp4"
			-- local speed 	= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxSpeed", obj, false, 5)
			local speed 	= sys_ini:r_float_ex(sect, "MaxSpeed", 5)
 -- amk.oau_reason="get_monster_params chp5"
			-- local dist 	= utils.cfg_get_number(sys_ini, obj:section_name(), "MaxAttackDist", obj, false, 3)
			local dist 		= sys_ini:r_float_ex(sect, "MaxAttackDist", 3)
 -- amk.oau_reason="get_monster_params chp6"
			-- local imm_sect = utils.cfg_get_string(sys_ini, obj:section_name(), "immunities_sect", obj, false, "", "")
			local imm_sect 	= sys_ini:r_string_ex(sect, "immunities_sect", "")
 -- amk.oau_reason="get_monster_params chp7"
			-- local immunity 	= utils.cfg_get_number(sys_ini, imm_sect, "fire_wound_immunity", obj, false, 1)
			local immunity 	= sys_ini:r_float_ex(imm_sect, "fire_wound_immunity", 1)
 -- amk.oau_reason="get_monster_params chp8"
			-- local att_sect 	= utils.cfg_get_string(sys_ini, obj:section_name(), "attack_params", obj, false, "", "")
			local att_sect 	= sys_ini:r_string_ex(sect, "attack_params", "")
 -- amk.oau_reason="get_monster_params chp9"
			local attack	= 0
 -- amk.oau_reason="get_monster_params chp10 "..tostring(att_sect)
			if (sys_ini:section_exist(att_sect)) then
 -- amk.oau_reason="get_monster_params chp11"
				local result, id, value = nil, nil, nil
				local max_attack = 0
 -- amk.oau_reason="get_monster_params chp12"
				for a=0, sys_ini:line_count(att_sect)-1 do
 -- amk.oau_reason="get_monster_params chp13"
					result, id, value = sys_ini:r_line(att_sect,a,"","")
 -- amk.oau_reason="get_monster_params chp14"
					if id~=nil and trim(id)~="" and trim(id)~=nil and value~=nil then
 -- amk.oau_reason="get_monster_params chp15"
						local m_value = string.explode(trim(value), ",", true)
 -- amk.oau_reason="get_monster_params chp16"
						if (m_value and #m_value>2) then
 -- amk.oau_reason="get_monster_params chp17"
							local v = tonumber(m_value[2])
 -- amk.oau_reason="get_monster_params chp18"
							if (v and v > max_attack) then					
 -- amk.oau_reason="get_monster_params chp19"
								max_attack = v
							end
						end
					end
				end
 -- amk.oau_reason="get_monster_params chp20"
				attack = max_attack
			end
      -- amk.mylog("speed for "..obj:section_name().." is "..tostring(speed))
			monster_params[sect] = {speed = speed, dist = dist, immunity = immunity, attack = attack}
			return monster_params[sect]			
		end
	else
		return nil
	end
end

function sobj_is_far(obj, distance)
	local result = true
	if (Actor and obj and distance and obj.position ) then
		-- на одном ли уровне?
		if obj.m_game_vertex_id and GGraph:valid_vertex_id(obj.m_game_vertex_id) then
			local map = object_level_name(obj)
			if (map and level.name() == map) then
				-- Достаточно ли далеко?
				if (obj.position:distance_to(Actor:position()) < distance) then
					result = false
				end
			end
	   end
   end
   return result
end

function box_is_protected(v)
	if v then
		-- проверяем по секции объекта
		local chk = v:section_name()
		-- отсекаем сюжетные тайники
		if transparent_treasure.IsTaken(chk) and chk ~= "m_inventory_box" then
			return true
		end

		for k, o in ipairs(protected.sections) do
			if o == chk then return true end
		end

		-- проверяем по имени объекта
		chk = v:name()
		for k, o in ipairs(protected.names) do
			if o == chk then return true end
		end

		-- проверяем по ID объекта
		chk = v.id
		for k, o in ipairs(protected.ids) do
			if o == chk then
				local p = zamok.reliability_code_check( chk ) + 1 /( level.get_game_difficulty()*10 + 5 )
			--	log("# reliability_code_check: %s", tostring(p))
				return math_random() < p
			end
		end

		-- проверяем по story ID объекта
		chk = v.m_story_id
		for k, o in ipairs(protected.story_ids) do
			if o == chk then return true end
		end
	end
	return false
end

function npc_smart_is_peaceful(sobj)
	local result = false
	if (sobj and smart_filters and #smart_filters>0) then
		if (sobj.smart_terrain_id and sobj:smart_terrain_id() and sobj:smart_terrain_id()~=65535) then
			local sm = AI:object(sobj:smart_terrain_id())
			if (sm and sm.name and sm:name()) then
				local sn = sm:name()
				for ks, vs in ipairs(smart_filters) do
					if (vs == sn) then
						-- Ага, он у нас мирный.
						result = true
						break
					end
				end
			end
		end
	end
	return result
end

function on_death(npc_id)
	smart_terrain.on_death( npc_id )
end

function get_flags(npc_id)
	local flags = 0
	local obj = AI:object(npc_id)
	if obj then
		if IAmAMonster[obj:clsid()] or IAmAStalker[obj:clsid()] then
			local char_ini = xr_logic.get_customdata_or_ini_file(obj, "<customdata>")
			if char_ini:section_exist("logic") then
				if char_ini:line_exist("logic", "cfg") then
					local logic_ini = ini_file( char_ini:r_string("logic", "cfg") )
					if logic_ini and logic_ini:section_exist("logic") then
						if logic_ini:line_exist("logic", "on_hit") then
							flags = bit_or(flags, 1)
						end
						if logic_ini:line_exist("logic", "on_death") then
							flags = bit_or(flags, 2)
						end
					end
				else
					if char_ini:line_exist("logic", "on_hit") then
						flags = bit_or(flags, 1)
					end
					if char_ini:line_exist("logic", "on_death") then
						flags = bit_or(flags, 2)
					end
				end
			end
		end
	end
	return flags
end

function is_valuable(item, section)
	if not (item or section) then return false end

	local sect = section or item:section_name()
	local cls = section and sys_ini:r_clsid(section, "class") or item:clsid()

	if (not (IAmAMonster[cls] or IAmAStalker[cls])) and (not protected_items.actor_items_keep(sect)) then
		-- Уники не подбираем (пока?)
		if no_sell_table[sect] == true then
			return false
		end

		local cost = sys_ini:r_float_ex(sect, "cost")
		if (IAmAWeapon[cls] and cost >= 1000) or (cost >= 800) then
			return sect~="zamok"
		end
	end
	return false
end

function init()
	build_tables()
	iTime = (game_time_minutes - iFreq) + 3
	off_npcs={}
end

