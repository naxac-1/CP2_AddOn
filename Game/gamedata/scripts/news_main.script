-- local ti = table.insert

local math_atan2 = math.atan2
local math_random = math.random
local table_remove = table.remove
local table_sort = table.sort
local table_random = table.random
local string_find = string.find
local string_gsub = string.gsub

local _debug = false
local prob = 0.35
local bInit = false

local timer_check_freq 			= 3 	-- Как часто проверять новости и выдавать сгруппированные, в игровых минутах

local timer_stalker_death 		= 3  	-- Сообщение о смерти сталкера
local timer_corpse 				= 60 -- 40 	-- Сообщение о найденом трупе
local timer_hear 				= 30  --15	-- Сообщение о услышанном
local timer_spawn 				= 45  --20 	-- Сообщение о увиденном
local timer_general 			= 30  --20	-- Прочее
local distance_close 			= 100	-- При каком расстоянии между обьектами считать их в одной группе
local timer_weather 			= 60	-- При изменнии погоды
local timer_heli 				= 10	-- При замеченном вертолетике

local timer_last_showed 		= 0 	-- Последняя показанная новость
local timer_show_freq 			= 6		-- Сколько ждать между новостями минимально (игровые минуты)
local timer_next_blow 			= 0			-- Тамер до след. выброса
local timer_blow_showed			= 0			-- Последняя показанная новость о Выбросе
local timer_blow_freq 			= 10 * 60  	-- Как часто новости о Выбросе показывать (игровые минуты)
local timer_eternal_stalker 	= 0 		-- Последняя показанная новость о Семецком
local timer_eternal_stalker_freq = 12 * 60 	-- Как часто новости о Семецком показывать (игровые минуты)
local timer_random_spawn		= 0			-- Последняя новость со спавном
local timer_random_spawn_freq 	= 5 * 60 	-- Как часто генерить новости со спавном (игровые минуты)
local timer_def_spawn			= 0			-- Последняя новость с "красивым" спавном
local timer_def_spawn_freq 		= 15 * 60 	-- Как часто генерить новости с "красивым" спавном (игровые минуты)
local timer_heli_showed			= 0			-- Последняя новость про вертолетик
local timer_heli_freq			= 10 		-- Как часто показывать новости про вертолетик (игровые минуты)
local timer_alife_showed		= 0			-- Последнее событие в оффлайн
local timer_alife_freq 			= 4 		-- Как часто генерить события в оффлайн (игровые минуты)
local timer_weather_showed 		= 0 		-- Последняя новость о погоде
local timer_weather_freq 		= 5 * 60 	-- Как часто новости о погоде показывать (игровые минуты)
local timer_daytime_showed 		= 0 		-- Последняя новость о времени суток
local timer_daytime_freq 		= 5 * 60	-- Как часто новости о времени суток показывать (игровые минуты)

if (_debug == true) then 
	timer_blow_freq 			= 30	-- Как часто новости о Выбросе показывать (игровые минуты)
	timer_eternal_stalker_freq 	= 30	-- Как часто новости о Семецком показывать (игровые минуты)
	timer_random_spawn_freq 	= 60 	-- Как часто генерить новости со спавном (игровые минуты)
	timer_def_spawn_freq 		= 60 	-- Как часто генерить новости с "красивым" спавном (игровые минуты)
	timer_alife_freq 			= 5 	-- Как часто генерить события в оффлайн
	timer_weather_freq 			= 30	-- Как часто новости о погоде показывать (игровые минуты)
	timer_daytime_freq 			= 30	-- Как часто новости о времени суток показывать (игровые минуты)
	timer_show_freq 			= 1		-- Сколько ждать между новостями минимально (игровые минуты)
	prob = 1.5
end


local bSmarts = false
local dist_close = 100
local dist_seen = 200
local dist_far = 200
local dist_heli_seen = 400
local dist_hear_min = 50
local dist_hear_max = 400

news_stack = {}
table_spawned = {}
table_killed_by_actor = {}
spammers = {}

function init()
	if (bInit == false) then
		news_data.Init()

		-- Реально в игре проходит timer_check_freq * 1000 * 60 * level.get_time_factor() секунд
		-- Реально проходит х секунд
		timer_last_showed = game_time_minutes
		timer_random_spawn = timer_last_showed - math_random(timer_random_spawn_freq)
		timer_def_spawn = timer_last_showed - math_random(timer_def_spawn_freq)
		timer_eternal_stalker = timer_last_showed - math_random(timer_eternal_stalker_freq)
		timer_blow_showed = timer_last_showed - math_random(timer_blow_freq)
		timer_heli_showed = timer_last_showed - math_random(timer_heli_freq)
		timer_alife_showed = timer_last_showed - math_random(timer_alife_freq)
		timer_weather_showed = timer_last_showed - math_random(timer_weather_freq)
		timer_daytime_showed = timer_last_showed - math_random(timer_daytime_freq)

	    if not has_timer("news_check") then
			start_game_timer("news_check", 0, 0, timer_check_freq)
	    end
    
		bInit = true
	end
end

function dbglog(fmt)
	if _debug == true then
	    local msg = fmt
		local msg_no_ws = string_gsub(msg, "%s", "_")
		get_console():execute("dbglog:" ..msg_no_ws..".")
		--get_console():execute("flush")		
	end
end

function mylog(text)
--	dbglog("==> "..text)
end

function trace(fmt)
	    local msg = fmt
		local msg_no_ws = string_gsub(msg, "%s", "_")
		get_console():execute("load ~~~ "..msg_no_ws)
		--get_console():execute("flush")		
end

function flushlog()
	get_console():execute("flush")		
end

function do_debug(title, text)
	if _debug == true then
		local m_title = ""
		local m_text = ""
		if title then m_title = title end
		if text then m_text = text end
		do_news(m_text, m_title, nil, 7)
	end
	mylog(title..": "..text)
end

function on_spawn_group(community, level, position, count, o_type)
	if (community and level and position and count and o_type and o_type > 0) then
		local s_author
		local author = get_nearest_stalker(level, position, dist_seen, 0)
		if (author) then
			s_author = get_npc_name(author)
		else
			return
		end
		local m_str = ""
		-- o_type = 1 - НПС
		-- o_type = 2 - монстры
		if(o_type == 2) then
			local coeff = 0.0
			local mon = community
			if (mon == "") then return end
			if (mon == "tushkano" or mon == "flesh" or mon == "dog" or mon == "psy_dog" or mon == "pseudodog" or mon == "cat" or mon == "boar") then
				coeff = -0.65
			elseif (mon == "bloodsucker" or mon == "controller") then
				coeff = 0.35				
			end
			if (math_random() < (prob + coeff)) then
				if (count == 1) then
					m_str = format_template_spawn(level, position, get_monster_name_by_string(mon, 4))
				else
					m_str = format_template_spawn_group(level, position, get_monster_name_by_string(mon, 6), count)
				end
				do_news(m_str, s_author, math_random(timer_spawn, timer_spawn*5), 7, nil, author.id)
			end
		elseif (o_type == 1) then
			if (math_random() < prob) then
				local zz = community
				local m_who = ""
				if (zz and news_data.community_name[zz]) then
					if (zz == "actor" or zz == "stalker" or zz == "dolg" or zz == "freedom" or zz== "trader" or zz== "nebo" or zz== "green") then -- это сталкер
						return
					end
					if (count == 1) then
						m_who = news_data.community_name[zz][3]
					else
						m_who = news_data.community_name[zz][4]
					end
				else
					trace("on_spawn_group - empty community_name for "..zz)
				end
				if (m_who == "") then return end
				if (count == 1) then
					m_str = format_template_spawn(level, position, m_who)
				else
					m_str = format_template_spawn_group(level, position, m_who, count)					
				end
				do_news(m_str, s_author, math_random(timer_spawn, timer_spawn*5), 7, nil, author.id)
			end
		end
	end
end

function on_spawn(obj)
-- Кто-то где-то появился.
-- Если монстрики - то кто-то мог видеть.
-- Или вояки\бандиты...
	if (obj) then
		add_spawned_object(obj)
	end
end

-- Дали по роже
function on_abuse(obj)
	if (obj == nil) then 
		return
	end
	if (obj.alive and obj:alive() == false) then
		return
	end
	local str = table_random(news_data.abuse_templates)
	local act
	if isGameObject(obj) == false then
		act = get_obj(obj.id)
	else
		act = obj
	end
	local m_name = get_npc_name(act)
	if (m_name == "" or m_name == nil) then
		m_name = amk_names_lists.get_strings(false)
	end
	do_news(str, m_name, math_random(timer_spawn, timer_spawn*5), 7, nil, act:id())	
end

function on_death(victim, killer)
	if (victim ~= nil) then
		if (IAmAStalker[victim:clsid()]) then
			local m_obj
			if (isGameObject(victim)) then
				m_obj = victim
			else
				m_obj = get_obj(victim.id)			
			end
			if (m_obj) then
				if (IsNpcStalker(m_obj)) then
					on_stalker_death(victim, killer)
				else
					on_npc_death(victim, killer)
				end
			end
		end	
	end
end


-- Погиб сталкер.
-- Собираем инфу о погибшем
-- Собираем инфу о виновнике смерти
-- Готовим сообщение
function on_stalker_death(victim_, killer_)
	if (victim_ == nil) then
		return
	end
	local m_killer = ""
	local m_killer_s = ""
	local m_victim = ""
	local victim
	if (isGameObject(victim_)) then
		victim = victim_
	else
		victim = get_obj(victim_.id)
	end
	local killer
	local m_name  = get_npc_name(victim)
	m_victim = format_death_stalker_corpse(victim)
	local m_level = get_level_name(get_object_levelname(victim))
	if (killer_) then
		if (isGameObject(killer_)) then
			killer = killer_
		else
			killer = get_obj(killer_.id)
		end
		if (IAmAMonster[killer:clsid()]) then
			m_killer = format_death_by_monster(killer)
			m_killer_str = get_monster_name(killer, 2)
		elseif (IsAnomaly(killer)) then
			m_killer = format_death_by_anomaly(killer)
			m_killer_str = get_anomaly_name(killer, 1)
		elseif (IsNpcStalker(killer)) then
			local m_o_weapon = get_npc_weapon(killer)
			local m_s_weapon = ""
			if (m_o_weapon) then
				m_s_weapon = get_weapon_type(m_o_weapon)
				if (m_s_weapon < 5) then m_killer_str = "пулевое ранение" end
				if (m_s_weapon == 6) then m_killer_str = "нож" end
				if (m_s_weapon == 8) then m_killer_str = "ожоги" end
				if (m_s_weapon == 7 or m_s_weapon == 5) then m_killer_str = "взрыв" end
			end
			if (IsNpcActor(killer)) then
				add_killed_by_actor(victim) -- Отметим, что это ГГ постарался.
			end						
			m_killer = format_death_by_stalker(killer)
		elseif (IsNpcOther(killer)) then
			local m_o_weapon2 = get_npc_weapon(killer)
			local m_s_weapon2 = ""
			if (m_o_weapon2) then
				m_s_weapon2 = get_weapon_type(m_o_weapon2)
				if (m_s_weapon2 < 5) then m_killer_str = "пулевое ранение" end
				if (m_s_weapon2 == 6) then m_killer_str = "нож" end
				if (m_s_weapon == 8) then m_killer_str = "ожоги" end
				if (m_s_weapon2 == 7 or m_s_weapon2 == 5) then m_killer_str = "взрыв" end
			end
			m_killer = format_death_by_stalker(killer)
		elseif killer:clsid() == clsid.turret_mgun then
			m_killer_str = "турель"
			m_killer = ""
		else
			m_killer_str = "причина смерти - неизвестна"
			m_killer = ""
			if _debug == true then mylog("On stalker death - unknown killer. "..killer:name().." clsid="..get_clsid(killer)) end
		end
	end
	if (m_killer_str==nil or m_killer_str=="") then m_killer_str = "причина смерти - неизвестна" end
	local m_string = m_name..". "..m_level..", "..m_killer_str.."."
	if (math_random() < 0.5) then   -- слишком часто приходят смс о смерти
		do_news(m_string, "Погиб сталкер:", math_random(timer_stalker_death, timer_stalker_death * 3), 5, "death", nil, 1) 
	end

	if (math_random() < prob) then
	--	local name, sname = amk_names_lists.get_strings()
	--	local s_author = name.." "..sname
		local s_author = amk_names_lists.get_strings()
		local m_str = ""
		local author = nil
		if (math_random() < 0.5) then
			if (math_random() < 0.5) then
				m_str = m_victim.." "..m_killer..""
			else
				m_str = m_victim..""
			end
			author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
		else
			author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_hear_max, dist_hear_min)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			m_str = format_death_hear_sounds(victim, killer)
		end
		if (m_str ~= "") then
			do_news(m_str, s_author, math_random(timer_corpse*2, timer_corpse *5), 7, nil, author.id)
		end
	end
end

-- Погиб кто-то, но не сталкер (военный, бандит, наемник...)
-- Посмотреть, попадают ли сюда Долг\Свобода
-- Собираем инфу о погибшем
-- Собираем инфу о виновнике смерти
-- Готовим сообщение
function on_npc_death(victim_, killer_)
	if (victim_ == nil) then
		return
	end
	local m_victim = ""
	local m_killer = ""
	local killer
	local victim
	if (isGameObject(victim_)) then
		victim = victim_
	else
		victim = get_obj(victim_.id)
	end
	m_victim = format_death_npc_corpse(victim)
	if (killer_) then
		if (isGameObject(killer_)) then
			killer = killer_
		else
			killer = get_obj(killer_.id)
		end
		if (killer) then
			if IAmAMonster[killer:clsid()] then
				m_killer = format_death_by_monster(killer)
			elseif (IsNpcStalker(killer)) then -- Хм, и кто ж его так? Или свои, или ГГ
				if (IsNpcActor(killer)) then
					add_killed_by_actor(victim) -- Отметим, что это ГГ постарался.
				end			
				m_killer = format_death_by_stalker(killer)
			elseif (IsNpcOther(killer)) then -- Ага. Или бандиты, или вояки, или киллеры... Вобщем, люди.
				m_killer = format_death_by_stalker(killer)
			elseif (IsAnomaly(killer)) then
				m_killer = format_death_by_anomaly(killer)
			else
				m_killer = ""
				if _debug == true then mylog("On npc death - unknown killer. "..killer:name().." clsid="..get_clsid(killer)) end
			end
		else
			if _debug == true then mylog("Хм. no killer. "..victim:name()) end
		end
	end
	if (math_random() < prob) then
		local s_from = ""
		local m_str = ""
		local author = nil
		local aid = nil
		if (math_random() < 0.5) then
			if (math_random() < 0.5) then
				m_str = m_victim.." "..m_killer..""
			else
				m_str = m_victim..""
			end
			author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_seen, 0)
			if (author) then
				s_from = get_npc_name(author)
				aid = author.id
			end
		else
			if (math_random() < 0.5 and Actor and Actor:id() ~= killer:id()) and (IsNpcStalker(killer)) then
				m_str = format_template_killer_act(victim)
				s_from = get_npc_name(killer)
			else
				author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_hear_max, dist_hear_min)
				if (author) then
					s_from = get_npc_name(author)
					aid = author.id
				else
					return
				end
				m_str = format_death_hear_sounds(victim, killer)
			end
		end
		if (m_str ~= "" and s_from ~= "") then
			if (_debug == true and author) then amk.add_spot_on_map(author.id, "red_location", s_from..": "..m_str) end
			do_news(m_str, s_from, math_random(timer_corpse*2, timer_corpse * 5), 7, nil, aid)
		end
	end
end

function get_obj(id)
	local m_obj = nil
	if (id) then
		m_obj = level.object_by_id(id)
	end
	return m_obj
end

function get_level_name(level_, index)
	if index == nil then index = 1 end
	local m_s_level 
	if level_ == nil then
		m_s_level = level.name()
	else
		m_s_level = level_
	end
	local m_tmp_str = ""
	if news_data.level_name[m_s_level] ~= nil then
		if (news_data.level_name[m_s_level][index] ~= nil) then
			m_tmp_str = news_data.level_name[m_s_level][index]..""
		end
	end
	return m_tmp_str
end

function get_current_time()
	local m_time = "00:00"
	if (level) then
		local m_h = level:get_time_hours()
		local m_m = level:get_time_minutes()
		m_time = m_h..":"..m_m
	end
	return m_time
end

function get_npc_name(obj)
	local m_s_name = ""
	if (obj) then
		if (isGameObject(obj)) then
			if (obj.character_name) then
				m_s_name = obj:character_name()
			end
		else
			local ob = get_obj(obj.id)
			if (ob and ob.character_name) then
				m_s_name = ob:character_name()
			else
			--	if IsNpcStalker(obj) then
					m_s_name = naxac_netpk.get_character_name(obj)
			--	end
			end
		end
	end
	if (m_s_name == nil) then
		m_s_name = ""
	end
	if (m_s_name == "") then
		--m_s_name = get_npc_community(obj)
	end
	return m_s_name
end

function get_npc_community(obj)
	local m_s_c = ""
	if (obj) then
		if IAmAMonster[obj:clsid()] then
			m_s_c = get_monster_name(obj, 1)
		else
			if (obj.character_community) then				
				m_s_c = obj:character_community()
			elseif (obj.community) then
				m_s_c = obj:community()
			end
		end
	end
	if (m_s_c == nil) then
		m_s_c = ""
	end
	if (obj and obj.name and m_s_c == "") then
		trace("get_npc_community returns '' for "..obj:name())
	end
	return m_s_c
end

function get_object_position(obj)
	local pos = nil
	if (obj) then
		if (isGameObject(obj) and obj.position) then
			pos = obj:position()
		else
			pos = obj.position
		end
	end
	return pos
end

function get_object_name(obj)
	local s_name = ""
	local value	= ""
	if (isGameObject(obj) and obj.section) then
		local sect = obj:section()
		--value	= utils.cfg_get_string(sys_ini, obj:section(), "inv_name", obj, false, "", "")
		value	= get_inv_name(sect)
		-- s_name = value
		s_name = game.translate_string(value)
		if string_find(sect, "^af_") then
			s_name = "артефакт "..s_name
		end
	elseif (obj.section_name) then
		local sect = obj:section_name()
		--value	= utils.cfg_get_string(sys_ini, obj:section_name(), "inv_name", obj, false, "", "")
		value	= get_inv_name(sect)
		-- s_name = value
		s_name = game.translate_string(value)
		if string_find(sect, "^af_") then
			s_name = "артефакт "..s_name
		end
	end
	if (s_name == nil) then s_name = "" end
	return s_name
end

function get_weapon_type(weapon)
    if(weapon and IAmAWeapon[weapon:clsid()]) then
        local section = get_weapon_name(weapon)
        if section == nil then 
            return 0
        elseif sys_ini:line_exist(section, "news_weapon_type") then
			return sys_ini:r_u32(section, "news_weapon_type")
        end
        log("~ news_main.get_weapon_type: Unknown weapon type for [ %s : %s ]", tostring(section), weapon:name())
    end
    return 0
end

function get_weapon_name(weapon)
	if weapon.section then
		return weapon:section()
	elseif weapon.section_name then
		return weapon:section_name()
	end
	return nil
end

function get_npc_weapon(obj)
	if (obj) then
		local ob
		if (isGameObject(obj) == false) then
			ob = get_obj(obj.id)
		else
			ob = obj
		end
		if (ob) then
			if (ob.active_item) then
				local m_act = ob:active_item()
				if (m_act) then
					if (IAmAWeapon[m_act:clsid()]) then
						return m_act
					else
						if _debug == true then mylog("get_npc_weapon - m_act is not a weapon - "..get_clsid(m_act)) end
					end
				else
					if _debug == true then mylog("get_npc_weapon - m_act = nil") end
				end
			else
				if _debug == true then
				mylog("get_npc_weapon - no active_item")
				if(ob.name) then mylog("get_npc_weapon - name: "..ob:name()) end
				mylog("get_npc_weapon - clsid: "..get_clsid(ob))
			end
			end
		else
			if _debug == true then mylog("get_npc_weapon - ob is nil") end
		end
	else
		if _debug == true then mylog("get_npc_weapon - obj is nil") end
	end
	return nil
end

function get_monster_name(obj, index)
	if obj and IAmAMonster[obj:clsid()] then
		local m_sec = obj.section and obj:section() or obj:section_name()
		return get_monster_name_by_string(m_sec, index)
	end
	return ""
end

function get_monster_name_by_string(str, index)
	if str then
		if (index == nil or index < 1) then
			index = 1
		end
		for i, v in ipairs(news_data.monster_classes) do
			if string_find(str, v[1]) then
				if v[index] then
					return v[index]
				else
					log("! [news_main.get_monster_name_by_string] index #%s not found for monster: %s", index, str)
					return ""
				end
			end
		end
		log("! [news_main.get_monster_name_by_string] Unknown monster: %s", str)
	end
	return ""
end

function get_npc_rank(obj)
	local m_rank = ""
	if (obj) then
		m_rank = ranks.get_obj_rank_name(obj)
		if (m_rank == nil) then
			m_rank = ""
		end
	end
	return m_rank
end

function get_monster_rank(obj)
	local m_rank = ""
	if (obj) then
		if (obj and IAmAMonster[obj:clsid()]) then
			m_rank = ranks.get_obj_rank_name(obj)
			if (m_rank == nil) then
				m_rank = ""
			end
		end
	end
	return m_rank
end

function get_anomaly_name(obj, index)
	if index == nil then index = 1 end
	if IsAnomaly(obj) then
		local m_type = obj.section and obj:section() or obj:section_name()
		if m_type then
			for k,v in pairs(news_data.anomaly_classes) do
				if string_find(m_type, k) then
					return v[index] or ""
				end
			end
		end
	end
	return ""
end

local stalker_community = {
	["actor"] = true,
	["actor_dolg"] = true,
	["actor_freedom"] = true,
	["stalker"] = true,
	["dolg"] = true,
	["freedom"] = true,
	["nebo"] = true,
	["green"] = true,
	["ecolog"] = true
}
local is_not_stalker = {
	['gar_dm_bandit_1'] = true,
	['gar_dm_bandit_2'] = true,
	['gar_dm_bandit_3'] = true,
	['agr_ratcatcher'] = true
}
function IsNpcOther(obj)
	if ( obj and IAmAStalker[ obj:clsid() ] ) then
		local m_comm  = get_npc_community(obj)
		if ( not stalker_community[m_comm] ) or is_not_stalker[ obj:name() ] then
			return true
		end
	end
	return false
end

function IsNpcStalker(obj)
	if ( obj and IAmAStalker[ obj:clsid() ] ) then
		local m_comm  = get_npc_community(obj)
		if stalker_community[m_comm] and not is_not_stalker[ obj:name() ] then
			return true
		end
	end
	return false
end

function IsNpcActor(obj)
	if (obj and IAmAStalker[obj:clsid()]) then
		local m_comm  = get_npc_community(obj)
		if (m_comm == "actor" or m_comm == "actor_dolg" or m_comm == "actor_freedom") then
			return true
		end
	end
	return false
end


function do_news(text, from, timeout, showtime, section, author_id, priority)
	if (text == nil) then text = "nil" end
	if (from == nil) then from = "nil" end
--	dbglog("add_news ==> "..text..": "..from)
	if (timeout == nil) then timeout = 0 end
	if (priority == nil) then priority = 0 end
	showtime = math.min(string.len(text)/10, 10)
	add_news(text, from, 1, timeout, showtime, section, author_id, priority)
end

function add_news(news_text, news_from, news_type, news_timeout, news_showtime, news_section, author_id, priority)
	newsitem = {
		eventType = news_type,
		created = game_time_minutes,
		text = news_text,
		from = news_from,
		timeout = game_time_minutes + (news_timeout / 60),
		showtime = news_showtime,
		section = news_section,
		lifetime = game_time_minutes + (news_timeout / 60) + 20,
		activated = nil,
		author_id = tonumber(author_id),
		priority = priority
	}
	table.insert(news_stack, newsitem)
end

function show_news(text, from, timeout, showtime, section)
	if (isIsolatedLevel(level.name()) == true)
		or (text == "")
		or (from == "")
		or sleep_manager.is_sleep_active()
	then return end

	local blow = amk.load_variable("blowout",-1)
	if blow > -1 and blow < 5 then return end	

	local diff = 0
	if (timer_next_blow ~= 0) then	
		diff = (timer_next_blow - game_time_minutes) * 60 -- Разница в игровых секундах.
		local eventtime = timeout * level.get_time_factor() -- Сколько пройдет игровых минут
		--trace("show_news: diff="..diff.." eventtime="..eventtime.." ["..timeout.."]")
		--flushlog()
		if eventtime >= diff then return end
	end

	if (text == nil) then text = "nil" end
	if (from == nil) then from = "nil" end
	if (timeout > 1000) then timeout = math_random(timer_general, timer_general * 4) end
--	dbglog("show_news ==> ["..timeout.."] "..from..": "..text)
	
	table.insert(spammers, from)

	text = "%c[gray2]"..from.."\\n%c[default]"..text
	if ( string.find(text, "\\n%c[gray2]", 1, true) ) ~= nil then
		amk_mod.show_news_queue(text, timeout, section)
	else
		news_manager.send_tip(text, timeout, section, showtime*1000)
	end

	timer_last_showed = game_time_minutes
end

function format_death_by_monster(obj)
	local m_s = ""
	local m_prefix = ""
	local m_suffix = ""
	local m_class = ""
	local m_postfix = ""
	if (obj) then
	-- monster_prefix + monster_classes + monster_suffix
	-- monster_suffix + monster_classes + monster_prefix
		m_prefix = table_random(news_data.monster_prefix).." "
		local m_suffid = math_random(#news_data.monster_suffix)
		local m_suff = news_data.monster_suffix[m_suffid]
		if (m_suff) then
			m_suffix = m_suff[math_random(#m_suff)]
			m_class = get_monster_name(obj, m_suffid+1)
			m_postfix = table_random(news_data.rate_postfix)
		end
		if (math_random() < 0.5) then
			m_s = m_prefix..""..m_suffix..""..m_class.."."..m_postfix
		else
			m_s = m_suffix..""..m_class..". "..m_prefix..""..m_postfix
		end
	end
	return m_s
end

function format_death_by_anomaly(obj)
	local m_s = ""
	local m_prefix = ""
	local m_suffix = ""
	local m_class = ""
	--local m_postfix = ""
	if (obj) then
	-- anomaly_prefix + anomaly_classes + anomaly_classes[3,4]
		m_prefix = table_random(news_data.anomaly_prefix)
		m_class = get_anomaly_name(obj, 2)
		m_suffix = get_anomaly_name(obj, math_random(3, 4))
		if (math_random() < 0.5) then
			m_s = m_prefix..""..m_class..". "..m_suffix.."." --..m_postfix.."."
		else
			m_s = m_prefix..""..m_class.."." --..m_postfix.."."
		end
	end
	return m_s
end

function format_death_by_stalker(obj)
	local m_s = ""
	if (obj) then
		local m_wpn = get_npc_weapon(obj)
		if (m_wpn) then
			local m_weapon = get_weapon_type(m_wpn)
			if m_weapon ~= 0 then
			m_s = format_template_weapon(m_weapon)
			end
		else
			if _debug == true then mylog("format_death_by_stalker - no weapon") end
		end
	end
	return m_s
end

function format_death_by_weapon(obj)
	local m_s = ""
	if (obj) then
		local m_weapon = get_weapon_type(obj)
		if m_weapon ~= 0 then
		m_s = format_template_weapon(m_weapon)
		end
	else
		if _debug == true then mylog("format_death_by_weapon - no weapon") end
	end
	return m_s
end

function format_death_stalker_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_stalker(obj)
	end
	return m_s
end

function format_death_npc_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_npc(obj)
	end
	return m_s
end

function format_death_monster_corpse(obj)
	local m_s = ""
	if (obj) then
		m_s = format_template_corpse_monster(obj)
	end
	return m_s
end

function format_death_hear_sounds(victim_, killer_, weapon_)
	local m_s = ""
	local m_hear_a = ""
	local m_hear_z = ""
	if (victim_) then
		if (killer_ and (IsNpcStalker(killer_) or IsNpcOther(killer_))) then -- Если killer == НПС - то стрельбу или взрывы
			if (weapon_ == nil) then
				local m_wpn = get_npc_weapon(killer_)
				if (m_wpn) then
					local m_weapon = get_weapon_type(m_wpn)
					if (m_weapon == 0) then return "" end
					if (m_weapon and news_data.weapon_classes[m_weapon]) then
						if (math_random() > news_data.weapon_classes[m_weapon]["hear_p"]) then
							return ""; -- Ничего не услышали, слишком тихое оружие...
						end
						m_hear_a = table_random(news_data.weapon_classes[m_weapon]["hear_a"])
						m_hear_z = table_random(news_data.weapon_classes[m_weapon]["hear_z"])
						m_s = format_template_hear(victim_, m_hear_a, m_hear_z)
					end
				end
			else
				local m_weapon = get_weapon_type(weapon_)
				if (m_weapon ==0) then return "" end
				if (m_weapon and news_data.weapon_classes[m_weapon]) then
					if (math_random() > news_data.weapon_classes[m_weapon]["hear_p"]) then
						return ""; -- Ничего не услышали, слишком тихое оружие...
					end
					m_hear_a = table_random(news_data.weapon_classes[m_weapon]["hear_a"])
					m_hear_z = table_random(news_data.weapon_classes[m_weapon]["hear_z"])
					m_s = format_template_hear(victim_, m_hear_a, m_hear_z)
				end			
			end
		elseif (killer_ and victim_ and IAmAMonster[victim_:clsid()] ~= true and (IsAnomaly(killer_) or IAmAMonster[killer_:clsid()])) then -- Если killer == аномалия и victim ~= монстры - то крики
			m_hear_a = "Слышал ужасные крики"
			m_hear_z = "слышал ужасные крики"
			m_s = format_template_hear(victim_, m_hear_a, m_hear_z)
		elseif ((killer_ and IAmAMonster[killer_:clsid()]) or (victim_ and IAmAMonster[victim_:clsid()])) then -- Если killer == монстры  или victim == монстры - то звуки
			m_hear_a = "Слышал страшный рык"
			m_hear_z = "слышал страшный рык"
			m_s = format_template_hear(victim_, m_hear_a, m_hear_z)
		else
			if _debug == true then
			if (victim_ and victim_.name) then
				mylog("format_death_hear_sounds - victim : "..victim_:name())
			end
			if (killer_) then
				mylog("format_death_hear_sounds - killer :  exists")
			end
			if (killer_ and killer_.name) then
				mylog("format_death_hear_sounds - killer : "..killer_:name())
			end
		end
	end
	end
	return m_s
end

function format_template_killer_act(obj)
	local m_s = ""
	if(obj ~= nil) then
		local m_class = ""
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end
		if IAmAMonster[obj:clsid()] then
			m_class = get_monster_name(obj, 4)
		else
			local m_comm  = get_npc_community(obj)
			if (m_comm and news_data.community_name[m_comm]) then
				m_class = news_data.community_name[m_comm][3]
			end
		end
		local common = news_data.common
		local t = {
			["class"] = m_class,
			["level"] = m_level,
			["killed_a"] = table_random(common["killed_a"]),
			["killed_z"] = table_random(common["killed_z"]),
			["hard_a"] = table_random(common["hard_a"]),
			["hard_z"] = table_random(common["hard_z"]),
			["meet_a"] = table_random(common["meet_a"]),
			["meet_z"] = table_random(common["meet_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.killer_act_templates)			
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_heli(obj, template_type)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (obj ~= nil and template_type and news_data.heli_templates[template_type]) then
		m_pos = get_object_position(obj)
		if (m_pos) then
			m_level = get_point_description(get_object_levelname(obj), m_pos)
			if (m_level == "") then return "" end
		end
		local common = news_data.common
		local t = {
			["level"] = m_level, 
			["carefull_a"] = table_random(common["carefull_a"]),
			["carefull_z"] = table_random(common["carefull_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.heli_templates[template_type])
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_weapon(weapon_type)
	if not weapon_type then return "" end
	local m_s = ""
	local wp_cls = news_data.weapon_classes[weapon_type]
	if (wp_cls and wp_cls["name"]) then
		local common = news_data.common
		local t = {
			["weapon_name_2"] = wp_cls["name"][2],
			["weapon_name_3"] = wp_cls["name"][3],
			["weapon_hit_a"] = table_random(wp_cls["hit_a"]),
			["weapon_hit_z"] = table_random(wp_cls["hit_z"]),
			["kill_a"] = table_random(common["kill_a"]),
			["kill_z"] = table_random(common["kill_z"]),
			["sad_a"] = table_random(common["sad_a"]),
			["sad_z"] = table_random(common["sad_z"]),
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["prob_a"] = table_random(common["prob_a"]),
			["prob_z"] = table_random(common["prob_z"])
		}
		local m_string = table_random(news_data.weapon_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_stalker(obj)
	local m_s = ""
	if(obj ~= nil) then
		local m_name  = get_npc_name(obj)
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj)) 
		if (m_level == "") then return "" end
		local m_rank  = get_npc_rank(obj)
		local m_rank_s = ""
		if (m_rank and news_data.rate_name[m_rank]) then
			m_rank_s = news_data.rate_name[m_rank][math_random(2, #news_data.rate_name[m_rank])]
		end
		local common = news_data.common
		local t = {
			["name"] = m_name,
			["level"] = m_level,
			["rate"] = m_rank_s,
			["kill_a"] = table_random(common["kill_a"]),
			["kill_z"] = table_random(common["kill_z"]),
			["sad_a"] = table_random(common["sad_a"]),
			["sad_z"] = table_random(common["sad_z"]),
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["prob_a"] = table_random(common["prob_a"]),
			["prob_z"] = table_random(common["prob_z"]),
			["corpse_a"] = table_random(common["corpse_a"]),
			["corpse_z"] = table_random(common["corpse_z"]),
			["seen_a"] = table_random(common["seen_a"]),
			["seen_z"] = table_random(common["seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.stalker_corpse_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_npc(obj)
	local m_s = ""
	if(obj ~= nil) then
		local m_name  = get_npc_name(obj)
		if (m_name == "") then
			m_name = "недавно в Зоне"
			local m_rank  = get_npc_rank(obj)
			local m_rank_s = ""
			if (m_rank and news_data.rate_name[m_rank]) then
				m_rank_s = news_data.rate_name[m_rank][math_random(2, #news_data.rate_name[m_rank])]
				m_name = m_rank_s
			end					
		end
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end
		local m_comm  = get_npc_community(obj)
		local m_class = ""
		if (m_comm and news_data.community_name[m_comm]) then
			m_class = news_data.community_name[m_comm][3]
		end
		local common = news_data.common
		local t = {
			["name"] = m_name,
			["level"] = m_level,
			["class"] = m_class,
			["kill_a"] = table_random(common["kill_a"]),
			["kill_z"] = table_random(common["kill_z"]),
			["sad_a"] = table_random(common["sad_a"]),
			["sad_z"] = table_random(common["sad_z"]),
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["prob_a"] = table_random(common["prob_a"]),
			["prob_z"] = table_random(common["prob_z"]),
			["corpse_a"] = table_random(common["corpse_a"]),
			["corpse_z"] = table_random(common["corpse_z"]),
			["corpse_name_a"] = table_random(common["corpse_name_a"]),
			["corpse_name_z"] = table_random(common["corpse_name_z"]),
			["seen_a"] = table_random(common["seen_a"]),
			["seen_z"] = table_random(common["seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.npc_corpse_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_corpse_monster(obj)
	local m_s = ""
	if(obj ~= nil) then
		local m_level = get_point_description(get_object_levelname(obj), get_object_position(obj))
		if (m_level == "") then return "" end		
		local m_name  = get_monster_name(obj, 3)
		local m_name2 = get_monster_name(obj, 4)
		local common = news_data.common
		local t = {
			["name"] = m_name,
			["class"] = m_name2,
			["c_corpse"] = m_name,
			["level"] = m_level,
			["kill_a"] = table_random(common["kill_a"]),
			["kill_z"] = table_random(common["kill_z"]),
			["sad_a"] = table_random(common["sad_a"]),
			["sad_z"] = table_random(common["sad_z"]),
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["prob_a"] = table_random(common["prob_a"]),
			["prob_z"] = table_random(common["prob_z"]),
			["corpse_a"] = table_random(common["corpse_a"]),
			["corpse_z"] = table_random(common["corpse_z"]),
			["seen_a"] = table_random(common["seen_a"]),
			["seen_z"] = table_random(common["seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.monster_corpse_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_hear(obj, hear_a, hear_z)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (obj) then
		if (isGameObject(obj)) then
			m_pos = obj:position()
		else
			m_pos = obj.position
		end
		if (m_pos) then
			m_level = get_point_description(get_object_levelname(obj), m_pos)
			if (m_level == "") then return "" end			
		end
		local common = news_data.common
		local t = {
			["level"] = m_level, 
			["hear_a"] = hear_a,
			["hear_z"] = hear_z,
			["carefull_a"] = table_random(common["carefull_a"]),
			["carefull_z"] = table_random(common["carefull_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.hear_sounds_tempates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_spawn(level_, position, class)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end	
		local common = news_data.common		
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["carefull_a"] = table_random(common["carefull_a"]),
			["carefull_z"] = table_random(common["carefull_z"]),
			["seen_a"] = table_random(common["spawn_seen_a"]),
			["seen_z"] = table_random(common["spawn_seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.spawn_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_spawn_group(level_, position, class, count)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class and count) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end	
		
		local s_count = ""
		if count == 1 then s_count = "одного"
		elseif count == 2 then s_count = "парочку"
		elseif count == 3 then s_count = "несколько"
		elseif count < 6 then s_count = "группу"
		elseif count < 8 then s_count = "большую группу"
		else s_count = "кучу" end

		local common = news_data.common
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["count"] = s_count,
			["carefull_a"] = table_random(common["carefull_a"]),
			["carefull_z"] = table_random(common["carefull_z"]),
			["seen_a"] = table_random(common["spawn_seen_a"]),
			["seen_z"] = table_random(common["spawn_seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"])
		}
		local m_string = table_random(news_data.spawn_templates_group)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_actor_seen(level_, position, class)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end	
		local common = news_data.common		
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["kill_seen_a"] = table_random(common["kill_seen_a"]),
			["kill_seen_z"] = table_random(common["kill_seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"]),
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["killed_a"] = table_random(common["killed_a"]),
			["killed_z"] = table_random(common["killed_z"]),
			["cool_a"] = table_random(common["cool_a"]),
			["cool_z"] = table_random(common["cool_z"])
		}
		local m_string = ""
		m_string = table_random(news_data.actor_seen_public_templates)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

function format_template_actor_seen_group(level_, position, class, count)
	local m_s = ""
	local m_level = ""
	local m_pos
	if (level_ and position and class and count) then
		m_pos = position
		m_level = get_point_description(level_, m_pos)
		if (m_level == "") then return "" end
		
		local s_count = ""
		if count == 1 then s_count = ""
		elseif count == 2 then s_count = "парочку"
		elseif count == 3 then s_count = "несколько"
		elseif count < 6 then s_count = "группу"
		else s_count = "большую группу" end

		local common = news_data.common
		local t = {
			["level"] = m_level, 
			["class"] = class,
			["count"] = s_count,
			["fun_a"] = table_random(common["fun_a"]),
			["fun_z"] = table_random(common["fun_z"]),
			["kill_seen_a"] = table_random(common["kill_seen_a"]),
			["kill_seen_z"] = table_random(common["kill_seen_z"]),
			["when_a"] = table_random(common["when_a"]),
			["when_z"] = table_random(common["when_z"]),
			["killed_a"] = table_random(common["killed_a"]),
			["killed_z"] = table_random(common["killed_z"]),
			["cool_a"] = table_random(common["cool_a"]),
			["cool_z"] = table_random(common["cool_z"])
		}
		local m_string = table_random(news_data.actor_seen_public_templates_group)
		for key0, value in pairs(t) do
			m_s = string_gsub(m_string, "%$"..key0, value)
			m_string = m_s
		end
		m_s = m_string
	end
	return m_s
end

local angle2str = {
	[ "северо-восток" ]	= { 30, 60 },
	[ "север" ]			= { 60, 120 },
	[ "северо-запад" ]	= { 120, 150 },
	[ "запад" ]			= { 150, 210 },
	[ "юго-запад" ]		= { 210, 240 },
	[ "юг" ]			= { 240, 300 },
	[ "юго-восток" ]	= { 300, 330 }
}
	
function get_point_description( level, point )
	if level == nil or (
		( level == "l10u_bunker"
		or level == "l11_pripyat" 
		or level == "l12_stancia"
		or level == "l12_stancia_2"
		or level == "l12u_control_monolith"
		or level == "l12u_sarcofag" )
		and isRadarDeactivated() == false
	) then
		return ""
	end
	
	local m_tmp_str = ""

	local tbl = news_data.level_name[ level ]
	if tbl and tbl[ 2 ] then
		m_tmp_str = tbl[ 2 ]
	else
		return ""
	end

	local m_points = news_data.base_points[ level ]
	if not ( m_points and point ) then return m_tmp_str end

	local dist = math.huge
	local m_dist = 0
	local m_point, i_point = nil, nil
	for i, value in ipairs( m_points ) do
		m_point = vector():set( unpack( value["p"] ) )
		m_dist = m_point:distance_to_sqr( point ) 
		if m_dist < dist then
			dist = m_dist
			i_point = i
		end
	end

	local t_point = m_points[ i_point ]

	local r = t_point.r0 or 20
	dist = math.sqrt( dist )
	if dist <= r then
		m_tmp_str = m_tmp_str.." "..t_point.text0
	elseif dist < r + 30 then
		m_tmp_str = m_tmp_str.." возле "..t_point.text
	elseif dist < r + 70 then
		m_tmp_str = m_tmp_str.." "..table.random({"около", "недалеко от", "неподалёку от"}).." "..t_point.text
	else --Говорим, куда (север, юг...)
		m_point = vector():set( unpack( t_point.p ) )
		local dir = point:sub( m_point )
		local angle = math_atan2( dir.z, dir.x ) *57
		if angle < 0 then angle = angle + 360
		elseif angle > 360 then angle = angle - 360 end

		local s_dir = "восток"
		for str, t in pairs( angle2str ) do
			if angle > t[ 1 ] and angle <= t[ 2 ] then
				s_dir = str
				break
			end
		end
		m_tmp_str = m_tmp_str.." к "..s_dir.."у от "..t_point.text
	end

	return m_tmp_str
end

function isGameObject(obj)
	local bResult = false
	if (obj and obj.fov) then
		bResult = true
	end
	return bResult
end

function get_object_levelname(obj)
	local mlevel = "null"	
	if (obj) then
		local m_game_vertex
		local nm = "nil"
		if (obj.name) then nm = obj:name() end
		if (isGameObject(obj)) then
			m_game_vertex = obj:game_vertex_id()
		else
			m_game_vertex = obj.m_game_vertex_id
		end
		if (m_game_vertex and GGraph:valid_vertex_id(m_game_vertex)) then
			local lvert = GGraph:vertex(m_game_vertex)
			if (lvert ~= nil and lvert.level_id) then
				local lid = lvert:level_id()
				if (lid ~= nil) then
					mlevel = AI:level_name(lid)
				else
					if _debug == true then mylog(" get_object_levelname - level id is null "..nm) end
				end
			else
				if _debug == true then mylog(" get_object_levelname - vertex is null "..nm) end
			end
			if mlevel == nil then mlevel = "nil" end
		else
			if _debug == true then mylog(" get_object_levelname - vertex_id is null "..nm) end
		end
	else
		if _debug == true then mylog("get_object_levelname - no obj") end
	end
	return mlevel
end

function check_news()
	-- выдать те новости, что успели собраться и сгрупироватся.
	amk.oau_reason="cn table_spawned"
	if table_spawned then
		-- for k, v in pairs(table_spawned) do
		for i=1, #table_spawned do
			local v = table_spawned[i]
			on_spawn_group(v.community, v.level, v.position, v.count, v.o_type)
		end
		-- _g.clear_table(table_spawned)
		table_spawned = {}
	end
	
	amk.oau_reason="cn killed_by_actor"
	if table_killed_by_actor then
		--for k, v in pairs(table_killed_by_actor) do
		for i=1, #table_killed_by_actor do
			local v = table_killed_by_actor[i]
			on_hero_seen(v.community, v.level, v.position, v.count, v.o_type)
		end
		-- _g.clear_table(table_killed_by_actor)
		table_killed_by_actor = {}
	end
	
	if (timer_last_showed + timer_show_freq < game_time_minutes) then
		-- Пора показывать, если есть что.
		amk.oau_reason="cn on_news"
		on_news()
	end

	spammers = {}
	amk.oau_reason="cn start_timer"	
	if not has_timer("news_check") then
		start_game_timer("news_check", 0, 0, timer_check_freq)
	end  
end

function add_spawned_object(obj)
	if (obj and (IAmAStalker[obj:clsid()] or IAmAMonster[obj:clsid()])) and obj:alive() then
		if obj.can_switch_online and obj:can_switch_online() == false then return end
		local s_comm = get_npc_community(obj)
		local communities = {
			[ "actor"] = true,
			[ "stalker"] = true,
			[ "dolg"] = true,
			[ "freedom"] = true,
			[ "stranger"] = true,
			[ "trader"] = true,
			[ "arena_enemy"] = true,
			[ "actor_dolg"] = true,
			[ "actor_freedom"] = true,
			[ "ecolog"] = true,
			[ "nebo"] = true,
			[ "green"] = true
			}
		if (s_comm and communities[s_comm]) then 
			return -- это сталкер
		elseif obj:name() == "mil_stalker0012" then
			return	-- сумасшедший на милитари
		end
		local s_id = ""
		local pos = get_object_position(obj)
		local lev = get_object_levelname(obj)
		local obj_type = 0
		if IAmAStalker[obj:clsid()] then 
			obj_type = 1
		elseif IAmAMonster[obj:clsid()] then 
			obj_type = 2 
		end
		if (isGameObject(obj)) then
			s_id = obj:id()
		else
			s_id = obj.id
		end	
		-- Проверим, не фильтруется ли он по smart_terrain
		if (news_data.smart_filters[s_comm] and #news_data.smart_filters[s_comm]>0) then
			local m_obj = nil
			if (obj.smart_terrain_id) then
				m_obj = obj
			else
				m_obj = AI:object(s_id)
			end
			if (m_obj and m_obj.smart_terrain_id and m_obj:smart_terrain_id() and m_obj:smart_terrain_id()~=65535) then
				local sm = AI:object(m_obj:smart_terrain_id())
				if (sm and sm.name and sm:name()) then
					local sn = sm:name()
					for ks, vs in pairs (news_data.smart_filters[s_comm]) do
						if string_find(sn, "^"..vs) then
							if _debug == true then mylog("add_spawned_object - "..s_comm.." on "..sn.." filtered") end
							return
						end
					end
				end
			end
		end
		-- Проверим, не монолитовцы ли это...
		if s_comm == "monolith" then
			if lev == "l10_radar" or lev == "l10u_bunker" or lev == "l11_pripyat" or lev == "l12_stancia" or lev == "l12_stancia_2" or lev == "l12u_control_monolith" or lev == "l12u_sarcofag" then
				return
			end
		end
		if s_comm == "zombie" or s_comm == "zombied" then
			if lev == "l08_yantar" then
				return
			end
		end
		local b_added = false
		if table_spawned then
			-- for k, v in pairs(table_spawned) do
			for i=1, #table_spawned do
				local v = table_spawned[i]
				if (v.community == s_comm and v.level == lev) then
					local mpos = v.position
					if (mpos) then
						local dist = pos:distance_to(mpos)
						if (dist < distance_close) then
							v.count = v.count + 1
							b_added = true
							break
						end
					end
				end
			end
		end
		if (b_added == false) then
			t = {id = s_id, community = s_comm, count = 1, level = lev, position = pos, o_type = obj_type}
			table.insert(table_spawned, t)
		else
			--
		end
	end
end

function add_killed_by_actor(obj)
	if (obj and (IAmAStalker[obj:clsid()] or IAmAMonster[obj:clsid()])) then
		local s_comm = get_npc_community(obj)
		if (s_comm and s_comm == "actor" or s_comm == "stalker" or s_comm == "dolg" or s_comm == "freedom" or s_comm == "trader" or s_comm == "ecolog" or s_comm == "nebo" or s_comm == "green") then 
			return -- это сталкер
		end
		local s_id = ""
		local lev = get_object_levelname(obj)
		local pos = get_object_position(obj)
		if (isGameObject(obj)) then
			s_id = obj:id()
		else
			s_id = obj.id
		end	
		local b_added = false
		local obj_type = 0
		if IAmAStalker[obj:clsid()] then
			obj_type = 1
		elseif IAmAMonster[obj:clsid()] then
			obj_type = 2
		end
		if table_killed_by_actor then
			-- for k, v in pairs(table_killed_by_actor) do
			for i=1, #table_killed_by_actor do
				local v = table_killed_by_actor[i]
				if (v.community == s_comm and v.level == lev) then
					local mpos = v.position
					if (mpos) then
						local dist = pos:distance_to(mpos)
						if (dist < distance_close) then
							v.count = v.count + 1
							b_added = true
							break
						end
					end
				end
			end
		end
		if (b_added == false) then
			t = {id = s_id, community = s_comm, count = 1, level = lev, position = pos, o_type = obj_type}
			table.insert(table_killed_by_actor, t)
		else
			--
		end
	end	
end

local convert_weather_tbl = {
--	["beta"] = "clear",
	["dry"] = "clear",
	["foggy"] = "fog",
	["rainy"] = "rain",
	["grey"] = "pasmurno",
	["stormy"] = "pasmurno",
	["thunder"] = "groza"
}
function on_weather_change(old_weather, new_weather)
--	log("# [news_main.on_weather_change]: %s -> %s", tostring(old_weather), tostring(new_weather))
-- clear, pasmurno, rain, groza
	old_weather = convert_weather_tbl[ string.match(old_weather, "^[^_]+") ]
	new_weather = convert_weather_tbl[ string.match(new_weather, "^[^_]+") ]
	if not (old_weather and new_weather) then return end
--	log("old_weather: %s, new_weather: %s", old_weather, new_weather)

	if (game_time_minutes - timer_weather_showed > timer_weather_freq) then
		if (math_random() < prob) then
			local s_weather = old_weather.."_"..new_weather
			local m_h = level:get_time_hours()
			local s_list = nil
			if m_h >= 6 and m_h < 21 then
				s_list = news_data.weather_templates_day
			else
				s_list = news_data.weather_templates_night
			end
			if s_list[s_weather] then
				local s_text = table.random(s_list[s_weather])
				local name = amk_names_lists.get_strings(true)
				show_news(s_text, name, math_random(timer_weather, timer_weather * 5), 7)
				timer_weather_showed = game_time_minutes
			end
		end
	end
end

function on_daytime()
-- ночь, рассвет, закат...
	if (game_time_minutes - timer_daytime_showed > timer_daytime_freq) then
		local m_h = level:get_time_hours()
		local m_m = level:get_time_minutes()
		local m_t = m_h * 60 + m_m
		local s_text = ""
		if (m_t >= 4*60+30 and m_t <= 6*60) then 
			-- 04:30 - 06:00 Рассвет
			if (math_random() < prob) then
				s_text = news_data.morning_templates[math_random(#news_data.morning_templates)]
				local name = amk_names_lists.get_strings(true)
				show_news(s_text, name, math_random(timer_weather, timer_weather * 5), 7)
				timer_daytime_showed = game_time_minutes
			end
		elseif(m_t >= 20*60+30 and m_t <= 22*60) then 
			-- 20:30 - 22:00 Закат
			if (math_random() < prob) then
				s_text = table_random(news_data.evening_templates)
				local name = amk_names_lists.get_strings(true)
				show_news(s_text, name, math_random(timer_weather, timer_weather * 5), 7)
				timer_daytime_showed = game_time_minutes
			end
		elseif(m_t >= 23*60 and m_t <= 24*60) or (m_t >= 0*60 and m_t <= 4*60) then 
			--23:00 - 04:00 Ночь			
			if (math_random() < prob) then
				local tbl = table_random(news_data.night_templates)
				local texts = tbl.texts
				local comments = tbl.comments
				local probl = tonumber(tbl.prob)
				local base_wait = math_random(timer_weather, timer_weather * 5)
				if (texts) then
					local name = "[источник неизвестен]"
					local i = 0
					for k, v in ipairs(texts) do
						if (comments == nil) then
							name = amk_names_lists.get_strings(true)
						end
						s_text = v
						show_news(s_text, name, base_wait + k * 3, 7)
						i = i + 1
					end
					if (probl and comments and news_data.comments_templates[comments] and math_random() < probl) then
						s_text = table_random(news_data.comments_templates[comments])
						local name = amk_names_lists.get_strings(true)
						show_news(s_text, name, base_wait + (i+1) * 3, 7)
					end
					timer_daytime_showed = game_time_minutes
				end				 
			end
			
		end
	end
end

-- Видели, как ГГ что-то делал
function on_hero_seen(community, level, position, count, o_type)
	if (community and level and position and count and o_type and o_type > 0) then
		local s_author = ""
		local m_str = ""
		local aid = nil
		local author = get_nearest_stalker(level, position, dist_seen, 30)
		if (author) then
			s_author = get_npc_name(author)
			aid = author.id
		else
			if (_debug == true) then mylog("on_hero_seen - skip") end
			return
		end

		-- o_type = 1 - НПС
		-- o_type = 2 - монстры
		if(o_type == 2) then
			local coeff = 0.0
			local mon = community
			if (mon == "") then return end
			if (mon == "tushkano" or mon == "flesh" or mon == "dog" or mon == "psy_dog" or mon == "pseudodog" or mon == "cat" or mon == "boar") then
				coeff = -0.65
			elseif (mon == "bloodsucker" or mon == "controller") then
				coeff = 0.3					
			end
			if (math_random() < (prob + coeff)) then
				if (count == 1) then
					m_str = format_template_actor_seen(level, potition, get_monster_name_by_string(mon, 4))
				else
					m_str = format_template_actor_seen_group(level, position, get_monster_name_by_string(mon, 6), count)
				end
				do_news(m_str, s_author, math_random(timer_corpse*5, timer_corpse*10), 7, nil, aid)
			end
		elseif(o_type == 1) then
			if (math_random() < prob) then
				local zz = community
				local m_who = ""
				if (zz and news_data.community_name[zz]) then
					if (zz == "actor" or zz == "stalker" or zz == "dolg" or zz == "freedom" or zz== "trader" or zz=="ecolog" or zz=="nebo" or zz=="green") then -- это сталкер
						return
					end
					if (count == 1) then
					m_who = news_data.community_name[zz][3]
					else
						m_who = news_data.community_name[zz][4]					
					end
				end
				if (m_who == "") then return end
				if (count == 1) then
					m_str = format_template_actor_seen(level, position, m_who)
				else
					m_str = format_template_actor_seen_group(level, position, m_who, count)
				end
				do_news(m_str, s_author, math_random(timer_corpse*5, timer_corpse*10), 7, nil, aid)
			end
		end
	end	
end


-- где-то веролет дает прикурить (heli_combat:round, heli_combat.heli_combat:search, heli_combat.heli_combat:flyby)
function on_heli_combat(obj)
	if (obj and game_time_minutes - timer_heli_showed > timer_heli_freq) then	
		if (math_random() < 0.5) then -- Не надо слишком часть о вертолетике сообщать
			if (math_random() < prob) then
				local s_author = ""
				local m_str = ""
				m_str = format_template_heli(obj, "combat")
				local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
				if (author) then
					s_author = get_npc_name(author)
				else
					return
				end
				do_news(m_str, s_author, math_random(timer_heli, timer_heli * 5), 7, nil, author.id, 1)
				timer_heli_showed = game_time_minutes
			end
		end
	end
end

-- видели вертолет
function on_heli_seen(obj)
	if (obj and game_time_minutes - timer_heli_showed > timer_heli_freq) then
		if (math_random() < prob) then
			local s_author = ""
			local m_str = ""
			m_str = format_template_heli(obj, "seen")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, math_random(timer_heli, timer_heli * 5), 7, nil, author.id, 1)
			timer_heli_showed = game_time_minutes
		end
	end
end

-- подбили вертолет
function on_heli_flame(obj)
	if (obj and game_time_minutes - timer_heli_showed > timer_heli_freq) then	
		if (math_random() < prob) then
			local s_author = ""
			local m_str = ""
			m_str = format_template_heli(obj, "flame")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, math_random(timer_heli, timer_heli * 5), 7, nil, author.id, 1)
			timer_heli_showed = game_time_minutes
		end
	end
end

-- упал вертолет
function on_heli_die(obj)
	if (obj and game_time_minutes - timer_heli_showed > timer_heli_freq) then	
		if (math_random() < prob) then
			local s_author = ""
			local m_str = ""
			m_str = format_template_heli(obj, "die")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, math_random(timer_heli, timer_heli * 5), 7, nil, author.id, 1)
			timer_heli_showed = game_time_minutes
		end
	end
end

-- улетел вертолетик
function on_heli_retreat(obj)
	if (obj and game_time_minutes - timer_heli_showed > timer_heli_freq) then	
		if (math_random() < prob) then
			local s_author = ""
			local m_str = ""
			m_str = format_template_heli(obj, "retreat")
			local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_heli_seen, 0)
			if (author) then
				s_author = get_npc_name(author)
			else
				return
			end
			do_news(m_str, s_author, math_random(timer_heli, timer_heli * 5), 7, nil, author.id, 1)
			timer_heli_showed = game_time_minutes
		end
	end
end

-- Видели монстров. Будем спавнить.
local reward_type = {
	money = 1,
	items = 2
}
function do_seen_monster()
	local avail = {}
	local s_author = amk_names_lists.get_strings(false)
	local o_author = ""
	local icon = "gen_info"
	local author_id = nil
	local where = ""
	for k,v in pairs(news_data.do_seen_monster_templates) do
		if (v.enabled == true) then
			-- Проверим, как там с режимом день\ночь
			local bDayOk = true
			for idx, cls in pairs(v.spawn) do
				local class = cls.class
				if (news_data.class_templates[class] and #news_data.class_templates[class] >0 ) then
					class = table_random(news_data.class_templates[class])
				end
				if (is_creature_day(class) == false) then
					bDayOk = false
					break
				end
			end
			if v.alive then
				local alive = tonumber(v.alive)
				if (alive and isAlive(alive) == false) then
					bDayOk = false
				end
			end
			if bDayOk == true then
				table.insert(avail, k)
			else
				--trace("Not day for "..v.text.." at "..level.get_time_hours())
			end
		end
	end

	if #avail == 0 then
		if _debug == true then mylog("do_seen_monster - no free news left.") end
		for k,v in pairs(news_data.do_seen_monster_templates) do
			v.enabled = true
		end
		return
	end

	local t = table_random(avail)
	local z = news_data.do_seen_monster_templates[t]
	-- Вытягиваем что надо.
	local spawn = z.spawn
	local text = z.text
	if not (text and spawn and (#spawn > 0)) then
		return
	end

	if (z.author) then 
		o_author = z.author
		s_author = z.author
	end
	if (z.icon) then icon = z.icon end
	local bInfo = true
	local info = z.has_info
	if (info) then				
		local tbl = string.explode(trim(info), ",", true)
		if #tbl>0 then
			bInfo = false
			for ki, vi in ipairs(tbl) do
				if has_alife_info(vi) then
					bInfo = true
				end
			end
		end
	end
	if (bInfo == false) then
		if _debug == true then mylog("do_seen_monster skip - "..text)	end
		return
	end

	local b_ok = false
	local microquest_created = false
	local obj
	for l,m in ipairs(spawn) do
		local class = m.class
		local count = m.count
		local point = m.point
		local lv = m.lv
		local gv = m.gv
		if (class and count and point and lv and gv) then
			local index
			local new_pos, x_offset, z_offset
			for index=1, count do
				x_offset = math_random(5)
				z_offset = math_random(5)
				new_pos = vector():set( point[1], point[2], point[3])
				new_pos.x = new_pos.x + x_offset
				new_pos.z = new_pos.z + z_offset
				if (point_is_far(new_pos, lv, gv, dist_far) == false) then
					-- Слишком близко.
					return
				end
				if game_options.DEBUG then
					local lname = AI:level_name( GGraph:vertex(gv):level_id() )
					log("# [news_main.do_seen_monster] create monster for news [%s] on level '%s'", class, lname)
				end
				se_monster.custom_data_on_spawn = "[smart_terrains]\n".."none = true"
				obj = AI:create(class, new_pos, lv, gv)
				if se_monster.custom_data_on_spawn then
					log("! [news_main.do_seen_monster] spawned obj is no monster: %s", obj:name())
					se_monster.custom_data_on_spawn = nil
				end
				if (obj) then
					if (o_author == "") then
						local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_seen, 0)
						if (author and get_npc_name(author) ~= "") then
							s_author = get_npc_name(author)
							o_author = s_author
							author_id = author.id
						end
					end
					if (where == "" and string_find(text,"$where")) then
						local m_where = get_point_description(get_object_levelname(obj), get_object_position(obj))
						if m_where then
							text = string_gsub(text, "$where", m_where)
							where = m_where
						end
					end
					if IAmAMonster[obj:clsid()] then
						local tbl = netpk:get(obj, netpk.fState)
						local cd = netpk:parse_custom_data(tbl.custom_data)
						if not cd.smart_terrains then cd.smart_terrains={} end
						cd.smart_terrains.none = "true"
						-- Микроквест
						if (not microquest_created) and z.reward then
							microquest_created = true
							if not cd.microquest then cd.microquest={} end
							if bit_and(z.reward.r_type, reward_type.money)~=0 then
								cd.microquest.reward_money = math_random(z.reward.c_min, z.reward.c_max) * 100
							end
							if bit_and(z.reward.r_type, reward_type.items)~=0 then
								cd.microquest.reward_items = ""
								local re_npc = author_id and AI:object(author_id)
								local rank
								if re_npc then
									rank = ranks.get_obj_rank_name(re_npc)
								else
									rank = ranks.get_rank_name_by_val( math_random(100, 5000), true )
								end
								if (rank and news_data.miniquest_rewards[rank]) then
									for i=1, math_random(1,3) do
										local section = table_random(news_data.miniquest_rewards[rank])
										if (section) then
											if (cd.microquest.reward_items == "" or cd.microquest.reward_items == "<nil>") then
												cd.microquest.reward_items = section
											else
												cd.microquest.reward_items = cd.microquest.reward_items..","..section
											end
											cd.microquest.reward_items = string.gsub(cd.microquest.reward_items, "%<nil%>", "")
										end
									end
								end
							end
							cd.microquest.reward_from = s_author
							cd.microquest.trader = z.reward.from
							if (_debug == true) then amk.add_spot_on_map(obj.id, "red_location", text) end
						end
						tbl.custom_data = netpk:gen_custom_data(cd)
						netpk:set(obj, tbl, netpk.fState)
					end
					b_ok = true
				end
			end					
		end
	end
	if (b_ok == true) then
		if (s_author ~= "") then
			if microquest_created then
				-- сообщение о микроквесте будем выводить независимо от очереди,
				-- чтобы наверняка не потерялось после перезагрузки
				text = "%c[gray2]"..s_author.."\\n%c[default]"..text
				news_manager.send_tip(text, math_random(timer_spawn, timer_spawn * 3), icon, 7000)
			elseif author_id then
				do_news(text, s_author, math_random(timer_spawn, timer_spawn * 3), 7, icon, author_id, 1)
			else
				show_news(text, s_author, math_random(timer_spawn, timer_spawn * 3), 7, icon)
			end
		end					
		news_data.do_seen_monster_templates[t].enabled = false				
		timer_def_spawn = game_time_minutes					
	end
end

local from2sid = {
	["trader"] = story_ids.Escape_Trader,
	["barman"] = story_ids.bar_Barman
}
function check_microquest(monster)
	local obj = AI:object( monster:id() )
	if obj then
		local data = netpk:get(obj, netpk.fState)
		local cd = netpk:parse_custom_data(data.custom_data)
		if cd.microquest then
			if cd.microquest.trader == nil then
				cd.microquest.trader = "trader"
			end
			local trader = AI:story_object( from2sid[cd.microquest.trader] )
			local tdata = netpk:get(trader, netpk.fState)
			local tcd = netpk:parse_custom_data(tdata.custom_data)
			if tcd.microquest == nil then
				tcd.microquest = { reward_money = 0, reward_items = "" }
			end
			tcd.microquest.reward_money = tcd.microquest.reward_money + (cd.microquest.reward_money or 0)
			tcd.microquest.reward_items = tcd.microquest.reward_items..","..(cd.microquest.reward_items or "")
			tcd.microquest.reward_items = string.gsub(tcd.microquest.reward_items, "%<nil%>", "")
			tdata.custom_data = netpk:gen_custom_data(tcd)
			netpk:set(trader, tdata, netpk.fState)
			local target_name = get_monster_name(obj, 4)

			start_real_timer(
				"miniquest", math.random(120, 240),
				{cd.microquest.trader, cd.microquest.reward_from, target_name}
			)
		end
	end
end

function miniquest_reward_news(tbl)
	local trader = tbl[1]
	local trader_name = news_data.reward_phrases_authors[trader]
	if trader_name == nil then
		return
	end

	local rewarder = string.gsub(tbl[2], "_", " ")
	if string_find(rewarder, "источник неизвестен") then
		rewarder = "какой-то сталкер"
	elseif string_find(rewarder, "Долг") then
		rewarder = "полковник Петренко"
	elseif rewarder == "Сахаров" then
		rewarder = "человечек от учёных с Янтаря"
	end

	local text = table_random(news_data.reward_phrases_templates[trader])
	local t = {
		["actor"] = Actor:character_name(),
		["who"] = rewarder,
		["target"] = tbl[3]
	}
	news_manager.send_tip("%c[gray]"..trader_name.."\\n%c[red_sms]"..format_text_pairs(text, t), 0, trader, 12000)
end

function on_wound(obj)
	if (obj and obj.name) then
		if (IsNpcStalker(obj)) then
			if (math_random() < prob) then
				local stype = "single"
				local author_id = obj.id
				if (math_random() < 0.5) then stype = "group" end
				local stext = table_random(news_data.wound_templates[stype])
				local m_pos = get_object_position(obj)
				local m_level = ""
				if (m_pos) then
					m_level = get_point_description(get_object_levelname(obj), m_pos)
					if (m_level == "") then return end
				end
				local sname = get_npc_name(obj)
				local t = { ["level"] = m_level, ["name"] = sname }
				local m_s = ""
				for key0, value in pairs(t) do
					m_s = string_gsub(stext, "%$"..key0, value)
					stext = m_s
				end
				m_s = stext
				local sfrom = sname
				if (stype == "group") then
					local author = get_nearest_stalker(get_object_levelname(obj), get_object_position(obj), dist_seen, 0)
					if (author and get_npc_name(author) ~= "") then
						sfrom = get_npc_name(author)
						author_id = author.id
					else
						sfrom = amk_names_lists.get_strings(false)
					end
				end
				do_news(m_s, sfrom, math_random(timer_stalker_death, timer_stalker_death * 2), 5, nil, author_id, 1)
				if (isGameObject(obj)) then
					if (_debug) then amk.add_spot_on_map(obj:id(), "red_location", m_s) end
				else
					if (_debug) then amk.add_spot_on_map(obj.id, "red_location", m_s) end
				end
			end
		end
	end
end

-- Сообщение о гибели Семецкого
function do_eternal_stalker()
	local m_level = news_data.levels[math_random(#news_data.levels-5)]
	local b_indoor = news_data.levels_types[m_level]
	if (m_level and news_data.level_name[m_level]) then
		m_level = news_data.level_name[m_level][1]
	end
	local m_name = "Юрий Семецкий"
	local m_killer_str = ""
	-- Аномалия, монстр или НПС(?).
	if (math_random() < 0.4) then
		-- Аномалия
		if (b_indoor == 0) then
			m_killer_str = table_random(news_data.anomalies)
		else
			-- Не все аномалии под землей бывают...
			m_killer_str = news_data.anomalies[math_random(#news_data.anomalies-3)]			
		end
	else
		-- Монстры
		if (b_indoor == 0) then
			m_killer_str = table_random(news_data.monsters)
		else
			-- Не все монстры под землей бывают...
			m_killer_str = news_data.monsters[math_random(#news_data.monsters-8)]
		end
	end
	local m_string = m_name..", "..m_level..", "..m_killer_str.."."
	local sem_timeout = math_random(timer_stalker_death, timer_stalker_death * 5)
	show_news(m_string, "Погиб сталкер:", sem_timeout, 5, "death")
	timer_eternal_stalker = game_time_minutes
end

function next_blow(timer)
	timer_next_blow = game_time_minutes + timer
end

--[[------------------------ новости о времени до выброса ----------------------]]
function do_blow_news()
	if game_options.RunBlowoutPP == false then return end

	if (timer_next_blow == 0) then return end

	local bl = amk.load_variable("blowout",-1)
	if (bl > -1 and bl < 5) then return end

	local diff = (timer_next_blow - game_time_minutes) / 60 -- Разница в игровых часах
	if diff < 1 then return end
	local item = table_random(news_data.blowout_templates)
	local stext = item["text"]
	local alive = item["alive"]
	if (alive and isAlive(alive) == false) then
		return
	end
	if (stext) then
		local when = ""
		if (diff < 2) then
			when = "через час-другой"
		elseif (diff >= 2 and diff <=4) then	
			when = "через пару часов"
		elseif (diff > 4 and diff <=8) then	
			when = "часов через 6-7"
		elseif (diff > 8) then
			local m_h = level:get_time_hours()
			local n_h = m_h + diff
			if (n_h >= 9 and n_h < 11) then when = "утром" end
			if (n_h >= 11 and n_h < 14) then when = "днем" end
			if (n_h >= 14 and n_h < 18) then when = "после обеда" end
			if (n_h >= 18 and n_h < 22) then when = "вечером" end
			if (n_h >= 22 and n_h < 30) then when = "ночью" end
			if (n_h >= 30 and n_h < 34) then when = "завтра утром" end
			if (n_h >= 34 and n_h < 38) then when = "завтра днем" end
			if (n_h >= 38 and n_h < 42) then when = "завтра после обеда" end
			if (n_h >= 42 and n_h < 50) then when = "завтра ночью" end
		end
		if (when == "") then return end
		local t = { ["when"] = when}
		local m_s = ""
		for key0, value in pairs(t) do
			m_s = string_gsub(stext, "%$"..key0, value)
			stext = m_s
		end
		m_s = stext
		local sfrom = amk_names_lists.get_strings(true, 'nebo', 'trader', 'green', 'stalker', 'ecolog', 'freedom', 'dolg')
		show_news(stext, sfrom, math_random(10, timer_general), 5)
		timer_blow_showed = game_time_minutes
	end
 end
--[[--------------------------------- lsclon -----------------------------------]]

function news_sort(a,b)
	if (a.priority==1 and b.priority ~=1) then
		return false
	end
	return a.created < b.created
	--return a.timeout < b.timeout
end


function on_news()
	local avail = {}
	if news_stack then 
		amk.oau_reason="cn on_news first pass"
		local v
		if #news_stack > 0 then
			for i = #news_stack, 1, -1 do
				v = news_stack[i]
				if v.activated == nil then
					if (v.lifetime <= game_time_minutes) then
						-- Новость устарела.
							-- mylog("Too old - "..v.from..": "..v.text)
						table_remove(news_stack, i)
					end
				else -- Новость уже была.
					table_remove(news_stack, i)
				end
			end
		end
		if #news_stack > 0 then
			amk.oau_reason="cn on_news sort"
			-- Отсортируем.
			table_sort(news_stack, news_sort)
			--amk.dump_table(news_stack)
			amk.oau_reason="cn on_news second pass"
			for i = #news_stack, 1, -1 do
				v = news_stack[i]
				if v.activated == nil then
					if (v.lifetime > game_time_minutes) then
						if (v.timeout < game_time_minutes) then -- Новость актуальна.
							table.insert(avail, i)
						else
					--		if _debug == true then mylog("Not ready yet - ".. v.from..": "..v.text) end -- Еще не время.
						end
					else -- Новость устарела.
						if _debug == true then mylog("Too old - "..v.from..": "..v.text) end
						table_remove(news_stack, i)
					end
				else -- Новость уже была.
					table_remove(news_stack, i)
				end
			end
		end
	end
	
	if avail and #avail > 0 then
		amk.oau_reason="cn on_news get available"
		--local t = avail[math_random(#avail)]
		local cnt = math_random(1, 2)
		local tmt = 0
		for i = 1, cnt do
			local t = avail[i]
			local z = news_stack[t]
			if (z) then
				local bAlive = false
				local m_author_id = tonumber(z.author_id)
				if (m_author_id ~= nil) then
					amk.oau_reason="cn on_news check author"
					bAlive = false
					local obj = AI:object(m_author_id)
					amk.oau_reason="cn on_news check author obj"
					if (obj) then
						amk.oau_reason="cn on_news author obj exists"
						if (IAmAStalker[obj:clsid()]) then
							amk.oau_reason="cn on_news author obj is NPC"
							if IsNpcStalker(obj) then
								amk.oau_reason="cn on_news check author alive"
								if (obj.alive and obj:alive()==true and obj.health and obj:health() > 0) then
									if (_debug == true) then amk.add_spot_on_map(obj.id, "red_location", z.from..": "..z.text) end
									amk.oau_reason="cn on_news author is alive"
									bAlive = true
								end
							end
						end
					end
				else
					bAlive = true
				end
				if (bAlive == true) then
					amk.oau_reason="cn on_news show_news"
					--show_news(z.from, z.text, z.timeout, z.showtime, z.section)
					-- show_news(z.text, z.from, 0, z.showtime, z.section)
					show_news(z.text, z.from, tmt, z.showtime, z.section)
					tmt = tmt + 9
					amk.oau_reason="cn on_news set activated"
					z.activated = game_time_minutes
				else
					amk.oau_reason="cn on_news show_news alive is false"
				end
			end
		end
	else
--		mylog("on_news [5] - no news ")
	end	

	amk.oau_reason="cn on_news continue"

	if (timer_next_blow == 0) then
		local timer = get_timer("blow_shift")
		timer_next_blow = (timer.time or 0)/60000
	end

    local gtime = game_time_minutes
	
	if (gtime - timer_alife_showed > timer_alife_freq) then
		amk.oau_reason="cn on_news offline_alife start"
		amk_offline_alife.offline_alife()
		amk.oau_reason="cn on_news offline_alife exit"
		timer_alife_showed = gtime
	end
	if (gtime - timer_blow_showed > timer_blow_freq) then
		do_blow_news()
	end
	if (gtime - timer_eternal_stalker > timer_eternal_stalker_freq) then
		do_eternal_stalker()	
	end
	if (gtime - timer_def_spawn > timer_def_spawn_freq) then
		do_seen_monster()	
	end	
	if (gtime - timer_daytime_showed > timer_daytime_freq) then
		on_daytime()
	end
end

function on_offline_item_found(who, object)
	if _debug == true then
	if (who and object) then
		mylog(get_npc_name(who).." нашел "..get_object_name(object))
	end
end
end

function on_offline_artifact_found(who, object)
	if _debug == true then
	if (who and object) then
		mylog(get_npc_name(who).." нашел "..get_object_name(object))
	end	
end
end

function on_offline_weapon_found(who, object)
	if _debug == true then
	if (who and object) then
		mylog(get_npc_name(who).." нашел "..get_object_name(object))
	end
end
end

function on_offline_monster_found(who, object)
	if (who and object) then
		local s_enemy = ""
		if (IAmAMonster[object:clsid()]) then
			s_enemy = get_monster_name(object, 2)
		end
		mylog(get_npc_name(who).." воюет с "..s_enemy)
	end	
end

function on_offline_enemy_found(who, object)
	if (who and object) then
		local s_enemy = ""
		if (IAmAStalker[object:clsid()]) then
			s_enemy = get_npc_community(object)
		end
		if _debug == true then mylog(get_npc_name(who).." воюет с "..s_enemy) end
	end
end

-- Кого-то грохнули в оффлайн.
function on_offline_death(victim, killer, weapon)
	victim = victim and victim.id and AI:object(victim.id)
	killer = killer and killer.id and AI:object(killer.id)
	if victim and killer then
		weapon = weapon and weapon.id and AI:object(weapon.id)
		amk.oau_reason=string.format("[news_main.on_offline_death]: %s kill %s from %s",
			victim:name(),
			killer:name(),
			(weapon and weapon:name() or "nil")
		)
		if (IAmAStalker[victim:clsid()]) then
			if (IsNpcStalker(victim)) then
				on_offline_stalker_death(victim, killer, weapon)
			else
				on_offline_npc_death(victim, killer, weapon)
			end
		end	
	end
end

function on_offline_stalker_death(victim_, killer_, weapon_)
	if (victim_ == nil) then
		return
	end
	local ss="news_main.on_offline_stalker_death "
	amk.oau_reason=ss.."1"
	local m_killer = ""
	local m_killer_s = ""
	local m_victim = ""
	local aid = nil
	local m_name  = get_npc_name(victim_)
	amk.oau_reason=ss.."2"
	m_victim = format_death_stalker_corpse(victim_)
	amk.oau_reason=ss.."3"
	local m_level = get_level_name(get_object_levelname(victim_))
	amk.oau_reason=ss.."4"
	if (killer_) then
	amk.oau_reason=ss.."5"
		if IAmAMonster[killer_:clsid()] then
	amk.oau_reason=ss.."6"
			m_killer = format_death_by_monster(killer_)
	amk.oau_reason=ss.."6.1"
			m_killer_str = get_monster_name(killer_, 2)
		elseif (IsAnomaly(killer_)) then
	amk.oau_reason=ss.."7"
			m_killer = format_death_by_anomaly(killer_)
	amk.oau_reason=ss.."7.1"
			m_killer_str = get_anomaly_name(killer_, 1)
		elseif (IsNpcStalker(killer_)) then
			local m_o_weapon = weapon_
			local m_s_weapon = ""
			if (m_o_weapon) then
	amk.oau_reason=ss.."8"
				m_s_weapon = get_weapon_type(m_o_weapon)
				if (m_s_weapon < 5) then m_killer_str = "пулевое ранение" end
				if (m_s_weapon == 6) then m_killer_str = "нож" end
				if (m_s_weapon == 8) then m_killer_str = "ожоги" end
				if (m_s_weapon == 7 or m_s_weapon == 5) then m_killer_str = "граната" end
			end
	amk.oau_reason=ss.."8.1"
			m_killer = format_death_by_weapon(weapon_)
		elseif (IsNpcOther(killer_)) then
			local m_o_weapon2 = weapon_
			local m_s_weapon2 = ""
			if (m_o_weapon2) then
	amk.oau_reason=ss.."9"
				m_s_weapon2 = get_weapon_type(m_o_weapon2)
				if (m_s_weapon2 < 5) then m_killer_str = "пулевое ранение" end
				if (m_s_weapon2 == 6) then m_killer_str = "нож" end
				if (m_s_weapon == 8) then m_killer_str = "ожоги" end
				if (m_s_weapon2 == 7 or m_s_weapon2 == 5) then m_killer_str = "граната" end
			end
	amk.oau_reason=ss.."9.1"
			m_killer = format_death_by_weapon(weapon_)
		else
	amk.oau_reason=ss.."10"
			m_killer_str = "причина смерти - не установлена"
			m_killer = ""
			--mylog("On offline stalker death - unknown killer. "..killer:name().." clsid="..get_clsid(killer))				
		end
	end
	amk.oau_reason=ss.."11"
	if (m_killer_str==nil or m_killer_str=="") then m_killer_str = "причина смерти - неустановлена" end
	local m_string = m_name..", "..m_level..", "..m_killer_str.."."
--	if _debug == true then mylog("Offline: Погиб сталкер: "..m_string)  end
--	if (math_random() < 0.5) then -- слишком часто приходят сообщения о смерти
	if true then
	amk.oau_reason=ss.."12"
		do_news(m_string, "Погиб сталкер:", math_random(timer_stalker_death, timer_stalker_death * 5), 5, "death", nil, 1) 
	end
	amk.oau_reason=ss.."13"

--	if (math_random() < prob) then
	if true then
	amk.oau_reason=ss.."14"
	--	local name, sname = amk_names_lists.get_strings()
		local s_author = "" --name.." "..sname
		local m_str = ""
		if (math_random() < 0.5) then
	amk.oau_reason=ss.."15"
			if (math_random() < 0.5) then
				m_str = m_victim.." "..m_killer..""
			else
				m_str = m_victim..""
			end
	amk.oau_reason=ss.."16"
			local author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_seen, 0)
			if (author) then
	amk.oau_reason=ss.."17"
				s_author = get_npc_name(author)
				aid = author.id
			end			
		else
	amk.oau_reason=ss.."18"
			local author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_hear_max, dist_hear_min)
			if (author) then
	amk.oau_reason=ss.."19"
				s_author = get_npc_name(author)
				aid = author.id
			else
	amk.oau_reason=ss.."end"
				return
			end		
	amk.oau_reason=ss.."20"
			m_str = format_death_hear_sounds(victim_, killer_, weapon_)
		end
	amk.oau_reason=ss.."21"
		if (m_str ~= "" and s_author ~= "") then
	amk.oau_reason=ss.."22"
			if _debug == true then mylog("Offline: "..s_author.." "..m_str)  end
	amk.oau_reason=ss.."23"
			do_news(m_str, s_author, math_random(timer_corpse, timer_corpse *5), 7, nil, aid)
		end
	end
	amk.oau_reason=ss.."end"
end

function on_offline_npc_death(victim_, killer_, weapon_)
	if (victim_ == nil) then
		return
	end
	local ss="news_main.on_offline_npc_death "
	amk.oau_reason=ss.."1"
	local m_victim = ""
	local m_killer = ""
	local aid = nil
	m_victim = format_death_npc_corpse(victim_)
	amk.oau_reason=ss.."2"
	if (killer_) then
		amk.oau_reason=ss.."3"
		if IAmAMonster[killer_:clsid()] then
			amk.oau_reason=ss.."3.1"
			m_killer = format_death_by_monster(killer_)
		elseif (IsNpcStalker(killer_)) then -- Хм, и кто ж его так? Или свои, или ГГ
			amk.oau_reason=ss.."3.2"
			m_killer = format_death_by_weapon(weapon_)
		elseif (IsNpcOther(killer_)) then -- Ага. Или бандиты, или вояки, или киллеры... Вобщем, люди.
			amk.oau_reason=ss.."3.4"
			m_killer = format_death_by_weapon(weapon_)
		elseif (IsAnomaly(killer_)) then
			amk.oau_reason=ss.."3.5"
			m_killer = format_death_by_anomaly(killer_)
		else
			amk.oau_reason=ss.."3.6"
			m_killer = ""
			if _debug == true then mylog("On offline npc death - unknown killer. "..killer:name().." clsid="..get_clsid(killer))	end
		end
	else
		amk.oau_reason=ss.."4"
		if _debug == true then mylog("Хм. no killer. "..victim_:name()) end
	end
	amk.oau_reason=ss.."5"
	if (math_random() < prob) then
		local s_from = ""
		local s_author = s_from
		local m_str = ""
		amk.oau_reason=ss.."6"
		if (math_random() < 0.5) then
			amk.oau_reason=ss.."7"
			if (math_random() < 0.5) then
				amk.oau_reason=ss.."7.1"
				m_str = m_victim.." "..m_killer..""
			else
				amk.oau_reason=ss.."7.2"
				m_str = m_victim..""
			end
			amk.oau_reason=ss.."8"
			local author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_seen, 0)
			if (author) then
				amk.oau_reason=ss.."9"
				s_author = get_npc_name(author)
				s_from = s_author
				aid = author.id
			end			
		else
			amk.oau_reason=ss.."10"
			local author = get_nearest_stalker(get_object_levelname(victim_), get_object_position(victim_), dist_hear_max, dist_hear_min)
			if (author) then
				amk.oau_reason=ss.."11"
				s_author = get_npc_name(author)
				s_from = s_author
				aid = author.id
			else
				amk.oau_reason=ss.."12"
				return
			end		
			amk.oau_reason=ss.."13"
			m_str = format_death_hear_sounds(victim_, killer_, weapon_)
		end
		if (m_str ~= "" and s_from ~= "") then
			amk.oau_reason=ss.."14"
			do_news(m_str, s_from, math_random(timer_corpse, timer_corpse *5), 7, nil, aid)
			if _debug == true then mylog("Offline: "..s_from.." "..m_str) end
		end
	end
end

-- Кого-то ранили в оффлайн.
function on_offline_wound(victim)
	if (victim) then
		if _debug == true then mylog("Offline: "..victim:name().." is wounded") end
		on_wound(victim)
	end
end

function on_offline_fight(team_A, team_B)
 -- Была перестрелка с . Всех перебили
-- Нарвался (Нарвались) на . Всех перебили
-- Была перестрелка с . 2 положили.
-- Нарвался (Нарвались) на . 4 положили.
-- Была перестрелка с . 2 наших положили.
-- Нарвался (Нарвались) на . 4 наших положили.
end

function on_offline_corpse_found(who, object)
	if (who and object) then
		if IsNpcStalker(who) then
			local s_corpse = ""
			if IAmAMonster[object:clsid()] then
				s_corpse = format_template_corpse_monster(object)
			elseif (IAmAStalker[object:clsid()]) then
				if (IsNpcStalker(object)) then
					s_corpse = format_template_corpse_stalker(object)			
				else
					s_corpse = format_template_corpse_npc(object)
				end
			end
			if (s_corpse == nil) then s_corpse = "" end
			local s_from = get_npc_name(who)
			if (s_from and s_corpse and s_corpse ~= "" and s_from ~= "") then
				do_news(s_corpse, s_from, math_random(timer_corpse, timer_corpse *5), 7)
			end
			-- amk.mylog("Offline: "..get_npc_community(who).." found a corpse. "..s_corpse)
		end
	end
end

function on_offline_trade(npc, item)
	if (npc and item and math_random() < 0.02) then
		local m_from = get_npc_name(npc)
		local m_str = table_random(news_data.trade_templates)
		local m_level = get_point_description(get_object_levelname(npc), get_object_position(npc))
		if (m_level == "") then return end		
		local m_title = get_object_name(item)
		local t = {["level"] = m_level, ["item"] = m_title}
		for key0, value in pairs(t) do
			m_str = string_gsub(m_str, "%$"..key0, value)
		end
		if (m_str ~= "") then
			if _debug == true then mylog("Offline: Trade "..m_from.." "..m_str) end
			--show_news(m_str, m_from, math_random(timer_general, timer_general *5), 15, "trade")
			do_news(m_str, m_from, math_random(timer_general, timer_general * 10), 7, "trade", npc.id, 1)
			if (_debug == true) then amk.add_spot_on_map(npc.id,"red_location", m_str) end
		end
	end
end

local rspl_tmeout = -1
function send_resupply(sobj)
	local trader_name = reminder.get_npc_name(sobj)
	local rnd_name = amk_names_lists.get_strings(true, "stalker")
	local text = table.remove( news_data.resupply_msgs, math.random(#news_data.resupply_msgs) )
	text = format_text_pairs( text, {rnd_npc = rnd_name} )
	local sms = "%c[gray]"..trader_name.."\\n%c[default]"..text

	local timeout = 5
	local tg = time_global()
	local rnd_timer = math.random(60, 120) *1000
	if tg < rspl_tmeout then
		timeout = (rspl_tmeout - tg)/1000
		rspl_tmeout = rspl_tmeout + rnd_timer
	else
		rspl_tmeout = tg + rnd_timer
	end

	news_manager.send_tip(sms, timeout, nil, 12000)
end


function create_treasurebox()
	local obj = AI:create_free("m_inventory_box", Actor:position(), Actor:level_vertex_id(), Actor:game_vertex_id())
	local t = netpk:get(obj, netpk.fState)
	if game_options.NewTreasures then
		t.custom_data = "[logic]\ncfg = scripts\\new_inventory_box_1.ltx"
	else
		-- Сбросим флаги, чтобы объект не уходил в оффлайн
		t.object_flags = bit_and(t.object_flags, bit_not(197))
		t.custom_data = "[logic]\ncfg = scripts\\new_inventory_box.ltx"
	end
	netpk:set(obj, t)
end

function on_miniquest_reward(trader)
	if (trader and Actor) then
		local money = 0
		local items = ""
		local story_id = -1
		if trader.m_story_id then
			story_id = trader.m_story_id
		elseif trader.story_id then
			story_id = trader:story_id()
		end
		if (story_id == story_ids.Escape_Trader)
			or (story_id == story_ids.bar_Barman)
		then
			local obj = AI:story_object(story_id)
			if obj then
				local t = netpk:get(obj, netpk.fState)
				local cd = netpk:parse_custom_data(t.custom_data)
				cd.microquest.reward_items = string.gsub(cd.microquest.reward_items, "%<nil%>", "")
			--	table.print(cd)
				if (cd.microquest and cd.microquest.reward_money and cd.microquest.reward_items) then
					money = tonumber(cd.microquest.reward_money)
					items = cd.microquest.reward_items
				end
				local res = false
				if money and money > 0 then
					dialogs.relocate_money(trader, money, "in")
					res = true
				end
				if items and items ~= "" then
					local tbl = string.explode(items, ",", true)
					local spawn = {}
					for i,v in pairs(tbl) do
						if v ~= "" then
							table.add(spawn, v)
						end
					end
					for k,v in pairs(spawn) do
						inventory.give_items(k,v)
					end
					res = true
				end
				if res then
					cd.microquest = {}
					cd.microquest.reward_money = 0
					cd.microquest.reward_items = ""
					t.custom_data = netpk:gen_custom_data(cd)
					netpk:set(obj, t, netpk.fState)
				end
			end	
		else
			if story_id == nil then story_id = -1 end
			trace("on_miniquest_reward - strange story_id="..story_id)
		end		
	end	
end


function point_is_far(point, lv, gv, distance)
	local result = true
	if (Actor and point and lv and gv and distance and GGraph:valid_vertex_id(gv)) then
		-- на одном ли уровне?
		local map = AI:level_name(GGraph:vertex(gv):level_id())
		if (map and level.name() == map) then
			-- Достаточно ли далеко?
			if (point:distance_to(Actor:position()) < distance) then
				result = false
			end
		end
   end
   return result
end

function get_nearest_stalker(level, point, dist_max, dist_min)
	local obj = nil
	local map = level
	local min_dist = 1000000
	if (dist_max == nil or dist_max == 0) then dist_max = dist_seen end
	if (dist_min == nil) then dist_min = 0 end
	if (map and point and amk_offline_alife.off_npcs[map] and amk_offline_alife.off_npcs[map].stalkers and #amk_offline_alife.off_npcs[map].stalkers > 0) then
		for k, v in pairs(amk_offline_alife.off_npcs[map].stalkers) do
			if v then
				local stalker = AI:object(v.id)
				-- На одном ли уровне?
				if stalker and stalker.id ~= Actor:id() and stalker.health and stalker.can_switch_online and stalker:can_switch_online() and stalker.m_game_vertex_id and GGraph:valid_vertex_id(stalker.m_game_vertex_id) then
					local s_map = object_level_name(stalker)
					if (map == s_map) then
						if (stalker:health() > 0 and stalker.alive and stalker:alive()==true) then
							local zz = get_npc_community(stalker)
							if (zz == "stalker" or zz == "dolg" or zz == "freedom" or zz == "nebo" or zz == "green") then -- это сталкер
								if (stalker.name and stalker:name() ~= "agr_ratcatcher") then
								-- Достаточно ли далеко?
									local s_dist = stalker.position:distance_to(point)
									if (s_dist <= dist_max and s_dist >= dist_min and s_dist < min_dist) then
										-- А не спамил ли он в последнее время?
										local b_ok = true
										if (spammers and #spammers > 0) then
											local sn = get_npc_name(stalker)
											if (sn ~= "" and sn ~= nil) then
												for sk, sv in pairs(spammers) do
													if (sv == sn) then
														b_ok = false
														break
													end
												end
											end
										end
										if (b_ok == true) then
											min_dist = s_dist
											obj = stalker
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
	return obj
end

function isAlive(story_id)
	if (story_id) then
		local obj = AI:story_object(story_id)
		return obj and obj.alive and obj:alive()
	end
	return false
end

function on_info(info_id)
--	if (info_id) then
--		amk.mylog("on_info : "..tostring(info_id))
--	end
end

function isRadarDeactivated()
	return has_alife_info("bar_deactivate_radar_done")
end

-- ОП-2: Функция отключена, чтобы всегда приходили сообщения о погибших квестовиках и ограбленных нычках
-- Они и так будут приходить, при чём тут эта функция?
local IsolatedLevels = {
	av_peshera = true,
	jupiter_underground = true,
	l03u_agr_underground = true,
	l04u_labx18 = true,
	l08u_brainlab = true,
	l10u_bunker = true,
	l12u_control_monolith = true,
	l12u_sarcofag = true,
	labx8 = true,
	peshera = true,
	warlab = true
}
function isIsolatedLevel(level_name)
	return IsolatedLevels[level_name]~=nil
end

function check_connection(lname, sname)
	local t = nil
	if IsolatedLevels[lname] and IsolatedLevels[sname] == nil then
		t = news_data.disconnect_templates
	elseif IsolatedLevels[sname] and IsolatedLevels[lname] == nil then
		t = news_data.connect_templates
	end
	if t~=nil then
		amk.send_tip(table_random(t), "Статус соединения:", 0, 30, "nano")
	end
end

function is_creature_day(obj_section)
	--проверка на дневной/ночной режим
	local day_begin = sys_ini:r_float_ex(obj_section, "DayTime_Begin", -1, nil)
	local day_end = sys_ini:r_float_ex(obj_section, "DayTime_End", -1, nil)
	if day_begin~=-1 and day_end~=-1 then
		local hrs = level.get_time_hours()
		local de = day_end
		if day_begin>day_end then
			hrs = hrs+24
			de=de+24
		end
		if not (hrs >= day_begin and hrs < de) then
			return false
		end
	end
	return true
end
